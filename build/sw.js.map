{"version":3,"sources":["webpack:///sw.js","webpack:///webpack/bootstrap 8232389d415a7f89aaab","webpack:///./src/modules/public-transport-client/sw.js","webpack:///./~/babel-preset-react-app/~/babel-runtime/regenerator/index.js","webpack:///./src/modules/geo-coords-functions/geoCoords.js","webpack:///./src/modules/public-transport-client/config.js","webpack:///./~/process/browser.js","webpack:///./src/modules/public-transport-client/dataProvider.js","webpack:///./src/modules/public-transport-client/jsonDataStorage.js","webpack:///./src/modules/public-transport-find-optimal-ways/optimalRoute.js","webpack:///./src/modules/public-transport-find-optimal-ways/optimalRoutesCollection.js","webpack:///./src/modules/public-transport-find-optimal-ways/optimalWay.js","webpack:///./src/modules/public-transport-find-optimal-ways/point.js","webpack:///./src/modules/public-transport-find-optimal-ways/points.js","webpack:///./src/modules/public-transport-find-optimal-ways/wayPoint.js","webpack:///./src/modules/public-transport-initialize-data/initialize.js","webpack:///./~/regenerator-runtime/runtime-module.js","webpack:///./~/regenerator-runtime/runtime.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_dataProvider","_dataProvider2","_config","_config2","_optimalRoutesCollection","_optimalRoutesCollection2","console","log","APP_CACHE_NAME","TILE_CACHE_NAME","urlsToCache","self","addEventListener","event","cachePromise","caches","open","then","cache","addAll","waitUntil","loadDataAndInitialize","clients","sender","source","data","includes","push","postMessage","setInterval","clientVsSwNoKillingMessageInterval","requestType","rejected","resolved","params","res","getAllStations","startOptimalRoutePoint","finalOptimalRoutePoint","startTime","transportTypes","goingSpeed","dopTimeMinutes","getOptimalWays","e","result","url","request","respondWith","match","response","add","fetch","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","GeoCoords","this","a","b","earthRadius","pi180","lat1","lat","lat2","long1","lng","long2","Math","acos","sin","cos","apiPublicTransportServer","apiGetStationsUrl","apiGetRoutesUrl","apiGetTimetablesUrl","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","process","nextTick","args","Array","arguments","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","_asyncToGenerator","fn","gen","Promise","resolve","reject","step","arg","info","error","done","err","_regenerator","_regenerator2","_loadDataOnly","_ref","mark","_callee","_response","_response2","wrap","_context","prev","next","_jsonDataStorage2","allStationsJSON","sent","getAllRoutes","allRoutesJSON","getAllTimetables","allTimetablesJSON","allStationsLoaded","text","allStations","JSON","parse","undefined","pushAllStations","allRoutesLoaded","allRoutes","pushAllRoutes","allTimetablesLoaded","allTimetables","pushAllTimetables","stop","loadData","_ref2","_callee2","_context2","loadingStarted","loadDataOnly","_initialize2","_jsonDataStorage","_initialize","DataProvider","_ref3","_callee3","_context3","_ref4","_callee4","_context4","getJsonDataStorageConnection","promise","indexedDB","dbName","onerror","onsuccess","onupgradeneeded","db","objectStore","createObjectStore","storeName","keyPath","createIndex","unique","_x","abrupt","tryPush","transaction","json","_x3","_x4","_x2","getItem","_ref5","_callee6","_context6","_ref6","_callee5","_context5","get","_x6","_x7","_x5","JsonDataStorage","_ref7","_callee7","_context7","t0","_ref8","_callee8","_context8","_ref9","_callee9","_context9","_x8","_ref10","_callee10","allStationsJson","_context10","_x9","_ref11","_callee11","allRoutesJson","_context11","_x10","_ref12","_callee12","allTimetablesJson","_context12","OptimalRoute","myPoints","stationsList","time","types","ignoringRoutesAdd","ignoringList","ignoringRoutes","points","reservedTimeSeconds","myIgnoringFragments","fillStartData","countShortWay","tmpP","finalPoint","toString","previousPoint","coords","startPoint","totalTimeSeconds","totalGoingTime","getTotalGoingTime","totalTransportChangingCount","getTotalTransportChangingCount","isVisited","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","getStationsAround","radius","n","s","distance","_optimalRoute","_optimalRoute2","_optimalWay","_optimalWay2","_points","_points2","_geoCoords","_geoCoords2","OptimalRoutesCollection","_Array","nowPos","needPos","speed","_this","getPrototypeOf","r","selectOptimalRouteWithMinimalMark","t","selectedOptimalRoute","setVisited","ddd","fromWhichRoute","tmpOptimalRoute","tmpJSON","stringify","ok","j","opt","_wayPoint","_wayPoint2","OptimalWay","optimalRoute","totalGoingTimeSeconds","station","reverse","Point","station_or_crds","fromWhichStation","hashcode","stationCode","point","to","tr","type","number","from","goingTime","getTimeForGoingTo","floor","_point","_point2","TableType","table","periodic","Points","collection","currentSelectedPoint","station_or_point","newCreatdPoint","heuristicTimeToFinalPoint","reservedTime","tryUpdate","finalPointCoords","st","contains","selectPointWithMinimalMark","selectedPointStation","selectedPointTotalTimeSeconds","selectedPointStationHashcode","selectedPointFromWhichRoute","momentWhenComingToStation","routesOnStation","selectedPointCoords","selectedPoint","getNextUnvisitedPoint","routes","nextStation","selectedRoute","getNextStation","getTimetable","momentWhenAskingForGoing","waitingTime","findTimeAfter","momentWhenSitInTransport","tbl","goingOnTransportTime","onNextPointtotalTimeSeconds","findElement","distanceToSelectedPoint","newTime","tryingNewTime","currentPoint","previousRouteStation","getPreviousStation","ttt","WayPoint","route","Coords","vehicles","gpsTrack","owner","stations","timetables","stationsJSON","currentStation","nn","dateTmp","Date","setMinutes","setHours","setSeconds","day","getDay","kkk","mnkk","days","stTime","iik","mnii","times","hour","minute","findTimeBefore","stt","initialize","bindRoutesStationsTimetables","tmpArr","tabArr","rr","tmp","find","element","index","routeCode","tmpTab","startInitializingMoment","now","tmpUsedStations","routesCodes","splice","stationsCodes","rr_stationsCodes","tmpUsed","k","mn","ex","timetable","global","g","window","hadRuntime","regeneratorRuntime","getOwnPropertyNames","indexOf","oldRuntime","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","makeInvokeMethod","tryCatch","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","forEach","method","AsyncIterator","invoke","record","hasOwn","__await","unwrapped","enqueue","callInvokeWithMethodAndArg","previousPromise","domain","bind","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","_sent","dispatchException","GenStateSuspendedYield","iterator","return","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","values","iterable","iteratorMethod","iteratorSymbol","isNaN","Op","hasOwnProperty","$Symbol","Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","ctor","awrap","async","iter","keys","object","pop","skipTempReset","charAt","slice","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield"],"mappings":"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","file":"sw.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _dataProvider = __webpack_require__(5);\n\t\n\tvar _dataProvider2 = _interopRequireDefault(_dataProvider);\n\t\n\tvar _config = __webpack_require__(3);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tvar _optimalRoutesCollection = __webpack_require__(8);\n\t\n\tvar _optimalRoutesCollection2 = _interopRequireDefault(_optimalRoutesCollection);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t//import AppClient from './client';\n\t//let s = '123hello123';\n\tconsole.log('Hello from SW...');\n\t\n\tvar APP_CACHE_NAME = 'mosm-app-v1';\n\tvar TILE_CACHE_NAME = 'mosm-tiles-v1';\n\t\n\tvar urlsToCache = ['/', '/favicon.ico', '/static/js/bundle.js', '/static/css/style.css'];\n\t\n\tself.addEventListener('install', function (event) {\n\t  // Perform install steps\n\t  var cachePromise = caches.open(APP_CACHE_NAME).then(function (cache) {\n\t    console.log('install: opened cache');\n\t    return cache.addAll(urlsToCache);\n\t  }).then(function () {\n\t    console.log('install: added all urls to cache');\n\t  });\n\t\n\t  event.waitUntil(cachePromise);\n\t  //event.waitUntil(self.skipWaiting()); // Activate worker immediately\n\t});\n\t\n\tself.addEventListener('activate', function (event) {\n\t  _dataProvider2.default.loadDataAndInitialize();\n\t\n\t  //event.waitUntil(self.clients.claim()); // Become available to all pages\n\t  //console.log('!!!!!!!!!activate');\n\t\n\t  /**/\n\t});\n\t/*\r\n\tvar test = 0;\r\n\tsetInterval(function() {\r\n\t  test++\r\n\t}, 1000)\r\n\t*/\n\t//var ok = true;\n\t\n\tvar clients = [];\n\t\n\tself.addEventListener('message', function (event) {\n\t  var sender = event.source;\n\t  //console.log(event.data);\n\t  if (event.data === 'no-kill-sw') {\n\t    //console.log('SW: client call no-kill-sw.')\n\t    if (clients.includes(sender.id)) {\n\t      return;\n\t    } else {\n\t      clients.push(sender.id);\n\t      sender.postMessage('no-kill-sw-accepted');\n\t      setInterval(function () {\n\t        sender.postMessage(\"no-kill-sw-accepted\");\n\t      }, _config2.default.clientVsSwNoKillingMessageInterval);\n\t    }\n\t  } else if (event.data.requestType === 'optimalWay') {\n\t    console.log('SW: request for optimalWay.');\n\t\n\t    _dataProvider2.default.loadDataAndInitialize();\n\t\n\t    var params = event.data.params;\n\t    var rejected, resolved;\n\t    try {\n\t      var res = new _optimalRoutesCollection2.default(_dataProvider2.default.getAllStations(), params.startOptimalRoutePoint, params.finalOptimalRoutePoint, params.startTime, params.transportTypes, params.goingSpeed, params.dopTimeMinutes);\n\t      //console.log('res = ' + res);\n\t      resolved = res.getOptimalWays();\n\t      //console.log('resolved = ' + resolved);\n\t    } catch (e) {\n\t      console.log(e);\n\t      rejected = e;\n\t    } finally {\n\t      sender.postMessage({\n\t        requestType: 'optimalWayResult',\n\t        result: resolved\n\t      });\n\t    }\n\t  }\n\t  /*if(ok) {\r\n\t    //ok = false;\r\n\t    setInterval(function() {\r\n\t      sender.postMessage({\r\n\t        message: test\r\n\t      });\r\n\t    }, 1000)\r\n\t    //if (event.waitUntil) {\r\n\t    //  event.waitUntil(promise);\r\n\t    //}\r\n\t  }*/\n\t});\n\t\n\tself.addEventListener('fetch', function (event) {\n\t  var url = event.request.url;\n\t\n\t  event.respondWith(caches.match(event.request).then(function (response) {\n\t    // Cache hit - return response\n\t    if (response) {\n\t      return response;\n\t    }\n\t    caches.open(TILE_CACHE_NAME).then(function (cache) {\n\t      return cache.add(url);\n\t    });\n\t\n\t    return fetch(event.request);\n\t  }));\n\t});\n\t\n\t/*self.addEventListener('fetch', function(event) {\r\n\t  event.respondWith(\r\n\t    fetch(event.request).catch(function() {\r\n\t      return caches.match(event.request);\r\n\t    })\r\n\t  );\r\n\t});*/\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(14);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t        value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GeoCoords = function () {\n\t        function GeoCoords() {\n\t                _classCallCheck(this, GeoCoords);\n\t        }\n\t\n\t        _createClass(GeoCoords, null, [{\n\t                key: \"distance\",\n\t                value: function distance(a, b) {\n\t                        var earthRadius = 6372795;\n\t                        var pi180 = 0.017453; // 29251//Math.Round(Math.PI / 180, 5);\n\t                        //const pi2 = 1.5707963;\n\t                        var zz = 1,\n\t                            yy = 1;\n\t                        function taylorSin(x) {\n\t                                yy = x * x;\n\t                                zz = x;\n\t                                return zz - (zz *= yy) / 6 + (zz *= yy) / 120;\n\t                        }\n\t                        function taylorCos(x) {\n\t                                yy = x * x;\n\t                                zz = yy;\n\t                                return 1 - yy / 2 + (zz *= yy) / 24;\n\t                        }\n\t                        /*function taylorArcCos(x) {\r\n\t                            yy = x * x;\r\n\t                            zz = x;\r\n\t                            return pi2 - zz - (zz *= yy)/6 - 3*(zz *= yy)/40;\r\n\t                        }*/\n\t                        /*function taylorAtan(x) {\r\n\t                            yy = x * x;\r\n\t                            zz = x;\r\n\t                            return zz - (zz *= yy) / 3 + (zz *= yy) / 5 - (zz *= yy) / 7 + (zz *= yy) / 9 - (zz *= yy) / 20;\r\n\t                        }*/\n\t\n\t                        // перевести координаты в радианы\n\t                        var lat1 = a.lat * pi180;\n\t                        var lat2 = b.lat * pi180;\n\t                        var long1 = a.lng * pi180;\n\t                        var long2 = b.lng * pi180;\n\t\n\t                        /*\r\n\t                        // косинусы и синусы широт и разницы долгот\r\n\t                        var cl1 = taylorCos(lat1);\r\n\t                        var cl2 = taylorCos(lat2);\r\n\t                        var sl1 = taylorSin(lat1);\r\n\t                        var sl2 = taylorSin(lat2);\r\n\t                        var delta = long2 - long1;\r\n\t                        var cdelta = taylorCos(delta);\r\n\t                        var sdelta = taylorSin(delta);\r\n\t                          // вычисления длины большого круга\r\n\t                        var tmp = cl2 * cdelta;\r\n\t                        var y = Math.sqrt(cl2 * cl2 * sdelta * sdelta + (cl1 * sl2 - sl1 * tmp) * (cl1 * sl2 - sl1 * tmp));\r\n\t                        var x = sl1 * sl2 + cl1 * tmp;\r\n\t                          //\r\n\t                        var ad = Math.atan2(y, x);//taylorAtan(y/x);\r\n\t                        var dist = Math.ceil(ad * earthRadius);//(int)Math.Round(ad * earthRadius, 0);\r\n\t                          //console.log(dist + \" vs \" + Math.acos(Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2))*earthRadius);\r\n\t                        //console.log((taylorSin(lat1)*taylorSin(lat2)+taylorCos(lat1)*taylorCos(lat2)*taylorCos(long1-long2)) + \" vs \" + (Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2)));\r\n\t                          return dist;\r\n\t                        */\n\t\n\t                        //arccos(sin(53.7*pi/180)*sin(53.71*pi/180)+cos(53.7*pi/180)*cos(53.71*pi/180)*cos((23.83-23.82)*pi/180))*6372795\n\t                        //return Math.acos(taylorSin(lat1)*taylorSin(lat2)+taylorCos(lat1)*taylorCos(lat2)*taylorCos(long1-long2))*earthRadius;\n\t                        return Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(long1 - long2)) * earthRadius;\n\t                }\n\t        }]);\n\t\n\t        return GeoCoords;\n\t}();\n\t\n\texports.default = GeoCoords;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    apiPublicTransportServer: \"https://ptp-97126.app.xervo.io/\",\n\t    apiGetStationsUrl: \"https://publictransportproject.000webhostapp.com/new/json/stations.json\", //\"stations\"\n\t    apiGetRoutesUrl: \"https://publictransportproject.000webhostapp.com/new/json/routes.json\", //\"routes\"\n\t    apiGetTimetablesUrl: \"https://publictransportproject.000webhostapp.com/new/json/timetables.json\", //\"timetables\"\n\t\n\t    clientVsSwNoKillingMessageInterval: 30000\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _regenerator = __webpack_require__(1);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _loadDataOnly = function () {\n\t    var _ref = _asyncToGenerator(_regenerator2.default.mark(function _callee() {\n\t        var response, _response, _response2;\n\t\n\t        return _regenerator2.default.wrap(function _callee$(_context) {\n\t            while (1) {\n\t                switch (_context.prev = _context.next) {\n\t                    case 0:\n\t                        _context.next = 2;\n\t                        return _jsonDataStorage2.default.getAllStations();\n\t\n\t                    case 2:\n\t                        allStationsJSON = _context.sent;\n\t                        _context.next = 5;\n\t                        return _jsonDataStorage2.default.getAllRoutes();\n\t\n\t                    case 5:\n\t                        allRoutesJSON = _context.sent;\n\t                        _context.next = 8;\n\t                        return _jsonDataStorage2.default.getAllTimetables();\n\t\n\t                    case 8:\n\t                        allTimetablesJSON = _context.sent;\n\t\n\t                        if (allStationsLoaded) {\n\t                            _context.next = 27;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allStationsJSON == null)) {\n\t                            _context.next = 24;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allStationsJSON\"] === undefined || localStorage[\"allStationsJSON\"] == null\n\t                        console.log(\"Downloading stations from server...\");\n\t\n\t                        _context.next = 14;\n\t                        return fetch(_config2.default.apiGetStationsUrl);\n\t\n\t                    case 14:\n\t                        response = _context.sent;\n\t                        _context.next = 17;\n\t                        return response.text();\n\t\n\t                    case 17:\n\t                        allStationsJSON = _context.sent;\n\t\n\t                        allStations = JSON.parse(allStationsJSON); //await response.json();\n\t\n\t                        if (allStations !== undefined && allStations != null) _jsonDataStorage2.default.pushAllStations(allStationsJSON); //localStorage[\"allStationsJSON\"] = allStationsJSON;\n\t                        allStationsLoaded = true;\n\t                        console.log(\"Stations loaded from server.\");\n\t                        _context.next = 27;\n\t                        break;\n\t\n\t                    case 24:\n\t                        allStations = JSON.parse(allStationsJSON); //localStorage[\"allStationsJSON\"]\n\t                        allStationsLoaded = true;\n\t                        console.log(\"Stations loaded from localStorage.\");\n\t\n\t                    case 27:\n\t                        if (allRoutesLoaded) {\n\t                            _context.next = 45;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allRoutesJSON == null)) {\n\t                            _context.next = 42;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allRoutesJSON\"] === undefined || localStorage[\"allRoutesJSON\"] == null\n\t                        console.log(\"Downloading routes from server...\");\n\t\n\t                        _context.next = 32;\n\t                        return fetch(_config2.default.apiGetRoutesUrl);\n\t\n\t                    case 32:\n\t                        _response = _context.sent;\n\t                        _context.next = 35;\n\t                        return _response.text();\n\t\n\t                    case 35:\n\t                        allRoutesJSON = _context.sent;\n\t\n\t                        allRoutes = JSON.parse(allRoutesJSON); //await response.json();\n\t\n\t                        if (allRoutes !== undefined && allRoutes != null) _jsonDataStorage2.default.pushAllRoutes(allRoutesJSON); //localStorage[\"allRoutesJSON\"] = allRoutesJSON;\n\t                        allRoutesLoaded = true;\n\t                        console.log(\"Routes loaded from server.\");\n\t                        _context.next = 45;\n\t                        break;\n\t\n\t                    case 42:\n\t                        allRoutes = JSON.parse(allRoutesJSON); //localStorage[\"allRoutesJSON\"]\n\t                        allRoutesLoaded = true;\n\t                        console.log(\"Routes loaded from localStorage.\");\n\t\n\t                    case 45:\n\t                        if (allTimetablesLoaded) {\n\t                            _context.next = 63;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allTimetablesJSON == null)) {\n\t                            _context.next = 60;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allTimetablesJSON\"] === undefined || localStorage[\"allTimetablesJSON\"] == null\n\t                        console.log(\"Downloading timetables from server...\");\n\t\n\t                        _context.next = 50;\n\t                        return fetch(_config2.default.apiGetTimetablesUrl);\n\t\n\t                    case 50:\n\t                        _response2 = _context.sent;\n\t                        _context.next = 53;\n\t                        return _response2.text();\n\t\n\t                    case 53:\n\t                        allTimetablesJSON = _context.sent;\n\t\n\t                        allTimetables = JSON.parse(allTimetablesJSON); //await response.json();\n\t\n\t                        if (allTimetables !== undefined && allTimetables != null) _jsonDataStorage2.default.pushAllTimetables(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"] = allTimetablesJSON;\n\t                        allTimetablesLoaded = true;\n\t                        console.log(\"Timetables loaded from server.\");\n\t                        _context.next = 63;\n\t                        break;\n\t\n\t                    case 60:\n\t                        allTimetables = JSON.parse(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"]\n\t                        allTimetablesLoaded = true;\n\t                        console.log(\"Timetables loaded from localStorage.\");\n\t\n\t                    case 63:\n\t                    case 'end':\n\t                        return _context.stop();\n\t                }\n\t            }\n\t        }, _callee, this);\n\t    }));\n\t\n\t    return function _loadDataOnly() {\n\t        return _ref.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar loadData = function () {\n\t    var _ref2 = _asyncToGenerator(_regenerator2.default.mark(function _callee2() {\n\t        return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t            while (1) {\n\t                switch (_context2.prev = _context2.next) {\n\t                    case 0:\n\t                        if (loadingStarted) {\n\t                            _context2.next = 5;\n\t                            break;\n\t                        }\n\t\n\t                        loadingStarted = true;\n\t\n\t                        _context2.next = 4;\n\t                        return _loadDataOnly();\n\t\n\t                    case 4:\n\t\n\t                        if (allStationsLoaded && allRoutesLoaded && allTimetablesLoaded) {\n\t                            (0, _initialize2.default)(allStations, allRoutes, allTimetables);\n\t                        }\n\t\n\t                    case 5:\n\t                    case 'end':\n\t                        return _context2.stop();\n\t                }\n\t            }\n\t        }, _callee2, this);\n\t    }));\n\t\n\t    return function loadData() {\n\t        return _ref2.apply(this, arguments);\n\t    };\n\t}();\n\t\n\t//loadData();\n\t\n\tvar _jsonDataStorage = __webpack_require__(6);\n\t\n\tvar _jsonDataStorage2 = _interopRequireDefault(_jsonDataStorage);\n\t\n\tvar _initialize = __webpack_require__(13);\n\t\n\tvar _initialize2 = _interopRequireDefault(_initialize);\n\t\n\tvar _config = __webpack_require__(3);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Load data.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar allStations = null;\n\tvar allRoutes = null;\n\tvar allTimetables = null;\n\t\n\t//var updatingFromServerInterval = 5000;\n\t\n\tvar loadingStarted = false;\n\t\n\tvar allStationsLoaded = false,\n\t    allRoutesLoaded = false,\n\t    allTimetablesLoaded = false;\n\tvar allStationsJSON = null,\n\t    allRoutesJSON = null,\n\t    allTimetablesJSON = null;\n\t\n\tvar DataProvider = function () {\n\t    function DataProvider() {\n\t        _classCallCheck(this, DataProvider);\n\t    }\n\t\n\t    _createClass(DataProvider, null, [{\n\t        key: 'getAllStations',\n\t        value: function getAllStations() {\n\t            return allStations;\n\t        }\n\t    }, {\n\t        key: 'getAllRoutes',\n\t        value: function getAllRoutes() {\n\t            return allRoutes;\n\t        }\n\t    }, {\n\t        key: 'getAllTimetables',\n\t        value: function getAllTimetables() {\n\t            return allTimetables;\n\t        }\n\t    }, {\n\t        key: 'getAllStationsJSON',\n\t        value: function getAllStationsJSON() {\n\t            return allStationsJSON;\n\t        }\n\t    }, {\n\t        key: 'getAllRoutesJSON',\n\t        value: function getAllRoutesJSON() {\n\t            return allRoutesJSON;\n\t        }\n\t    }, {\n\t        key: 'getAllTimetablesJSON',\n\t        value: function getAllTimetablesJSON() {\n\t            return allTimetablesJSON;\n\t        }\n\t    }, {\n\t        key: 'loadDataAndInitialize',\n\t        value: function () {\n\t            var _ref3 = _asyncToGenerator(_regenerator2.default.mark(function _callee3() {\n\t                return _regenerator2.default.wrap(function _callee3$(_context3) {\n\t                    while (1) {\n\t                        switch (_context3.prev = _context3.next) {\n\t                            case 0:\n\t                                _context3.next = 2;\n\t                                return loadData();\n\t\n\t                            case 2:\n\t                            case 'end':\n\t                                return _context3.stop();\n\t                        }\n\t                    }\n\t                }, _callee3, this);\n\t            }));\n\t\n\t            function loadDataAndInitialize() {\n\t                return _ref3.apply(this, arguments);\n\t            }\n\t\n\t            return loadDataAndInitialize;\n\t        }()\n\t    }, {\n\t        key: 'loadDataOnly',\n\t        value: function () {\n\t            var _ref4 = _asyncToGenerator(_regenerator2.default.mark(function _callee4() {\n\t                return _regenerator2.default.wrap(function _callee4$(_context4) {\n\t                    while (1) {\n\t                        switch (_context4.prev = _context4.next) {\n\t                            case 0:\n\t                                _context4.next = 2;\n\t                                return _loadDataOnly();\n\t\n\t                            case 2:\n\t                            case 'end':\n\t                                return _context4.stop();\n\t                        }\n\t                    }\n\t                }, _callee4, this);\n\t            }));\n\t\n\t            function loadDataOnly() {\n\t                return _ref4.apply(this, arguments);\n\t            }\n\t\n\t            return loadDataOnly;\n\t        }()\n\t    }]);\n\t\n\t    return DataProvider;\n\t}();\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End load data.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\texports.default = DataProvider;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _regenerator = __webpack_require__(1);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar getJsonDataStorageConnection = function () {\n\t    var _ref = _asyncToGenerator(_regenerator2.default.mark(function _callee2() {\n\t        var promise;\n\t        return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t            while (1) {\n\t                switch (_context2.prev = _context2.next) {\n\t                    case 0:\n\t                        promise = new Promise(function (resolve, reject) {\n\t\n\t                            var request = indexedDB.open(dbName, 1);\n\t                            request.onerror = function (event) {\n\t                                reject(event.target.error);\n\t                            };\n\t                            request.onsuccess = function (event) {\n\t                                resolve(event.target.result);\n\t                            };\n\t                            request.onupgradeneeded = function () {\n\t                                var _ref2 = _asyncToGenerator(_regenerator2.default.mark(function _callee(event) {\n\t                                    var db, objectStore, result;\n\t                                    return _regenerator2.default.wrap(function _callee$(_context) {\n\t                                        while (1) {\n\t                                            switch (_context.prev = _context.next) {\n\t                                                case 0:\n\t                                                    db = event.target.result;\n\t                                                    objectStore = db.createObjectStore(storeName, { keyPath: \"name\" });\n\t\n\t                                                    objectStore.createIndex(\"json\", \"json\", { unique: false });\n\t\n\t                                                    _context.next = 5;\n\t                                                    return getJsonDataStorageConnection();\n\t\n\t                                                case 5:\n\t                                                    result = _context.sent;\n\t\n\t                                                    resolve(result);\n\t\n\t                                                case 7:\n\t                                                case \"end\":\n\t                                                    return _context.stop();\n\t                                            }\n\t                                        }\n\t                                    }, _callee, this);\n\t                                }));\n\t\n\t                                return function (_x) {\n\t                                    return _ref2.apply(this, arguments);\n\t                                };\n\t                            }();\n\t                        });\n\t                        _context2.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context2.abrupt(\"return\", _context2.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context2.stop();\n\t                }\n\t            }\n\t        }, _callee2, this);\n\t    }));\n\t\n\t    return function getJsonDataStorageConnection() {\n\t        return _ref.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar tryPush = function () {\n\t    var _ref3 = _asyncToGenerator(_regenerator2.default.mark(function _callee4(obj) {\n\t        var promise;\n\t        return _regenerator2.default.wrap(function _callee4$(_context4) {\n\t            while (1) {\n\t                switch (_context4.prev = _context4.next) {\n\t                    case 0:\n\t                        promise = new Promise(function () {\n\t                            var _ref4 = _asyncToGenerator(_regenerator2.default.mark(function _callee3(resolve, reject) {\n\t                                var db, transaction, objectStore, request;\n\t                                return _regenerator2.default.wrap(function _callee3$(_context3) {\n\t                                    while (1) {\n\t                                        switch (_context3.prev = _context3.next) {\n\t                                            case 0:\n\t                                                _context3.next = 2;\n\t                                                return getJsonDataStorageConnection();\n\t\n\t                                            case 2:\n\t                                                db = _context3.sent;\n\t\n\t                                                //console.log(db);\n\t                                                transaction = db.transaction([storeName], \"readwrite\");\n\t                                                objectStore = transaction.objectStore(storeName);\n\t                                                request = objectStore.add({\n\t                                                    name: obj.name,\n\t                                                    json: obj.json\n\t                                                });\n\t\n\t                                                request.onerror = function (event) {\n\t                                                    reject(event.target.error);\n\t                                                };\n\t                                                request.onsuccess = function (event) {\n\t                                                    resolve(event.target.result);\n\t                                                };\n\t\n\t                                            case 8:\n\t                                            case \"end\":\n\t                                                return _context3.stop();\n\t                                        }\n\t                                    }\n\t                                }, _callee3, this);\n\t                            }));\n\t\n\t                            return function (_x3, _x4) {\n\t                                return _ref4.apply(this, arguments);\n\t                            };\n\t                        }());\n\t                        _context4.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context4.abrupt(\"return\", _context4.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context4.stop();\n\t                }\n\t            }\n\t        }, _callee4, this);\n\t    }));\n\t\n\t    return function tryPush(_x2) {\n\t        return _ref3.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar getItem = function () {\n\t    var _ref5 = _asyncToGenerator(_regenerator2.default.mark(function _callee6(name) {\n\t        var promise;\n\t        return _regenerator2.default.wrap(function _callee6$(_context6) {\n\t            while (1) {\n\t                switch (_context6.prev = _context6.next) {\n\t                    case 0:\n\t                        promise = new Promise(function () {\n\t                            var _ref6 = _asyncToGenerator(_regenerator2.default.mark(function _callee5(resolve, reject) {\n\t                                var db, transaction, objectStore, request;\n\t                                return _regenerator2.default.wrap(function _callee5$(_context5) {\n\t                                    while (1) {\n\t                                        switch (_context5.prev = _context5.next) {\n\t                                            case 0:\n\t                                                _context5.next = 2;\n\t                                                return getJsonDataStorageConnection();\n\t\n\t                                            case 2:\n\t                                                db = _context5.sent;\n\t                                                transaction = db.transaction([storeName]);\n\t                                                objectStore = transaction.objectStore(storeName);\n\t                                                request = objectStore.get(name);\n\t\n\t                                                request.onsuccess = function (event) {\n\t                                                    if (event.target.result !== undefined) {\n\t                                                        resolve(event.target.result.json);\n\t                                                    } else {\n\t                                                        //resolve(null);\n\t                                                        reject(event.target.error);\n\t                                                    }\n\t                                                };\n\t                                                request.onerror = function (event) {\n\t                                                    reject(event.target.error);\n\t                                                };\n\t\n\t                                            case 8:\n\t                                            case \"end\":\n\t                                                return _context5.stop();\n\t                                        }\n\t                                    }\n\t                                }, _callee5, this);\n\t                            }));\n\t\n\t                            return function (_x6, _x7) {\n\t                                return _ref6.apply(this, arguments);\n\t                            };\n\t                        }());\n\t                        _context6.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context6.abrupt(\"return\", _context6.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context6.stop();\n\t                }\n\t            }\n\t        }, _callee6, this);\n\t    }));\n\t\n\t    return function getItem(_x5) {\n\t        return _ref5.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\t//import ApiConfig from './config';\n\t\n\tvar dbName = \"public_transport2\";\n\tvar storeName = \"json_data\";\n\t\n\tvar JsonDataStorage = function () {\n\t    function JsonDataStorage() {\n\t        _classCallCheck(this, JsonDataStorage);\n\t    }\n\t\n\t    _createClass(JsonDataStorage, null, [{\n\t        key: \"getAllStations\",\n\t        value: function () {\n\t            var _ref7 = _asyncToGenerator(_regenerator2.default.mark(function _callee7() {\n\t                return _regenerator2.default.wrap(function _callee7$(_context7) {\n\t                    while (1) {\n\t                        switch (_context7.prev = _context7.next) {\n\t                            case 0:\n\t                                _context7.prev = 0;\n\t                                _context7.next = 3;\n\t                                return getItem('allStations');\n\t\n\t                            case 3:\n\t                                return _context7.abrupt(\"return\", _context7.sent);\n\t\n\t                            case 6:\n\t                                _context7.prev = 6;\n\t                                _context7.t0 = _context7[\"catch\"](0);\n\t                                return _context7.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context7.stop();\n\t                        }\n\t                    }\n\t                }, _callee7, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllStations() {\n\t                return _ref7.apply(this, arguments);\n\t            }\n\t\n\t            return getAllStations;\n\t        }()\n\t    }, {\n\t        key: \"getAllRoutes\",\n\t        value: function () {\n\t            var _ref8 = _asyncToGenerator(_regenerator2.default.mark(function _callee8() {\n\t                return _regenerator2.default.wrap(function _callee8$(_context8) {\n\t                    while (1) {\n\t                        switch (_context8.prev = _context8.next) {\n\t                            case 0:\n\t                                _context8.prev = 0;\n\t                                _context8.next = 3;\n\t                                return getItem('allRoutes');\n\t\n\t                            case 3:\n\t                                return _context8.abrupt(\"return\", _context8.sent);\n\t\n\t                            case 6:\n\t                                _context8.prev = 6;\n\t                                _context8.t0 = _context8[\"catch\"](0);\n\t                                return _context8.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context8.stop();\n\t                        }\n\t                    }\n\t                }, _callee8, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllRoutes() {\n\t                return _ref8.apply(this, arguments);\n\t            }\n\t\n\t            return getAllRoutes;\n\t        }()\n\t    }, {\n\t        key: \"getAllTimetables\",\n\t        value: function () {\n\t            var _ref9 = _asyncToGenerator(_regenerator2.default.mark(function _callee9() {\n\t                return _regenerator2.default.wrap(function _callee9$(_context9) {\n\t                    while (1) {\n\t                        switch (_context9.prev = _context9.next) {\n\t                            case 0:\n\t                                _context9.prev = 0;\n\t                                _context9.next = 3;\n\t                                return getItem('allTimetables');\n\t\n\t                            case 3:\n\t                                return _context9.abrupt(\"return\", _context9.sent);\n\t\n\t                            case 6:\n\t                                _context9.prev = 6;\n\t                                _context9.t0 = _context9[\"catch\"](0);\n\t                                return _context9.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context9.stop();\n\t                        }\n\t                    }\n\t                }, _callee9, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllTimetables() {\n\t                return _ref9.apply(this, arguments);\n\t            }\n\t\n\t            return getAllTimetables;\n\t        }()\n\t    }, {\n\t        key: \"pushAllStations\",\n\t        value: function () {\n\t            var _ref10 = _asyncToGenerator(_regenerator2.default.mark(function _callee10(allStationsJson) {\n\t                return _regenerator2.default.wrap(function _callee10$(_context10) {\n\t                    while (1) {\n\t                        switch (_context10.prev = _context10.next) {\n\t                            case 0:\n\t                                _context10.prev = 0;\n\t                                _context10.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allStations',\n\t                                    json: allStationsJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context10.abrupt(\"return\", _context10.sent);\n\t\n\t                            case 6:\n\t                                _context10.prev = 6;\n\t                                _context10.t0 = _context10[\"catch\"](0);\n\t                                return _context10.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context10.stop();\n\t                        }\n\t                    }\n\t                }, _callee10, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllStations(_x8) {\n\t                return _ref10.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllStations;\n\t        }()\n\t    }, {\n\t        key: \"pushAllRoutes\",\n\t        value: function () {\n\t            var _ref11 = _asyncToGenerator(_regenerator2.default.mark(function _callee11(allRoutesJson) {\n\t                return _regenerator2.default.wrap(function _callee11$(_context11) {\n\t                    while (1) {\n\t                        switch (_context11.prev = _context11.next) {\n\t                            case 0:\n\t                                _context11.prev = 0;\n\t                                _context11.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allRoutes',\n\t                                    json: allRoutesJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context11.abrupt(\"return\", _context11.sent);\n\t\n\t                            case 6:\n\t                                _context11.prev = 6;\n\t                                _context11.t0 = _context11[\"catch\"](0);\n\t                                return _context11.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context11.stop();\n\t                        }\n\t                    }\n\t                }, _callee11, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllRoutes(_x9) {\n\t                return _ref11.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllRoutes;\n\t        }()\n\t    }, {\n\t        key: \"pushAllTimetables\",\n\t        value: function () {\n\t            var _ref12 = _asyncToGenerator(_regenerator2.default.mark(function _callee12(allTimetablesJson) {\n\t                return _regenerator2.default.wrap(function _callee12$(_context12) {\n\t                    while (1) {\n\t                        switch (_context12.prev = _context12.next) {\n\t                            case 0:\n\t                                _context12.prev = 0;\n\t                                _context12.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allTimetables',\n\t                                    json: allTimetablesJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context12.abrupt(\"return\", _context12.sent);\n\t\n\t                            case 6:\n\t                                _context12.prev = 6;\n\t                                _context12.t0 = _context12[\"catch\"](0);\n\t                                return _context12.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context12.stop();\n\t                        }\n\t                    }\n\t                }, _callee12, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllTimetables(_x10) {\n\t                return _ref12.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllTimetables;\n\t        }()\n\t    }]);\n\t\n\t    return JsonDataStorage;\n\t}();\n\t\n\texports.default = JsonDataStorage;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t        value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//import Points from './points';\n\t//import IgnoringFragments from './ignoringFragments';\n\t\n\tvar OptimalRoute = function () {\n\t        function OptimalRoute(myPoints, stationsList, /*nowPos, needPos,*/time, types, goingSpeed, dopTimeMinutes, ignoringRoutesAdd, ignoringList) {\n\t                _classCallCheck(this, OptimalRoute);\n\t\n\t                if (ignoringRoutesAdd != null) this.ignoringRoutes = ignoringRoutesAdd;else this.ignoringRoutes = [];\n\t\n\t                this.points = [];\n\t\n\t                //this.needPos = needPos;\n\t                //this.nowPos = nowPos;\n\t                this.goingSpeed = goingSpeed;\n\t                this.time = time;\n\t                var reservedTimeSeconds = 60 * dopTimeMinutes;\n\t\n\t                this.types = types;\n\t\n\t                this.myIgnoringFragments = null;\n\t                //if (ignoringList != null) this.myIgnoringFragments = new IgnoringFragments(ignoringList);\n\t                //else this.myIgnoringFragments = new IgnoringFragments();\n\t\n\t                //var myPoints = new Points(nowPos, needPos);\n\t\n\t                myPoints.fillStartData(stationsList, goingSpeed, reservedTimeSeconds, this.myIgnoringFragments);\n\t\n\t                // Находим кратчайшие пути до всех вершин:\n\t                myPoints.countShortWay(this.ignoringRoutes, this.myIgnoringFragments, time, types, goingSpeed, reservedTimeSeconds);\n\t\n\t                var tmpP = myPoints.finalPoint;\n\t                this.points.push(tmpP.toString()); ////\n\t                while (tmpP.previousPoint != null) {\n\t                        tmpP = tmpP.previousPoint; //\n\t                        this.points.push(tmpP.toString());\n\t                        if (tmpP.previousPoint == null && tmpP.coords !== myPoints.startPoint.coords) throw new Error(\"Где-то удалилась часть маршрута...\");\n\t                }\n\t\n\t                this.totalTimeSeconds = myPoints.finalPoint.totalTimeSeconds;\n\t                this.totalGoingTime = myPoints.finalPoint.getTotalGoingTime();\n\t                this.totalTransportChangingCount = myPoints.finalPoint.getTotalTransportChangingCount();\n\t\n\t                this.myPoints = myPoints;\n\t\n\t                this.isVisited = false;\n\t        }\n\t\n\t        _createClass(OptimalRoute, [{\n\t                key: \"setVisited\",\n\t                value: function setVisited() {\n\t                        this.isVisited = true;\n\t                }\n\t        }]);\n\t\n\t        return OptimalRoute;\n\t}();\n\t\n\texports.default = OptimalRoute;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _optimalRoute = __webpack_require__(7);\n\t\n\tvar _optimalRoute2 = _interopRequireDefault(_optimalRoute);\n\t\n\tvar _optimalWay = __webpack_require__(9);\n\t\n\tvar _optimalWay2 = _interopRequireDefault(_optimalWay);\n\t\n\tvar _points = __webpack_require__(11);\n\t\n\tvar _points2 = _interopRequireDefault(_points);\n\t\n\tvar _geoCoords = __webpack_require__(2);\n\t\n\tvar _geoCoords2 = _interopRequireDefault(_geoCoords);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //import IgnoringFragments from './ignoringFragments';\n\t\n\t\n\tvar distance = _geoCoords2.default.distance;\n\tfunction getStationsAround(allStations, coords, radius) {\n\t    var result = [];\n\t    for (var i = 0, n = allStations.length, s = allStations[0]; i < n; s = allStations[++i]) {\n\t        if (s != null && distance(s.coords, coords) < radius) result.push(s);\n\t    }\n\t    return result;\n\t}\n\t\n\tvar OptimalRoutesCollection = function (_Array) {\n\t    _inherits(OptimalRoutesCollection, _Array);\n\t\n\t    /*getOptimalWays() {\r\n\t        var result = [];\r\n\t        for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n\t            result.push(new OptimalWay(r));\r\n\t        }\r\n\t        return result;\r\n\t    }*/\n\t    /*selectOptimalRouteWithMinimalMark() {\r\n\t        var p = null;\r\n\t        for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n\t            if (!(t.isVisited)) {\r\n\t                p = t;\r\n\t                for (t = this[++i]; i < n; t = this[++i]) {\r\n\t                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n\t                        p = t;\r\n\t                    }\r\n\t                }\r\n\t                return p;\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    }*/\n\t    function OptimalRoutesCollection(allStations, nowPos, needPos, time, types, speed, dopTimeMinutes) {\n\t        _classCallCheck(this, OptimalRoutesCollection);\n\t\n\t        var _this = _possibleConstructorReturn(this, (OptimalRoutesCollection.__proto__ || Object.getPrototypeOf(OptimalRoutesCollection)).call(this));\n\t\n\t        _this.getOptimalWays = function () {\n\t            var result = [];\n\t            for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\n\t                result.push(new _optimalWay2.default(r));\n\t            }\n\t            return result;\n\t        };\n\t        _this.selectOptimalRouteWithMinimalMark = function () {\n\t            var p = null;\n\t            for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\n\t                if (!t.isVisited) {\n\t                    p = t;\n\t                    for (t = this[++i]; i < n; t = this[++i]) {\n\t                        if (!t.isVisited && t.totalTimeSeconds < p.totalTimeSeconds) {\n\t                            p = t;\n\t                        }\n\t                    }\n\t                    return p;\n\t                }\n\t            }\n\t            return null;\n\t        };\n\t\n\t        var myPoints = new _points2.default(nowPos, needPos);\n\t        // Получим \"начальный\" список станций:\n\t        var stationsList = getStationsAround(allStations, nowPos, distance(nowPos, needPos));\n\t\n\t        _this.push(new _optimalRoute2.default(myPoints, stationsList, /*nowPos, needPos,*/time, types, speed, dopTimeMinutes));\n\t\n\t        var ignoringRoutes = [];\n\t\n\t        //var ignoringFragments = new IgnoringFragments();\n\t\n\t        for (var selectedOptimalRoute = _this[0]; selectedOptimalRoute != null; selectedOptimalRoute.setVisited(), selectedOptimalRoute = _this.selectOptimalRouteWithMinimalMark()) {\n\t            var ddd = 0.25;\n\t\n\t            ignoringRoutes = [];\n\t            // Проходим по всем ребрам выбранного пути и строим новые маршруты при удалении ребер:\n\t            for (var tmpP = selectedOptimalRoute.myPoints.finalPoint; tmpP.previousPoint != null; tmpP = tmpP.previousPoint) {\n\t                //if(tmpP == null) console.log(\"err in optimalRoutesCollection.js\");\n\t                if (tmpP.fromWhichRoute != null && !ignoringRoutes.includes(tmpP.fromWhichRoute)) ignoringRoutes.push(tmpP.fromWhichRoute);\n\t            }\n\t            for (var i = 0, n = ignoringRoutes.length, r = ignoringRoutes[0]; i < n; r = ignoringRoutes[++i]) {\n\t                if (selectedOptimalRoute.ignoringRoutes.includes(r)) continue;\n\t                var ignoringRoutesAdd = [];\n\t                ignoringRoutesAdd = ignoringRoutesAdd.concat(selectedOptimalRoute.ignoringRoutes);\n\t                ignoringRoutesAdd.push(r);\n\t                myPoints = new _points2.default(nowPos, needPos);\n\t                var tmpOptimalRoute = new _optimalRoute2.default(myPoints, stationsList, /*nowPos, needPos,*/time, types, speed, dopTimeMinutes, ignoringRoutesAdd);\n\t\n\t                if (tmpOptimalRoute.totalTimeSeconds <= _this[0].totalTimeSeconds / ddd) {\n\t                    var tmpJSON = JSON.stringify(tmpOptimalRoute.points);\n\t                    var ok = false;\n\t                    for (var j = 0, m = _this.length, opt = _this[0]; j < m; opt = _this[++j]) {\n\t                        if (JSON.stringify(opt.points) === tmpJSON) {\n\t                            ok = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (ok) continue;\n\t                    _this.push(tmpOptimalRoute);\n\t                }\n\t            }\n\t        }\n\t        return _this;\n\t    }\n\t\n\t    return OptimalRoutesCollection;\n\t}(Array);\n\t\n\texports.default = OptimalRoutesCollection;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _wayPoint = __webpack_require__(12);\n\t\n\tvar _wayPoint2 = _interopRequireDefault(_wayPoint);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar OptimalWay = function OptimalWay(optimalRoute) {\n\t    _classCallCheck(this, OptimalWay);\n\t\n\t    this.totalTimeSeconds = optimalRoute.totalTimeSeconds;\n\t    this.totalGoingTimeSeconds = optimalRoute.totalGoingTime;\n\t    this.totalTransportChangingCount = optimalRoute.totalTransportChangingCount;\n\t    this.points = [];\n\t\n\t    for (var tmpP = optimalRoute.myPoints.finalPoint; tmpP != null; tmpP = tmpP.previousPoint) {\n\t        this.points.push(new _wayPoint2.default(tmpP.totalTimeSeconds, tmpP.station, tmpP.fromWhichRoute, tmpP.coords));\n\t    }\n\t    this.points.reverse();\n\t};\n\t\n\texports.default = OptimalWay;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Point = function () {\n\t    function Point(totalTimeSeconds, station_or_crds, fromWhichStation, fromWhichRoute) {\n\t        _classCallCheck(this, Point);\n\t\n\t        if (station_or_crds.hashcode !== undefined) {\n\t            this.station = station_or_crds;\n\t            this.stationCode = station_or_crds.hashcode;\n\t            station_or_crds.point = this;\n\t            this.coords = station_or_crds.coords;\n\t        } else {\n\t            this.coords = station_or_crds;\n\t            this.station = null;\n\t            this.stationCode = null;\n\t        }\n\t        this.totalTimeSeconds = totalTimeSeconds;\n\t        this.fromWhichStation = fromWhichStation;\n\t        this.fromWhichRoute = fromWhichRoute;\n\t\n\t        this.isVisited = false;\n\t\n\t        this.previousPoint = null;\n\t    }\n\t\n\t    _createClass(Point, [{\n\t        key: \"tryUpdate\",\n\t        value: function tryUpdate(totalTimeSeconds, previousPoint, fromWhichStation, fromWhichRoute) {\n\t            if (totalTimeSeconds < this.totalTimeSeconds) {\n\t                this.fromWhichRoute = fromWhichRoute;\n\t                this.previousPoint = previousPoint;\n\t                this.totalTimeSeconds = totalTimeSeconds;\n\t                this.fromWhichStation = fromWhichStation;\n\t\n\t                return true;\n\t            }\n\t            return false;\n\t        }\n\t    }, {\n\t        key: \"setVisited\",\n\t        value: function setVisited() {\n\t            this.isVisited = true;\n\t        }\n\t    }, {\n\t        key: \"toString\",\n\t        value: function toString() {\n\t            var to, tr; //, from, p;\n\t            //if (this.fromWhichStation != null) from = this.fromWhichStation.name;\n\t            //else from = \"null\";\n\t            if (this.station != null) to = this.station.name;else to = \"null\";\n\t            if (this.fromWhichRoute != null) tr = this.fromWhichRoute.type + \" \" + this.fromWhichRoute.number + \" \" + this.fromWhichRoute.from + \" - \" + this.fromWhichRoute.to;else tr = \"пешком\";\n\t            //if (this.previousPoint != null) p = this.previousPoint.toString();\n\t            //else p = \"null\";\n\t            return (/*p+\" -->> */\"(\" + this.totalTimeSeconds + \") \" + to + \" (\" + tr + \")\"\n\t            ); // from \" + from + \" to\n\t        }\n\t    }, {\n\t        key: \"getTotalGoingTime\",\n\t        value: function getTotalGoingTime() {\n\t            var goingTime = 0;\n\t            var tmpP = this;\n\t            //this.points.Add(tmpP.ToString());\n\t            while (tmpP.previousPoint != null) {\n\t                if (tmpP.fromWhichRoute == null /*&& tmpP.fromWhichRoute.hashcode == null*/) goingTime += tmpP.totalTimeSeconds - tmpP.previousPoint.totalTimeSeconds;\n\t                tmpP = tmpP.previousPoint;\n\t            }\n\t            return goingTime;\n\t        }\n\t    }, {\n\t        key: \"getTotalTransportChangingCount\",\n\t        value: function getTotalTransportChangingCount() {\n\t            var result = 0;\n\t            var tmpP = this;\n\t            //this.points.Add(tmpP.ToString());\n\t            while (tmpP.previousPoint != null) {\n\t                if (tmpP.fromWhichRoute != null && tmpP.fromWhichRoute.hashcode != null && tmpP.fromWhichRoute !== tmpP.previousPoint.fromWhichRoute) result++;\n\t                tmpP = tmpP.previousPoint;\n\t            }\n\t            return result;\n\t        }\n\t    }]);\n\t\n\t    return Point;\n\t}();\n\t\n\texports.default = Point;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _point = __webpack_require__(10);\n\t\n\tvar _point2 = _interopRequireDefault(_point);\n\t\n\tvar _geoCoords = __webpack_require__(2);\n\t\n\tvar _geoCoords2 = _interopRequireDefault(_geoCoords);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar distance = _geoCoords2.default.distance;\n\t\n\tfunction getTimeForGoingTo(distance, goingSpeed) {\n\t    return Math.floor(distance / (goingSpeed / 3.6));\n\t}\n\t\n\tvar TableType = { table: 1, periodic: 2 };\n\t\n\tvar Points = function () {\n\t    function Points(nowPos, needPos) {\n\t        _classCallCheck(this, Points);\n\t\n\t        this.collection = [];\n\t        this.startPoint = new _point2.default(0, nowPos, null, null);\n\t        this.finalPoint = new _point2.default(2160000000, needPos, null, null);\n\t        this.currentSelectedPoint = null;\n\t    }\n\t\n\t    _createClass(Points, [{\n\t        key: 'findElement',\n\t        value: function findElement(station_or_point) {\n\t            if (station_or_point.hashcode != null) {\n\t                if (station_or_point.point != null) return station_or_point.point;\n\t                var newCreatdPoint = new _point2.default(2160000000, station_or_point, null, null);\n\t                newCreatdPoint.heuristicTimeToFinalPoint = distance(newCreatdPoint.coords, this.finalPoint.coords) / 5;\n\t                this.collection.push(newCreatdPoint);\n\t                return newCreatdPoint;\n\t            } else {\n\t                for (var i = 0, n = this.collection.length, p = this.collection[0]; i < n; p = this.collection[++i]) {\n\t                    if (p.coords === station_or_point.coords && p.stationCode === station_or_point.stationCode) return p;\n\t                }\n\t                return null;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'fillStartData',\n\t        value: function fillStartData(stationsList, goingSpeed, reservedTime, myIgnoringFragments) {\n\t            this.finalPoint.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, this.finalPoint.coords), goingSpeed) + 1800 /*+ TimeSpan.FromMinutes(20)*/, this.startPoint, null, null);\n\t            var finalPointCoords = this.finalPoint.coords;\n\t            for (var i = 0, n = stationsList.length, st = stationsList[0]; i < n; st = stationsList[++i]) {\n\t                if (myIgnoringFragments != null && myIgnoringFragments.contains(st.hashcode, null, null)) continue;\n\t\n\t                var add = new _point2.default(2160000000, st, null, null);\n\t                add.heuristicTimeToFinalPoint = distance(add.coords, finalPointCoords) / 5;\n\t                add.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, st.coords), goingSpeed) + reservedTime, this.startPoint, null, null);\n\t                this.collection.push(add);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getNextUnvisitedPoint',\n\t        value: function getNextUnvisitedPoint() {\n\t            if (this.currentSelectedPoint != null) this.currentSelectedPoint.setVisited();\n\t\n\t            this.currentSelectedPoint = this.selectPointWithMinimalMark();\n\t\n\t            return this.currentSelectedPoint;\n\t        }\n\t    }, {\n\t        key: 'selectPointWithMinimalMark',\n\t        value: function selectPointWithMinimalMark() {\n\t            var p = null;\n\t            for (var i = 0, n = this.collection.length, t = this.collection[0]; i < n; t = this.collection[++i]) {\n\t                if (!t.isVisited) {\n\t                    p = t;\n\t                    //var euristicTimeSecondsToFinalPoint = distance(p.coords, this.finalPoint.coords) / 5; // Оценка оставшегося времени пути в секундах.\n\t                    for (t = this.collection[++i]; i < n; t = this.collection[++i]) {\n\t                        //var tmpEuristic = distance(t.coords, this.finalPoint.coords) / 5;\n\t                        if (!t.isVisited && t.totalTimeSeconds + t.heuristicTimeToFinalPoint < p.totalTimeSeconds + p.heuristicTimeToFinalPoint) {\n\t                            p = t;\n\t                            //euristicTimeSecondsToFinalPoint = tmpEuristic;\n\t                        }\n\t                    }\n\t                    return p;\n\t                }\n\t            }\n\t            return null;\n\t        }\n\t    }, {\n\t        key: 'countShortWay',\n\t        value: function countShortWay(ignoringRoutes, myIgnoringFragments, time, types, speed, reservedTime) {\n\t            //TimeSpan overLimitResedvedTime = TimeSpan.FromMinutes(20);\n\t\n\t            for (var selectedPoint = this.getNextUnvisitedPoint(), selectedPointStation, selectedPointTotalTimeSeconds, selectedPointStationHashcode, selectedPointFromWhichRoute, momentWhenComingToStation, routesOnStation, selectedPointCoords; selectedPoint != null; selectedPoint = this.getNextUnvisitedPoint()) {\n\t                //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t                selectedPointTotalTimeSeconds = selectedPoint.totalTimeSeconds;\n\t                if (selectedPointTotalTimeSeconds > this.finalPoint.totalTimeSeconds /* + overLimitResedvedTime*/) //... Пропускаем и удаляем, если значение метки превышает минимальное время до пункта назначения.\n\t                    {\n\t                        break;\n\t                    }\n\t                selectedPointStation = selectedPoint.station;\n\t                selectedPointStationHashcode = selectedPointStation.hashcode;\n\t                selectedPointFromWhichRoute = selectedPoint.fromWhichRoute;\n\t                if (selectedPointStation != null) {\n\t                    // Момент, когда мы прибудем на остановку:\n\t                    momentWhenComingToStation = time + selectedPointTotalTimeSeconds;\n\t                    // Загружаем маршруты, проходящие через остановку:\n\t                    routesOnStation = null; // = routesOnStation = Database.GetRoutesOnStation(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);\n\t                    if (selectedPointStation.routes != null) routesOnStation = selectedPointStation.routes;else continue;\n\t\n\t                    for (var i = 0, n = routesOnStation.length, selectedRoute = routesOnStation[0], nextStation; i < n; selectedRoute = routesOnStation[++i]) {\n\t                        if (ignoringRoutes != null && ignoringRoutes.includes(selectedRoute)) continue;\n\t                        if (types.includes(selectedRoute.type)) {\n\t                            // Следующая остановка у данного тран спорта:\n\t                            nextStation = selectedRoute.getNextStation(selectedPointStation);\n\t\n\t                            /*// Код остановки, на которую попадем на данном транспорте:\r\n\t                            string nextCode = selectedRoute.getNextStationCodeAfter(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);*/\n\t                            if (nextStation /*nextCode*/ != null) // Если остановка не является конечной, то:\n\t                                {\n\t                                    // Загружаем расписание:\n\t                                    var table = selectedRoute.getTimetable(selectedPointStation); //Database.getTimetable(selectedPointStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\t                                    // Блокируем попытку попасть указанным транспортом на указанную остановку:\n\t                                    if (myIgnoringFragments != null && myIgnoringFragments.contains(nextStation.hashcode /*nextCode*/, selectedRoute.hashcode, selectedPointStationHashcode)) continue;\n\t\n\t                                    if (table.type === TableType.table) // Если это точное расписание, то:\n\t                                        {\n\t                                            // Минимальный начальный момент, с который можно начинать ожидать посадку:\n\t                                            var momentWhenAskingForGoing = momentWhenComingToStation;\n\t\n\t                                            // Резервируем дополнительное время, если будем пересаживаться на другой маршрут:\n\t                                            //if (selectedPoint.RouteCode == null || selectedPoint.RouteCode != selectedRoute.hashcode) momentWhenAskingForGoing += reservedTime;\n\t                                            if (selectedPointFromWhichRoute != null && selectedPointFromWhichRoute !== selectedRoute) momentWhenAskingForGoing += reservedTime;\n\t\n\t                                            // Подсчитываем, сколько будем ожидать этот транспорт на остановке:\n\t                                            var waitingTime = table.findTimeAfter(momentWhenAskingForGoing);\n\t\n\t                                            // Момент, когда мы сядем в транспорт:\n\t                                            var momentWhenSitInTransport = momentWhenAskingForGoing + waitingTime;\n\t\n\t                                            /*// Следующая остановка у данного транспорта:\r\n\t                                            Station nextStation = Database.GetStationByHashcode(nextCode, databaseMysqlConnection, canReadDataFromLocalCopy: true);*/\n\t\n\t                                            // И соответствующее расписание на этой остановке:\n\t                                            var tbl = selectedRoute.getTimetable(nextStation); //Database.getTimetable(nextStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\t\n\t                                            // (сколько будем ехать до следующей остановки):\n\t                                            var goingOnTransportTime = tbl.findTimeAfter(momentWhenSitInTransport);\n\t\n\t                                            // Метка времени:\n\t                                            var onNextPointtotalTimeSeconds = momentWhenSitInTransport - momentWhenComingToStation + goingOnTransportTime + selectedPointTotalTimeSeconds;\n\t\n\t                                            if (this.findElement(nextStation).tryUpdate(onNextPointtotalTimeSeconds, selectedPoint, selectedPointStation, selectedRoute)) {\n\t                                                //console.log(\"upd...\");\n\t                                            }\n\t                                        } else if (table.type === TableType.periodic) {\n\t                                        throw new Error();\n\t                                    }\n\t                                }\n\t                        }\n\t                    }\n\t                }\n\t                selectedPointCoords = selectedPoint.coords;\n\t                // Нет смысла идти пешком \"транзитом\" через остановку:\n\t                if (selectedPointFromWhichRoute == null) continue;\n\t\n\t                // Попробуем пройти пешком до других \"вершин\":\n\t                for (var j = 0, m = this.collection.length, p = this.collection[0], distanceToSelectedPoint, goingTime, newTime; j < m; p = this.collection[++j]) {\n\t                    if (!p.isVisited && p !== selectedPoint) {\n\t                        // Блокируем попытку дойти пешком до указанной остановки:\n\t                        if (myIgnoringFragments != null && myIgnoringFragments.contains(p.stationCode, null, selectedPointStationHashcode)) continue;\n\t\n\t                        distanceToSelectedPoint = distance(selectedPointCoords, p.coords);\n\t\n\t                        goingTime = getTimeForGoingTo(distanceToSelectedPoint, speed /*, true, sp*/);\n\t\n\t                        newTime = selectedPointTotalTimeSeconds + goingTime + reservedTime;\n\t                        /*if (p != myFinishPoint)*/ // newTime += reservedTime;\n\t\n\t                        if (p.tryUpdate(newTime, selectedPoint, selectedPointStation, null)) {\n\t                            //console.log(\"upd...\");\n\t                        }\n\t                    }\n\t                }if (myIgnoringFragments != null && myIgnoringFragments.contains(null, null, selectedPointStationHashcode)) continue;\n\t\n\t                var tryingNewTime = selectedPointTotalTimeSeconds + getTimeForGoingTo(distance(selectedPointCoords, this.finalPoint.coords), speed);\n\t                if (this.finalPoint.tryUpdate(tryingNewTime, selectedPoint, selectedPointStation, null)) {\n\t                    //console.log(\"upd: \" + selectedPointStation.hashcode);\n\t                }\n\t            }\n\t\n\t            // Сокращаем время ходьбы пешком до минимума и избавляемся от \"бессмысленных\" пересадок, сохраняя общее время неизменным:\n\t            var currentPoint = this.finalPoint.previousPoint;\n\t            while (currentPoint !== this.startPoint) {\n\t                if (currentPoint == null) {\n\t                    console.log(\"err 1 in points.js\");\n\t                    console.log(this.finalPoint);\n\t                }\n\t                var r = currentPoint.fromWhichRoute;\n\t                if (r != null) {\n\t                    var previousPoint = currentPoint.previousPoint;\n\t                    //if(previousPoint == null) console.log(\"err 2 in points.js\");\n\t                    if (previousPoint !== this.startPoint && previousPoint.fromWhichRoute !== r) // Если на предыдущую остановку мы добрались другим транспортом, то:\n\t                        {\n\t                            var previousRouteStation = r.getPreviousStation(previousPoint.station);\n\t                            if (previousRouteStation != null) {\n\t                                var point = previousRouteStation.point;\n\t                                if (point != null && point.isVisited) {\n\t                                    var ttt = r.getTimetable(previousRouteStation);\n\t                                    if (ttt != null) {\n\t                                        //var ddd = time + previousPoint.totalTimeSeconds;\n\t                                        //var moment = r.getTimetable(currentPoint.station).findTimeAfter(ddd);\n\t                                        //var tmp_time = ttt.findTimeBefore(ddd + moment);\n\t\n\t                                        //var momentArriveOnCurrent = previousPoint.totalTimeSeconds + moment;\n\t                                        //var momentSittingOnPrevious = momentArriveOnCurrent + tmp_time;\n\t                                        /*bool bbb = point.fromWhichRoute != null && point.fromWhichRoute.getTimetable(point.station) != null && point.fromWhichRoute.getTimetable(point.station).findTimeAfter(time + point.totalTimeSeconds) <= previousPoint.totalTimeSeconds + moment + tmp_time;\r\n\t                                        if (bbb)\r\n\t                                        {\r\n\t                                            previousPoint.fromWhichRoute = r;\r\n\t                                            previousPoint.previousPoint = point;////!bbb && point.totalTimeSeconds <= momentSittingOnPrevious &&\r\n\t                                        }\r\n\t                                        else */\n\t                                        if ( /*point.totalGoingTime>=previousPoint.totalGoingTime || */point.totalTimeSeconds <= previousPoint.totalTimeSeconds /* && point.totalGoingTime <= previousPoint.totalGoingTime*/) {\n\t                                                previousPoint.fromWhichRoute = r;\n\t                                                previousPoint.previousPoint = point;\n\t                                            }\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                }\n\t                currentPoint = currentPoint.previousPoint;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return Points;\n\t}();\n\t\n\texports.default = Points;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar WayPoint = function WayPoint(time, station, route, coords) {\n\t    _classCallCheck(this, WayPoint);\n\t\n\t    this.time = time;\n\t    this.station = station == null ? null : { hashcode: station.hashcode, name: station.name, routes: null, Coords: { lat: station.coords.lat, lng: station.coords.lng } };\n\t    this.route = route == null ? null : { vehicles: [], gpsTrack: null, hashcode: route.hashcode, number: route.number, type: route.type, from: route.from, to: route.to, owner: \"\", stations: null, timetables: null, stationsJSON: null };\n\t    this.coords = coords;\n\t};\n\t\n\texports.default = WayPoint;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Initailize.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tfunction getNextStation(currentStation) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n\t            if (this.stations[j][t] === currentStation) {\n\t                if (t + 1 !== nn) return this.stations[j][t + 1];else return null;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction getPreviousStation(currentStation) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n\t            if (this.stations[j][t] === currentStation) {\n\t                if (t !== nn) return this.stations[j][t - 1];else return null;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction getTimetable(station) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var i = 0, n = this.stations[j].length; i < n; i++) {\n\t            if (this.stations[j][i] === station) {\n\t                return this.timetables[j][i];\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction findTimeAfter(time) {\n\t    var dateTmp = new Date();\n\t    dateTmp.setMinutes(0);\n\t    dateTmp.setHours(0);\n\t    dateTmp.setSeconds(time);\n\t    var day = dateTmp.getDay();\n\t    //foreach (Table t in table)\n\t    for (var kkk = 0, mnkk = this.table.length, t = this.table[0]; kkk < mnkk; t = this.table[++kkk]) {\n\t        if (t.days.includes(day)) {\n\t\n\t            //foreach (SimpleTime st in t.times)\n\t            for (var iik = 0, mnii = t.times.length, st = t.times[0], stTime; iik < mnii; st = t.times[++iik]) {\n\t                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n\t                //\n\t                stTime = st.hour * 3600 + st.minute * 60;\n\t                if (stTime >= time /*.Second + time.Minute * 60 + time.Hour * 3600*/ /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n\t                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n\t                        return stTime - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/;\n\t                    }\n\t            }\n\t            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/ + 86400;\n\t            break;\n\t        }\n\t    }\n\t    return 2160000000;\n\t    //throw new Exception();\n\t}\n\tfunction findTimeBefore(time) {\n\t    var dateTmp = new Date();\n\t    dateTmp.setMinutes(0);\n\t    dateTmp.setHours(0);\n\t    dateTmp.setSeconds(time);\n\t    var day = dateTmp.getDay();\n\t    for (var kkk = 0, mnkk = this.table.length, t = this.table[0], ok = false, st; kkk < mnkk; t = this.table[++kkk]) {\n\t        if (t.days.includes(day)) {\n\t            ok = false;\n\t            st = null;\n\t            for (var iik = 0, mnii = t.times.length, stt = t.times[0]; iik < mnii; stt = t.times[++iik]) {\n\t                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n\t                //\n\t                if (stt.hour * 3600 + stt.minute * 60 <= time /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n\t                        ok = true;\n\t                        st = stt;\n\t                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n\t                    } else break;\n\t            }\n\t            if (ok) return st.hour * 3600 + st.minute * 60 - time;\n\t            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time - 86400;\n\t            break;\n\t        }\n\t    }\n\t    return 0; //TimeSpan.FromDays(0/*-25000*/);\n\t    //throw new Exception();\n\t}\n\t\n\tfunction initialize(allStations, allRoutes, allTimetables) {\n\t    //alert(allStations.length);\n\t    //alert(allRoutes.length);\n\t    //alert(allTimetables.length);\n\t\n\t    console.log(\"Start initializing...\");\n\t    var startInitializingMoment = Date.now();\n\t\n\t    var tmpUsedStations = [];\n\t\n\t    function bindRoutesStationsTimetables(station, tmpArr, tabArr, rr) {\n\t        if (station.routes == null) station.routes = [];\n\t        //console.log(station.routes);//!!!\n\t        if (!station.routes.includes(rr)) station.routes.push(rr);\n\t        tmpArr.push(station);\n\t\n\t        var tmp = allTimetables.find(function (element, index, array) {\n\t            return element.stationCode === station.hashcode && element.routeCode === rr.hashcode;\n\t        });\n\t        var tmpTab = tmp == null ? null : tmp;\n\t\n\t        tabArr.push(tmpTab);\n\t    }\n\t\n\t    for (var i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\n\t        if (currentStation.routesCodes == null || currentStation.routesCodes.length === 0) {\n\t            allStations.splice(i, 1);\n\t            n = allStations.length;\n\t        } else i++;\n\t    }\n\t\n\t    for (var _i = 0, _n = allRoutes.length, rr = allRoutes[0]; _i < _n; rr = allRoutes[++_i]) {\n\t\n\t        rr.getNextStation = getNextStation;\n\t        rr.getPreviousStation = getPreviousStation;\n\t        rr.getTimetable = getTimetable;\n\t\n\t        if (rr.stationsCodes == null || rr.stationsCodes.length === 0) continue;\n\t\n\t        try {\n\t            //if (rr.stationsCodes[rr.stationsCodes.Length - 1] != ']') continue;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\t            rr.stations = [[], []];\n\t            rr.timetables = [[], []];\n\t\n\t            for (var index = 0, tmpArr = [], tabArr = []; index <= 1; index++) {\n\t                var rr_stationsCodes = rr.stationsCodes;\n\t                if (rr_stationsCodes[index] == null || rr_stationsCodes[index].length === 0) continue;\n\t                for (var j = 0, m = rr_stationsCodes[index].length, stationCode = rr_stationsCodes[index][0]; j < m; stationCode = rr_stationsCodes[index][++j]) {\n\t                    var tmpUsed = false;\n\t                    for (var k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\n\t                        if (station != null && station.hashcode === stationCode) {\n\t                            bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\n\t                            tmpUsed = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (!tmpUsed) {\n\t                        for (var _k = 0, _mn = allStations.length, _station = allStations[0]; _k < _mn; _station = allStations[++_k]) {\n\t                            if (_station != null && _station.hashcode === stationCode) {\n\t                                bindRoutesStationsTimetables(_station, tmpArr, tabArr, rr);\n\t                                if (!tmpUsedStations.includes(_station)) tmpUsedStations.push(_station);\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                rr.stations[index] = tmpArr;\n\t                rr.timetables[index] = tabArr;\n\t            }\n\t        } catch (ex) {\n\t            console.log(ex /*.message*/);\n\t            continue;\n\t        }\n\t    }\n\t\n\t    for (var _i2 = 0, _n2 = allTimetables.length, timetable = allTimetables[0]; _i2 < _n2; timetable = allTimetables[++_i2]) {\n\t        timetable.findTimeAfter = findTimeAfter;\n\t        timetable.findTimeBefore = findTimeBefore;\n\t    }\n\t\n\t    //...\n\t    /*\r\n\t    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n\t        if (currentStation.routes == undefined || currentStation.routes == null || currentStation.routes.length == 0) {\r\n\t            allStations.splice(i, 1);\r\n\t            n = allStations.length;\r\n\t        }\r\n\t        else i++;\r\n\t    }\r\n\t    */\n\t\n\t    console.log(\"Initialized. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t    //console.log(\"\\n\\n\" + JSON.stringify(allTimetables[0]) + \"\\n\\n\");\n\t    //alert(distance({ lat: allStations[0].xCoord, lng: allStations[0].yCoord }, { lat: allStations[5].xCoord, lng: allStations[5].yCoord }));\n\t\n\t\n\t    //for (let t = 0; t < 1000; t++) var ttt = GetStationsAround(allStations[0].coords, 30000).length;\n\t    //console.log(\"test. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t\n\t\n\t    //global.initialized = true;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End initailize.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\texports.default = initialize;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be\n\t// kept identical to the way it is obtained in runtime.js\n\tvar g =\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this;\n\t\n\t// Use `getOwnPropertyNames` because not all browsers support calling\n\t// `hasOwnProperty` on the global `self` object in a worker. See #183.\n\tvar hadRuntime = g.regeneratorRuntime &&\n\t  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\t\n\t// Save the old regeneratorRuntime in case it needs to be restored later.\n\tvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\t\n\t// Force reevalutation of runtime.js.\n\tg.regeneratorRuntime = undefined;\n\t\n\tmodule.exports = __webpack_require__(15);\n\t\n\tif (hadRuntime) {\n\t  // Restore the original runtime.\n\t  g.regeneratorRuntime = oldRuntime;\n\t} else {\n\t  // Remove the global property added by runtime.js.\n\t  try {\n\t    delete g.regeneratorRuntime;\n\t  } catch(e) {\n\t    g.regeneratorRuntime = undefined;\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {/**\n\t * Copyright (c) 2014, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n\t * additional grant of patent rights can be found in the PATENTS file in\n\t * the same directory.\n\t */\n\t\n\t!(function(global) {\n\t  \"use strict\";\n\t\n\t  var Op = Object.prototype;\n\t  var hasOwn = Op.hasOwnProperty;\n\t  var undefined; // More compressible than void 0.\n\t  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n\t  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n\t  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n\t  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\t\n\t  var inModule = typeof module === \"object\";\n\t  var runtime = global.regeneratorRuntime;\n\t  if (runtime) {\n\t    if (inModule) {\n\t      // If regeneratorRuntime is defined globally and we're in a module,\n\t      // make the exports object identical to regeneratorRuntime.\n\t      module.exports = runtime;\n\t    }\n\t    // Don't bother evaluating the rest of this file if the runtime was\n\t    // already defined globally.\n\t    return;\n\t  }\n\t\n\t  // Define the runtime globally (as expected by generated code) as either\n\t  // module.exports (if we're in a module) or a new, empty object.\n\t  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\t\n\t  function wrap(innerFn, outerFn, self, tryLocsList) {\n\t    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n\t    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n\t    var generator = Object.create(protoGenerator.prototype);\n\t    var context = new Context(tryLocsList || []);\n\t\n\t    // The ._invoke method unifies the implementations of the .next,\n\t    // .throw, and .return methods.\n\t    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\t\n\t    return generator;\n\t  }\n\t  runtime.wrap = wrap;\n\t\n\t  // Try/catch helper to minimize deoptimizations. Returns a completion\n\t  // record like context.tryEntries[i].completion. This interface could\n\t  // have been (and was previously) designed to take a closure to be\n\t  // invoked without arguments, but in all the cases we care about we\n\t  // already have an existing method we want to call, so there's no need\n\t  // to create a new function object. We can even get away with assuming\n\t  // the method takes exactly one argument, since that happens to be true\n\t  // in every case, so we don't have to touch the arguments object. The\n\t  // only additional allocation required is the completion record, which\n\t  // has a stable shape and so hopefully should be cheap to allocate.\n\t  function tryCatch(fn, obj, arg) {\n\t    try {\n\t      return { type: \"normal\", arg: fn.call(obj, arg) };\n\t    } catch (err) {\n\t      return { type: \"throw\", arg: err };\n\t    }\n\t  }\n\t\n\t  var GenStateSuspendedStart = \"suspendedStart\";\n\t  var GenStateSuspendedYield = \"suspendedYield\";\n\t  var GenStateExecuting = \"executing\";\n\t  var GenStateCompleted = \"completed\";\n\t\n\t  // Returning this object from the innerFn has the same effect as\n\t  // breaking out of the dispatch switch statement.\n\t  var ContinueSentinel = {};\n\t\n\t  // Dummy constructor functions that we use as the .constructor and\n\t  // .constructor.prototype properties for functions that return Generator\n\t  // objects. For full spec compliance, you may wish to configure your\n\t  // minifier not to mangle the names of these two functions.\n\t  function Generator() {}\n\t  function GeneratorFunction() {}\n\t  function GeneratorFunctionPrototype() {}\n\t\n\t  // This is a polyfill for %IteratorPrototype% for environments that\n\t  // don't natively support it.\n\t  var IteratorPrototype = {};\n\t  IteratorPrototype[iteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t\n\t  var getProto = Object.getPrototypeOf;\n\t  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\t  if (NativeIteratorPrototype &&\n\t      NativeIteratorPrototype !== Op &&\n\t      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n\t    // This environment has a native %IteratorPrototype%; use it instead\n\t    // of the polyfill.\n\t    IteratorPrototype = NativeIteratorPrototype;\n\t  }\n\t\n\t  var Gp = GeneratorFunctionPrototype.prototype =\n\t    Generator.prototype = Object.create(IteratorPrototype);\n\t  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\t  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n\t  GeneratorFunctionPrototype[toStringTagSymbol] =\n\t    GeneratorFunction.displayName = \"GeneratorFunction\";\n\t\n\t  // Helper for defining the .next, .throw, and .return methods of the\n\t  // Iterator interface in terms of a single ._invoke method.\n\t  function defineIteratorMethods(prototype) {\n\t    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n\t      prototype[method] = function(arg) {\n\t        return this._invoke(method, arg);\n\t      };\n\t    });\n\t  }\n\t\n\t  runtime.isGeneratorFunction = function(genFun) {\n\t    var ctor = typeof genFun === \"function\" && genFun.constructor;\n\t    return ctor\n\t      ? ctor === GeneratorFunction ||\n\t        // For the native GeneratorFunction constructor, the best we can\n\t        // do is to check its .name property.\n\t        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n\t      : false;\n\t  };\n\t\n\t  runtime.mark = function(genFun) {\n\t    if (Object.setPrototypeOf) {\n\t      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n\t    } else {\n\t      genFun.__proto__ = GeneratorFunctionPrototype;\n\t      if (!(toStringTagSymbol in genFun)) {\n\t        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n\t      }\n\t    }\n\t    genFun.prototype = Object.create(Gp);\n\t    return genFun;\n\t  };\n\t\n\t  // Within the body of any async function, `await x` is transformed to\n\t  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n\t  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n\t  // meant to be awaited.\n\t  runtime.awrap = function(arg) {\n\t    return { __await: arg };\n\t  };\n\t\n\t  function AsyncIterator(generator) {\n\t    function invoke(method, arg, resolve, reject) {\n\t      var record = tryCatch(generator[method], generator, arg);\n\t      if (record.type === \"throw\") {\n\t        reject(record.arg);\n\t      } else {\n\t        var result = record.arg;\n\t        var value = result.value;\n\t        if (value &&\n\t            typeof value === \"object\" &&\n\t            hasOwn.call(value, \"__await\")) {\n\t          return Promise.resolve(value.__await).then(function(value) {\n\t            invoke(\"next\", value, resolve, reject);\n\t          }, function(err) {\n\t            invoke(\"throw\", err, resolve, reject);\n\t          });\n\t        }\n\t\n\t        return Promise.resolve(value).then(function(unwrapped) {\n\t          // When a yielded Promise is resolved, its final value becomes\n\t          // the .value of the Promise<{value,done}> result for the\n\t          // current iteration. If the Promise is rejected, however, the\n\t          // result for this iteration will be rejected with the same\n\t          // reason. Note that rejections of yielded Promises are not\n\t          // thrown back into the generator function, as is the case\n\t          // when an awaited Promise is rejected. This difference in\n\t          // behavior between yield and await is important, because it\n\t          // allows the consumer to decide what to do with the yielded\n\t          // rejection (swallow it and continue, manually .throw it back\n\t          // into the generator, abandon iteration, whatever). With\n\t          // await, by contrast, there is no opportunity to examine the\n\t          // rejection reason outside the generator function, so the\n\t          // only option is to throw it from the await expression, and\n\t          // let the generator function handle the exception.\n\t          result.value = unwrapped;\n\t          resolve(result);\n\t        }, reject);\n\t      }\n\t    }\n\t\n\t    if (typeof process === \"object\" && process.domain) {\n\t      invoke = process.domain.bind(invoke);\n\t    }\n\t\n\t    var previousPromise;\n\t\n\t    function enqueue(method, arg) {\n\t      function callInvokeWithMethodAndArg() {\n\t        return new Promise(function(resolve, reject) {\n\t          invoke(method, arg, resolve, reject);\n\t        });\n\t      }\n\t\n\t      return previousPromise =\n\t        // If enqueue has been called before, then we want to wait until\n\t        // all previous Promises have been resolved before calling invoke,\n\t        // so that results are always delivered in the correct order. If\n\t        // enqueue has not been called before, then it is important to\n\t        // call invoke immediately, without waiting on a callback to fire,\n\t        // so that the async generator function has the opportunity to do\n\t        // any necessary setup in a predictable way. This predictability\n\t        // is why the Promise constructor synchronously invokes its\n\t        // executor callback, and why async functions synchronously\n\t        // execute code before the first await. Since we implement simple\n\t        // async functions in terms of async generators, it is especially\n\t        // important to get this right, even though it requires care.\n\t        previousPromise ? previousPromise.then(\n\t          callInvokeWithMethodAndArg,\n\t          // Avoid propagating failures to Promises returned by later\n\t          // invocations of the iterator.\n\t          callInvokeWithMethodAndArg\n\t        ) : callInvokeWithMethodAndArg();\n\t    }\n\t\n\t    // Define the unified helper method that is used to implement .next,\n\t    // .throw, and .return (see defineIteratorMethods).\n\t    this._invoke = enqueue;\n\t  }\n\t\n\t  defineIteratorMethods(AsyncIterator.prototype);\n\t  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t  runtime.AsyncIterator = AsyncIterator;\n\t\n\t  // Note that simple async functions are implemented on top of\n\t  // AsyncIterator objects; they just return a Promise for the value of\n\t  // the final result produced by the iterator.\n\t  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n\t    var iter = new AsyncIterator(\n\t      wrap(innerFn, outerFn, self, tryLocsList)\n\t    );\n\t\n\t    return runtime.isGeneratorFunction(outerFn)\n\t      ? iter // If outerFn is a generator, return the full iterator.\n\t      : iter.next().then(function(result) {\n\t          return result.done ? result.value : iter.next();\n\t        });\n\t  };\n\t\n\t  function makeInvokeMethod(innerFn, self, context) {\n\t    var state = GenStateSuspendedStart;\n\t\n\t    return function invoke(method, arg) {\n\t      if (state === GenStateExecuting) {\n\t        throw new Error(\"Generator is already running\");\n\t      }\n\t\n\t      if (state === GenStateCompleted) {\n\t        if (method === \"throw\") {\n\t          throw arg;\n\t        }\n\t\n\t        // Be forgiving, per 25.3.3.3.3 of the spec:\n\t        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t        return doneResult();\n\t      }\n\t\n\t      context.method = method;\n\t      context.arg = arg;\n\t\n\t      while (true) {\n\t        var delegate = context.delegate;\n\t        if (delegate) {\n\t          var delegateResult = maybeInvokeDelegate(delegate, context);\n\t          if (delegateResult) {\n\t            if (delegateResult === ContinueSentinel) continue;\n\t            return delegateResult;\n\t          }\n\t        }\n\t\n\t        if (context.method === \"next\") {\n\t          // Setting context._sent for legacy support of Babel's\n\t          // function.sent implementation.\n\t          context.sent = context._sent = context.arg;\n\t\n\t        } else if (context.method === \"throw\") {\n\t          if (state === GenStateSuspendedStart) {\n\t            state = GenStateCompleted;\n\t            throw context.arg;\n\t          }\n\t\n\t          context.dispatchException(context.arg);\n\t\n\t        } else if (context.method === \"return\") {\n\t          context.abrupt(\"return\", context.arg);\n\t        }\n\t\n\t        state = GenStateExecuting;\n\t\n\t        var record = tryCatch(innerFn, self, context);\n\t        if (record.type === \"normal\") {\n\t          // If an exception is thrown from innerFn, we leave state ===\n\t          // GenStateExecuting and loop back for another invocation.\n\t          state = context.done\n\t            ? GenStateCompleted\n\t            : GenStateSuspendedYield;\n\t\n\t          if (record.arg === ContinueSentinel) {\n\t            continue;\n\t          }\n\t\n\t          return {\n\t            value: record.arg,\n\t            done: context.done\n\t          };\n\t\n\t        } else if (record.type === \"throw\") {\n\t          state = GenStateCompleted;\n\t          // Dispatch the exception by looping back around to the\n\t          // context.dispatchException(context.arg) call above.\n\t          context.method = \"throw\";\n\t          context.arg = record.arg;\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  // Call delegate.iterator[context.method](context.arg) and handle the\n\t  // result, either by returning a { value, done } result from the\n\t  // delegate iterator, or by modifying context.method and context.arg,\n\t  // setting context.delegate to null, and returning the ContinueSentinel.\n\t  function maybeInvokeDelegate(delegate, context) {\n\t    var method = delegate.iterator[context.method];\n\t    if (method === undefined) {\n\t      // A .throw or .return when the delegate iterator has no .throw\n\t      // method always terminates the yield* loop.\n\t      context.delegate = null;\n\t\n\t      if (context.method === \"throw\") {\n\t        if (delegate.iterator.return) {\n\t          // If the delegate iterator has a return method, give it a\n\t          // chance to clean up.\n\t          context.method = \"return\";\n\t          context.arg = undefined;\n\t          maybeInvokeDelegate(delegate, context);\n\t\n\t          if (context.method === \"throw\") {\n\t            // If maybeInvokeDelegate(context) changed context.method from\n\t            // \"return\" to \"throw\", let that override the TypeError below.\n\t            return ContinueSentinel;\n\t          }\n\t        }\n\t\n\t        context.method = \"throw\";\n\t        context.arg = new TypeError(\n\t          \"The iterator does not provide a 'throw' method\");\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var record = tryCatch(method, delegate.iterator, context.arg);\n\t\n\t    if (record.type === \"throw\") {\n\t      context.method = \"throw\";\n\t      context.arg = record.arg;\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var info = record.arg;\n\t\n\t    if (! info) {\n\t      context.method = \"throw\";\n\t      context.arg = new TypeError(\"iterator result is not an object\");\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    if (info.done) {\n\t      // Assign the result of the finished delegate to the temporary\n\t      // variable specified by delegate.resultName (see delegateYield).\n\t      context[delegate.resultName] = info.value;\n\t\n\t      // Resume execution at the desired location (see delegateYield).\n\t      context.next = delegate.nextLoc;\n\t\n\t      // If context.method was \"throw\" but the delegate handled the\n\t      // exception, let the outer generator proceed normally. If\n\t      // context.method was \"next\", forget context.arg since it has been\n\t      // \"consumed\" by the delegate iterator. If context.method was\n\t      // \"return\", allow the original .return call to continue in the\n\t      // outer generator.\n\t      if (context.method !== \"return\") {\n\t        context.method = \"next\";\n\t        context.arg = undefined;\n\t      }\n\t\n\t    } else {\n\t      // Re-yield the result returned by the delegate method.\n\t      return info;\n\t    }\n\t\n\t    // The delegate iterator is finished, so forget it and continue with\n\t    // the outer generator.\n\t    context.delegate = null;\n\t    return ContinueSentinel;\n\t  }\n\t\n\t  // Define Generator.prototype.{next,throw,return} in terms of the\n\t  // unified ._invoke helper method.\n\t  defineIteratorMethods(Gp);\n\t\n\t  Gp[toStringTagSymbol] = \"Generator\";\n\t\n\t  Gp.toString = function() {\n\t    return \"[object Generator]\";\n\t  };\n\t\n\t  function pushTryEntry(locs) {\n\t    var entry = { tryLoc: locs[0] };\n\t\n\t    if (1 in locs) {\n\t      entry.catchLoc = locs[1];\n\t    }\n\t\n\t    if (2 in locs) {\n\t      entry.finallyLoc = locs[2];\n\t      entry.afterLoc = locs[3];\n\t    }\n\t\n\t    this.tryEntries.push(entry);\n\t  }\n\t\n\t  function resetTryEntry(entry) {\n\t    var record = entry.completion || {};\n\t    record.type = \"normal\";\n\t    delete record.arg;\n\t    entry.completion = record;\n\t  }\n\t\n\t  function Context(tryLocsList) {\n\t    // The root entry object (effectively a try statement without a catch\n\t    // or a finally block) gives us a place to store values thrown from\n\t    // locations where there is no enclosing try statement.\n\t    this.tryEntries = [{ tryLoc: \"root\" }];\n\t    tryLocsList.forEach(pushTryEntry, this);\n\t    this.reset(true);\n\t  }\n\t\n\t  runtime.keys = function(object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t      keys.push(key);\n\t    }\n\t    keys.reverse();\n\t\n\t    // Rather than returning an object with a next method, we keep\n\t    // things simple and return the next function itself.\n\t    return function next() {\n\t      while (keys.length) {\n\t        var key = keys.pop();\n\t        if (key in object) {\n\t          next.value = key;\n\t          next.done = false;\n\t          return next;\n\t        }\n\t      }\n\t\n\t      // To avoid creating an additional object, we just hang the .value\n\t      // and .done properties off the next function object itself. This\n\t      // also ensures that the minifier will not anonymize the function.\n\t      next.done = true;\n\t      return next;\n\t    };\n\t  };\n\t\n\t  function values(iterable) {\n\t    if (iterable) {\n\t      var iteratorMethod = iterable[iteratorSymbol];\n\t      if (iteratorMethod) {\n\t        return iteratorMethod.call(iterable);\n\t      }\n\t\n\t      if (typeof iterable.next === \"function\") {\n\t        return iterable;\n\t      }\n\t\n\t      if (!isNaN(iterable.length)) {\n\t        var i = -1, next = function next() {\n\t          while (++i < iterable.length) {\n\t            if (hasOwn.call(iterable, i)) {\n\t              next.value = iterable[i];\n\t              next.done = false;\n\t              return next;\n\t            }\n\t          }\n\t\n\t          next.value = undefined;\n\t          next.done = true;\n\t\n\t          return next;\n\t        };\n\t\n\t        return next.next = next;\n\t      }\n\t    }\n\t\n\t    // Return an iterator with no values.\n\t    return { next: doneResult };\n\t  }\n\t  runtime.values = values;\n\t\n\t  function doneResult() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  Context.prototype = {\n\t    constructor: Context,\n\t\n\t    reset: function(skipTempReset) {\n\t      this.prev = 0;\n\t      this.next = 0;\n\t      // Resetting context._sent for legacy support of Babel's\n\t      // function.sent implementation.\n\t      this.sent = this._sent = undefined;\n\t      this.done = false;\n\t      this.delegate = null;\n\t\n\t      this.method = \"next\";\n\t      this.arg = undefined;\n\t\n\t      this.tryEntries.forEach(resetTryEntry);\n\t\n\t      if (!skipTempReset) {\n\t        for (var name in this) {\n\t          // Not sure about the optimal order of these conditions:\n\t          if (name.charAt(0) === \"t\" &&\n\t              hasOwn.call(this, name) &&\n\t              !isNaN(+name.slice(1))) {\n\t            this[name] = undefined;\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    stop: function() {\n\t      this.done = true;\n\t\n\t      var rootEntry = this.tryEntries[0];\n\t      var rootRecord = rootEntry.completion;\n\t      if (rootRecord.type === \"throw\") {\n\t        throw rootRecord.arg;\n\t      }\n\t\n\t      return this.rval;\n\t    },\n\t\n\t    dispatchException: function(exception) {\n\t      if (this.done) {\n\t        throw exception;\n\t      }\n\t\n\t      var context = this;\n\t      function handle(loc, caught) {\n\t        record.type = \"throw\";\n\t        record.arg = exception;\n\t        context.next = loc;\n\t\n\t        if (caught) {\n\t          // If the dispatched exception was caught by a catch block,\n\t          // then let that catch block handle the exception normally.\n\t          context.method = \"next\";\n\t          context.arg = undefined;\n\t        }\n\t\n\t        return !! caught;\n\t      }\n\t\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        var record = entry.completion;\n\t\n\t        if (entry.tryLoc === \"root\") {\n\t          // Exception thrown outside of any try block that could handle\n\t          // it, so set the completion value of the entire function to\n\t          // throw the exception.\n\t          return handle(\"end\");\n\t        }\n\t\n\t        if (entry.tryLoc <= this.prev) {\n\t          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n\t          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\t\n\t          if (hasCatch && hasFinally) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            } else if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else if (hasCatch) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            }\n\t\n\t          } else if (hasFinally) {\n\t            if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else {\n\t            throw new Error(\"try statement without catch or finally\");\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    abrupt: function(type, arg) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc <= this.prev &&\n\t            hasOwn.call(entry, \"finallyLoc\") &&\n\t            this.prev < entry.finallyLoc) {\n\t          var finallyEntry = entry;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (finallyEntry &&\n\t          (type === \"break\" ||\n\t           type === \"continue\") &&\n\t          finallyEntry.tryLoc <= arg &&\n\t          arg <= finallyEntry.finallyLoc) {\n\t        // Ignore the finally entry if control is not jumping to a\n\t        // location outside the try/catch block.\n\t        finallyEntry = null;\n\t      }\n\t\n\t      var record = finallyEntry ? finallyEntry.completion : {};\n\t      record.type = type;\n\t      record.arg = arg;\n\t\n\t      if (finallyEntry) {\n\t        this.method = \"next\";\n\t        this.next = finallyEntry.finallyLoc;\n\t        return ContinueSentinel;\n\t      }\n\t\n\t      return this.complete(record);\n\t    },\n\t\n\t    complete: function(record, afterLoc) {\n\t      if (record.type === \"throw\") {\n\t        throw record.arg;\n\t      }\n\t\n\t      if (record.type === \"break\" ||\n\t          record.type === \"continue\") {\n\t        this.next = record.arg;\n\t      } else if (record.type === \"return\") {\n\t        this.rval = this.arg = record.arg;\n\t        this.method = \"return\";\n\t        this.next = \"end\";\n\t      } else if (record.type === \"normal\" && afterLoc) {\n\t        this.next = afterLoc;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    finish: function(finallyLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.finallyLoc === finallyLoc) {\n\t          this.complete(entry.completion, entry.afterLoc);\n\t          resetTryEntry(entry);\n\t          return ContinueSentinel;\n\t        }\n\t      }\n\t    },\n\t\n\t    \"catch\": function(tryLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc === tryLoc) {\n\t          var record = entry.completion;\n\t          if (record.type === \"throw\") {\n\t            var thrown = record.arg;\n\t            resetTryEntry(entry);\n\t          }\n\t          return thrown;\n\t        }\n\t      }\n\t\n\t      // The context.catch method must only be called with a location\n\t      // argument that corresponds to a known catch block.\n\t      throw new Error(\"illegal catch attempt\");\n\t    },\n\t\n\t    delegateYield: function(iterable, resultName, nextLoc) {\n\t      this.delegate = {\n\t        iterator: values(iterable),\n\t        resultName: resultName,\n\t        nextLoc: nextLoc\n\t      };\n\t\n\t      if (this.method === \"next\") {\n\t        // Deliberately forget the last sent value so that we don't\n\t        // accidentally pass it on to the delegate.\n\t        this.arg = undefined;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t  };\n\t})(\n\t  // Among the various tricks for obtaining a reference to the global\n\t  // object, this seems to be the most reliable technique that does not\n\t  // use indirect eval (which violates Content Security Policy).\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this\n\t);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4)))\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// sw.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8232389d415a7f89aaab","import DataProvider from './dataProvider';\r\nimport ApiConfig from './config';\r\nimport OptimalRoutesCollection from './../public-transport-find-optimal-ways/optimalRoutesCollection';\r\n//import AppClient from './client';\r\n//let s = '123hello123';\r\nconsole.log('Hello from SW...');\r\n\r\n\r\nconst APP_CACHE_NAME = 'mosm-app-v1';\r\nconst TILE_CACHE_NAME = 'mosm-tiles-v1';\r\n\r\nconst urlsToCache = [\r\n  '/',\r\n  '/favicon.ico',\r\n  '/static/js/bundle.js',\r\n  '/static/css/style.css',\r\n  //ApiConfig.apiGetStationsUrl,\r\n  //ApiConfig.apiGetRoutesUrl,\r\n  //ApiConfig.apiGetTimetablesUrl\r\n];\r\n\r\nself.addEventListener('install', function(event) {\r\n  // Perform install steps\r\n  const cachePromise = caches.open(APP_CACHE_NAME)\r\n    .then(function(cache) {\r\n      console.log('install: opened cache');\r\n      return cache.addAll(urlsToCache);\r\n    })\r\n    .then(() => {\r\n      console.log('install: added all urls to cache');\r\n    });\r\n\r\n  event.waitUntil(cachePromise);\r\n  //event.waitUntil(self.skipWaiting()); // Activate worker immediately\r\n});\r\n\r\nself.addEventListener('activate', function(event) {\r\n  DataProvider.loadDataAndInitialize();\r\n\r\n  //event.waitUntil(self.clients.claim()); // Become available to all pages\r\n  //console.log('!!!!!!!!!activate');\r\n\r\n  /**/\r\n\r\n  \r\n\r\n});\r\n/*\r\nvar test = 0;\r\nsetInterval(function() {\r\n  test++\r\n}, 1000)\r\n*/\r\n//var ok = true;\r\n\r\nvar clients = [];\r\n\r\nself.addEventListener('message', function(event) {\r\n  var sender = event.source;\r\n  //console.log(event.data);\r\n  if(event.data === 'no-kill-sw') {\r\n    //console.log('SW: client call no-kill-sw.')\r\n    if(clients.includes(sender.id)){\r\n      return;\r\n    }\r\n    else {\r\n      clients.push(sender.id);\r\n      sender.postMessage('no-kill-sw-accepted');\r\n      setInterval(function(){\r\n        sender.postMessage(\"no-kill-sw-accepted\");\r\n      }, ApiConfig.clientVsSwNoKillingMessageInterval);\r\n    }\r\n  }\r\n  else if(event.data.requestType === 'optimalWay'){\r\n    console.log('SW: request for optimalWay.');\r\n\r\n    DataProvider.loadDataAndInitialize();\r\n\r\n    var params = event.data.params;\r\n    var rejected, resolved;\r\n    try {\r\n      var res = new OptimalRoutesCollection(\r\n        DataProvider.getAllStations(), \r\n        params.startOptimalRoutePoint, \r\n        params.finalOptimalRoutePoint, \r\n        params.startTime,\r\n        params.transportTypes,\r\n        params.goingSpeed,\r\n        params.dopTimeMinutes\r\n      );\r\n      //console.log('res = ' + res);\r\n      resolved = res.getOptimalWays();\r\n      //console.log('resolved = ' + resolved);\r\n    } catch(e) {\r\n      console.log(e);\r\n      rejected = e;\r\n    } finally {\r\n      sender.postMessage({\r\n        requestType: 'optimalWayResult',\r\n        result: resolved\r\n      });\r\n    }\r\n  }\r\n  /*if(ok) {\r\n    //ok = false;\r\n    setInterval(function() {\r\n      sender.postMessage({\r\n        message: test\r\n      });\r\n    }, 1000)\r\n    //if (event.waitUntil) {\r\n    //  event.waitUntil(promise);\r\n    //}\r\n  }*/\r\n});\r\n\r\n\r\n\r\nself.addEventListener('fetch', function(event) {\r\n  const { url } = event.request;\r\n  event.respondWith(\r\n    caches.match(event.request)\r\n      .then(function(response) {\r\n        // Cache hit - return response\r\n        if (response) {\r\n          return response;\r\n        }\r\n        caches.open(TILE_CACHE_NAME).then(cache => cache.add(url));\r\n\r\n        return fetch(event.request);\r\n      }\r\n    )\r\n  );\r\n});\r\n\r\n\r\n\r\n/*self.addEventListener('fetch', function(event) {\r\n  event.respondWith(\r\n    fetch(event.request).catch(function() {\r\n      return caches.match(event.request);\r\n    })\r\n  );\r\n});*/\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-client/sw.js","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-preset-react-app/~/babel-runtime/regenerator/index.js\n// module id = 1\n// module chunks = 0","class GeoCoords {\r\n    static distance(a, b) {\r\n        const earthRadius = 6372795;\r\n        const pi180 = 0.017453;// 29251//Math.Round(Math.PI / 180, 5);\r\n        //const pi2 = 1.5707963;\r\n        var zz = 1, yy = 1;\r\n        function taylorSin(x) {\r\n            yy = x * x;\r\n            zz = x;\r\n            return zz - (zz *= yy) / 6 + (zz *= yy) / 120;\r\n        }\r\n        function taylorCos(x) {\r\n            yy = x * x;\r\n            zz = yy;\r\n            return 1 - (yy) / 2 + (zz *= yy) / 24;\r\n        }\r\n        /*function taylorArcCos(x) {\r\n            yy = x * x;\r\n            zz = x;\r\n            return pi2 - zz - (zz *= yy)/6 - 3*(zz *= yy)/40;\r\n        }*/\r\n        /*function taylorAtan(x) {\r\n            yy = x * x;\r\n            zz = x;\r\n            return zz - (zz *= yy) / 3 + (zz *= yy) / 5 - (zz *= yy) / 7 + (zz *= yy) / 9 - (zz *= yy) / 20;\r\n        }*/\r\n\r\n        // перевести координаты в радианы\r\n        var lat1 = a.lat * pi180;\r\n        var lat2 = b.lat * pi180;\r\n        var long1 = a.lng * pi180;\r\n        var long2 = b.lng * pi180;\r\n\r\n        /*\r\n        // косинусы и синусы широт и разницы долгот\r\n        var cl1 = taylorCos(lat1);\r\n        var cl2 = taylorCos(lat2);\r\n        var sl1 = taylorSin(lat1);\r\n        var sl2 = taylorSin(lat2);\r\n        var delta = long2 - long1;\r\n        var cdelta = taylorCos(delta);\r\n        var sdelta = taylorSin(delta);\r\n\r\n        // вычисления длины большого круга\r\n        var tmp = cl2 * cdelta;\r\n        var y = Math.sqrt(cl2 * cl2 * sdelta * sdelta + (cl1 * sl2 - sl1 * tmp) * (cl1 * sl2 - sl1 * tmp));\r\n        var x = sl1 * sl2 + cl1 * tmp;\r\n\r\n        //\r\n        var ad = Math.atan2(y, x);//taylorAtan(y/x);\r\n        var dist = Math.ceil(ad * earthRadius);//(int)Math.Round(ad * earthRadius, 0);\r\n\r\n        //console.log(dist + \" vs \" + Math.acos(Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2))*earthRadius);\r\n        //console.log((taylorSin(lat1)*taylorSin(lat2)+taylorCos(lat1)*taylorCos(lat2)*taylorCos(long1-long2)) + \" vs \" + (Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2)));\r\n\r\n        return dist;\r\n        */\r\n\r\n\r\n        //arccos(sin(53.7*pi/180)*sin(53.71*pi/180)+cos(53.7*pi/180)*cos(53.71*pi/180)*cos((23.83-23.82)*pi/180))*6372795\r\n        //return Math.acos(taylorSin(lat1)*taylorSin(lat2)+taylorCos(lat1)*taylorCos(lat2)*taylorCos(long1-long2))*earthRadius;\r\n        return Math.acos(Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2))*earthRadius;\r\n    }\r\n}\r\n\r\nexport default GeoCoords;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/geo-coords-functions/geoCoords.js","export default {\r\n    apiPublicTransportServer: \"https://ptp-97126.app.xervo.io/\",\r\n    apiGetStationsUrl: \"https://publictransportproject.000webhostapp.com/new/json/stations.json\", //\"stations\"\r\n    apiGetRoutesUrl: \"https://publictransportproject.000webhostapp.com/new/json/routes.json\", //\"routes\"\r\n    apiGetTimetablesUrl: \"https://publictransportproject.000webhostapp.com/new/json/timetables.json\", //\"timetables\"\r\n\r\n    clientVsSwNoKillingMessageInterval: 30000\r\n};\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-client/config.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 4\n// module chunks = 0","import JsonDataStorage from './jsonDataStorage';\r\nimport initialize from './../public-transport-initialize-data/initialize';\r\nimport ApiConfig from './config';\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Load data.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar allStations = null;\r\nvar allRoutes = null;\r\nvar allTimetables = null;\r\n\r\n//var updatingFromServerInterval = 5000;\r\n\r\nvar loadingStarted = false;\r\n\r\nvar allStationsLoaded = false, allRoutesLoaded = false,  allTimetablesLoaded = false;\r\nvar allStationsJSON = null, allRoutesJSON = null, allTimetablesJSON = null;\r\n\r\nasync function loadDataOnly() {\r\n    allStationsJSON = await JsonDataStorage.getAllStations();\r\n    allRoutesJSON = await JsonDataStorage.getAllRoutes();\r\n    allTimetablesJSON = await JsonDataStorage.getAllTimetables();\r\n\r\n    if(!allStationsLoaded){\r\n        if (allStationsJSON == null) { //localStorage[\"allStationsJSON\"] === undefined || localStorage[\"allStationsJSON\"] == null\r\n            console.log(\"Downloading stations from server...\");\r\n\r\n            let response = await fetch(ApiConfig.apiGetStationsUrl);\r\n            allStationsJSON = await response.text();\r\n            allStations = JSON.parse(allStationsJSON);//await response.json();\r\n\r\n            if (allStations !== undefined && allStations != null) JsonDataStorage.pushAllStations(allStationsJSON); //localStorage[\"allStationsJSON\"] = allStationsJSON;\r\n            allStationsLoaded = true;\r\n            console.log(\"Stations loaded from server.\");\r\n        }\r\n        else {\r\n            allStations = JSON.parse(allStationsJSON); //localStorage[\"allStationsJSON\"]\r\n            allStationsLoaded = true;\r\n            console.log(\"Stations loaded from localStorage.\");\r\n        }\r\n    }\r\n\r\n    if(!allRoutesLoaded){\r\n        if (allRoutesJSON == null) { //localStorage[\"allRoutesJSON\"] === undefined || localStorage[\"allRoutesJSON\"] == null\r\n            console.log(\"Downloading routes from server...\");\r\n\r\n            let response = await fetch(ApiConfig.apiGetRoutesUrl);\r\n            allRoutesJSON = await response.text();\r\n            allRoutes = JSON.parse(allRoutesJSON);//await response.json();\r\n\r\n            if (allRoutes !== undefined && allRoutes != null) JsonDataStorage.pushAllRoutes(allRoutesJSON); //localStorage[\"allRoutesJSON\"] = allRoutesJSON;\r\n            allRoutesLoaded = true;\r\n            console.log(\"Routes loaded from server.\");\r\n        }\r\n        else {\r\n            allRoutes = JSON.parse(allRoutesJSON); //localStorage[\"allRoutesJSON\"]\r\n            allRoutesLoaded = true;\r\n            console.log(\"Routes loaded from localStorage.\");\r\n        }\r\n    }\r\n\r\n    if(!allTimetablesLoaded){\r\n        if (allTimetablesJSON == null) { //localStorage[\"allTimetablesJSON\"] === undefined || localStorage[\"allTimetablesJSON\"] == null\r\n            console.log(\"Downloading timetables from server...\");\r\n\r\n            let response = await fetch(ApiConfig.apiGetTimetablesUrl);\r\n            allTimetablesJSON = await response.text();\r\n            allTimetables = JSON.parse(allTimetablesJSON);//await response.json();\r\n\r\n            if (allTimetables !== undefined && allTimetables != null) JsonDataStorage.pushAllTimetables(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"] = allTimetablesJSON;\r\n            allTimetablesLoaded = true;\r\n            console.log(\"Timetables loaded from server.\");\r\n        }\r\n        else {\r\n            allTimetables = JSON.parse(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"]\r\n            allTimetablesLoaded = true;\r\n            console.log(\"Timetables loaded from localStorage.\");\r\n        }\r\n    }\r\n}\r\n\r\nasync function loadData() {\r\n    if(!loadingStarted){\r\n        loadingStarted = true;\r\n\r\n        await loadDataOnly();\r\n\r\n        if (allStationsLoaded && allRoutesLoaded && allTimetablesLoaded) {\r\n            initialize(allStations, allRoutes, allTimetables);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//loadData();\r\n\r\nclass DataProvider {\r\n    static getAllStations() {\r\n        return allStations;\r\n    }\r\n    static getAllRoutes() {\r\n        return allRoutes;\r\n    }\r\n    static getAllTimetables() {\r\n        return allTimetables;\r\n    }\r\n    static getAllStationsJSON() {\r\n        return allStationsJSON;\r\n    }\r\n    static getAllRoutesJSON() {\r\n        return allRoutesJSON;\r\n    }\r\n    static getAllTimetablesJSON() {\r\n        return allTimetablesJSON;\r\n    }\r\n    static async loadDataAndInitialize() {\r\n        await loadData();\r\n    }\r\n    static async loadDataOnly() {\r\n        await loadDataOnly();\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// End load data.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport default DataProvider;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-client/dataProvider.js","//import ApiConfig from './config';\r\n\r\nconst dbName = \"public_transport2\";\r\nconst storeName = \"json_data\";\r\n\r\nasync function getJsonDataStorageConnection() {\r\n    let promise = new Promise(function (resolve, reject) {\r\n        \r\n        let request = indexedDB.open(dbName, 1);\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n        request.onsuccess = function(event) {\r\n            resolve(event.target.result);\r\n        }\r\n        request.onupgradeneeded = async function(event) {\r\n            let db = event.target.result;\r\n            let objectStore = db.createObjectStore(storeName, { keyPath: \"name\"});\r\n            objectStore.createIndex(\"json\", \"json\", { unique: false });\r\n            \r\n            let result = await getJsonDataStorageConnection();\r\n            resolve(result);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\nasync function tryPush(obj) {\r\n    let promise = new Promise(async function (resolve, reject) {\r\n        let db = await getJsonDataStorageConnection();\r\n        //console.log(db);\r\n        let transaction = db.transaction([storeName], \"readwrite\");\r\n        let objectStore = transaction.objectStore(storeName);\r\n        let request = objectStore.add({\r\n            name: obj.name,\r\n            json: obj.json\r\n        });\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n        request.onsuccess = function(event) {\r\n            resolve(event.target.result);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\nasync function getItem(name) {\r\n    let promise = new Promise(async function (resolve, reject) {\r\n        let db = await getJsonDataStorageConnection();\r\n        let transaction = db.transaction([storeName]);\r\n        let objectStore = transaction.objectStore(storeName);\r\n\r\n        var request = objectStore.get(name);\r\n        request.onsuccess = function(event) { \r\n            if(event.target.result !== undefined) {                  \r\n                resolve(event.target.result.json);\r\n            }\r\n            else {\r\n                //resolve(null);\r\n                reject(event.target.error);\r\n            }\r\n        };\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\n\r\nclass JsonDataStorage {\r\n    static async getAllStations() {\r\n        try {\r\n            return await getItem('allStations');\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async getAllRoutes() {\r\n        try {\r\n            return await getItem('allRoutes');\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async getAllTimetables() {\r\n        try {\r\n            return await getItem('allTimetables');\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async pushAllStations(allStationsJson) {\r\n        try {\r\n            return await tryPush({\r\n                name: 'allStations',\r\n                json: allStationsJson\r\n            });\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async pushAllRoutes(allRoutesJson) {\r\n        try {\r\n            return await tryPush({\r\n                name: 'allRoutes',\r\n                json: allRoutesJson\r\n            });\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async pushAllTimetables(allTimetablesJson) {\r\n        try {\r\n            return await tryPush({\r\n                name: 'allTimetables',\r\n                json: allTimetablesJson\r\n            });\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nexport default JsonDataStorage;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-client/jsonDataStorage.js"," //import Points from './points';\r\n//import IgnoringFragments from './ignoringFragments';\r\n\r\nclass OptimalRoute {\r\n    constructor(myPoints, stationsList, /*nowPos, needPos,*/ time, types, goingSpeed, dopTimeMinutes, ignoringRoutesAdd, ignoringList) {\r\n        if (ignoringRoutesAdd != null) this.ignoringRoutes = ignoringRoutesAdd;\r\n        else this.ignoringRoutes = [];\r\n\r\n        this.points = [];\r\n\r\n        //this.needPos = needPos;\r\n        //this.nowPos = nowPos;\r\n        this.goingSpeed = goingSpeed;\r\n        this.time = time;\r\n        var reservedTimeSeconds = 60 * dopTimeMinutes;\r\n\r\n        this.types = types;\r\n\r\n        this.myIgnoringFragments = null;\r\n        //if (ignoringList != null) this.myIgnoringFragments = new IgnoringFragments(ignoringList);\r\n        //else this.myIgnoringFragments = new IgnoringFragments();\r\n\r\n        //var myPoints = new Points(nowPos, needPos);\r\n        \r\n        myPoints.fillStartData(stationsList, goingSpeed, reservedTimeSeconds, this.myIgnoringFragments);\r\n\r\n        // Находим кратчайшие пути до всех вершин:\r\n        myPoints.countShortWay(this.ignoringRoutes, this.myIgnoringFragments, time, types, goingSpeed, reservedTimeSeconds);\r\n\r\n        var tmpP = myPoints.finalPoint;\r\n        this.points.push(tmpP.toString());////\r\n        while (tmpP.previousPoint != null) {\r\n            tmpP = tmpP.previousPoint;//\r\n            this.points.push(tmpP.toString());\r\n            if (tmpP.previousPoint == null && tmpP.coords !== myPoints.startPoint.coords)\r\n                throw new Error(\"Где-то удалилась часть маршрута...\");\r\n        }\r\n\r\n        this.totalTimeSeconds = myPoints.finalPoint.totalTimeSeconds;\r\n        this.totalGoingTime = myPoints.finalPoint.getTotalGoingTime();\r\n        this.totalTransportChangingCount = myPoints.finalPoint.getTotalTransportChangingCount();\r\n\r\n        this.myPoints = myPoints;\r\n\r\n\r\n        this.isVisited = false;\r\n    }\r\n\r\n    setVisited() {\r\n        this.isVisited = true;\r\n    }\r\n\r\n}\r\n\r\nexport default OptimalRoute;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/optimalRoute.js","//import IgnoringFragments from './ignoringFragments';\r\nimport OptimalRoute from './optimalRoute';\r\nimport OptimalWay from './optimalWay';\r\nimport Points from './points';\r\n\r\nimport GeoCoords from './../geo-coords-functions/geoCoords';\r\nvar distance = GeoCoords.distance;\r\nfunction getStationsAround(allStations, coords, radius) {\r\n    var result = [];\r\n    for (var i = 0, n = allStations.length, s = allStations[0]; i < n; s = allStations[++i]) {\r\n        if (s != null && distance(s.coords, coords) < radius) result.push(s);\r\n    }\r\n    return result;\r\n}\r\n\r\nclass OptimalRoutesCollection extends Array {\r\n    /*getOptimalWays() {\r\n        var result = [];\r\n        for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n            result.push(new OptimalWay(r));\r\n        }\r\n        return result;\r\n    }*/\r\n    /*selectOptimalRouteWithMinimalMark() {\r\n        var p = null;\r\n        for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n            if (!(t.isVisited)) {\r\n                p = t;\r\n                for (t = this[++i]; i < n; t = this[++i]) {\r\n                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                        p = t;\r\n                    }\r\n                }\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }*/\r\n    constructor(allStations, nowPos, needPos, time, types, speed, dopTimeMinutes) {\r\n        super();\r\n        this.getOptimalWays = function() {\r\n            var result = [];\r\n            for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n                result.push(new OptimalWay(r));\r\n            }\r\n            return result;\r\n        }\r\n        this.selectOptimalRouteWithMinimalMark = function() {\r\n            var p = null;\r\n            for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n                if (!(t.isVisited)) {\r\n                    p = t;\r\n                    for (t = this[++i]; i < n; t = this[++i]) {\r\n                        if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                            p = t;\r\n                        }\r\n                    }\r\n                    return p;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        var myPoints = new Points(nowPos, needPos);\r\n        // Получим \"начальный\" список станций:\r\n        var stationsList = getStationsAround(allStations, nowPos, distance(nowPos, needPos));\r\n\r\n        this.push(new OptimalRoute(myPoints, stationsList, /*nowPos, needPos,*/ time, types, speed, dopTimeMinutes));\r\n\r\n        var ignoringRoutes = [];\r\n\r\n        //var ignoringFragments = new IgnoringFragments();\r\n        \r\n        for (var selectedOptimalRoute = this[0]; selectedOptimalRoute != null; selectedOptimalRoute.setVisited(), selectedOptimalRoute = this.selectOptimalRouteWithMinimalMark()) {\r\n            var ddd = 0.25;\r\n\r\n            ignoringRoutes = [];\r\n            // Проходим по всем ребрам выбранного пути и строим новые маршруты при удалении ребер:\r\n            for (var tmpP = selectedOptimalRoute.myPoints.finalPoint; tmpP.previousPoint != null; tmpP = tmpP.previousPoint) {\r\n                //if(tmpP == null) console.log(\"err in optimalRoutesCollection.js\");\r\n                if (tmpP.fromWhichRoute != null && !ignoringRoutes.includes(tmpP.fromWhichRoute)) ignoringRoutes.push(tmpP.fromWhichRoute);\r\n            }\r\n            for (var i = 0, n = ignoringRoutes.length, r = ignoringRoutes[0]; i < n; r = ignoringRoutes[++i]) {\r\n                if (selectedOptimalRoute.ignoringRoutes.includes(r)) continue;\r\n                var ignoringRoutesAdd = [];\r\n                ignoringRoutesAdd = ignoringRoutesAdd.concat(selectedOptimalRoute.ignoringRoutes);\r\n                ignoringRoutesAdd.push(r);\r\n                myPoints = new Points(nowPos, needPos);\r\n                var tmpOptimalRoute = new OptimalRoute(myPoints, stationsList, /*nowPos, needPos,*/ time, types, speed, dopTimeMinutes, ignoringRoutesAdd);\r\n\r\n                if (tmpOptimalRoute.totalTimeSeconds <= this[0].totalTimeSeconds / ddd) {\r\n                    var tmpJSON = JSON.stringify(tmpOptimalRoute.points);\r\n                    var ok = false;\r\n                    for (var j = 0, m = this.length, opt = this[0]; j < m; opt = this[++j]) {\r\n                        if (JSON.stringify(opt.points) === tmpJSON) {\r\n                            ok = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (ok) continue;\r\n                    this.push(tmpOptimalRoute);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default OptimalRoutesCollection;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/optimalRoutesCollection.js","import WayPoint from './wayPoint';\r\n\r\nclass OptimalWay {\r\n    constructor(optimalRoute) {\r\n        this.totalTimeSeconds = optimalRoute.totalTimeSeconds;\r\n        this.totalGoingTimeSeconds = optimalRoute.totalGoingTime;\r\n        this.totalTransportChangingCount = optimalRoute.totalTransportChangingCount;\r\n        this.points = [];\r\n\r\n        for (var tmpP = optimalRoute.myPoints.finalPoint; tmpP != null; tmpP = tmpP.previousPoint) {\r\n            this.points.push(new WayPoint(tmpP.totalTimeSeconds, tmpP.station, tmpP.fromWhichRoute, tmpP.coords));\r\n        }\r\n        this.points.reverse();\r\n    }\r\n\r\n}\r\n\r\nexport default OptimalWay;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/optimalWay.js","class Point {\r\n    constructor(totalTimeSeconds, station_or_crds, fromWhichStation, fromWhichRoute) {\r\n        if (station_or_crds.hashcode !== undefined) {\r\n            this.station = station_or_crds;\r\n            this.stationCode = station_or_crds.hashcode;\r\n            station_or_crds.point = this;\r\n            this.coords = station_or_crds.coords;\r\n        }\r\n        else {\r\n            this.coords = station_or_crds;\r\n            this.station = null;\r\n            this.stationCode = null;\r\n        }\r\n        this.totalTimeSeconds = totalTimeSeconds;\r\n        this.fromWhichStation = fromWhichStation;\r\n        this.fromWhichRoute = fromWhichRoute;\r\n\r\n        this.isVisited = false;\r\n\r\n        this.previousPoint = null;\r\n    }\r\n    tryUpdate(totalTimeSeconds, previousPoint, fromWhichStation, fromWhichRoute) {\r\n        if (totalTimeSeconds < this.totalTimeSeconds) {\r\n            this.fromWhichRoute = fromWhichRoute;\r\n            this.previousPoint = previousPoint;\r\n            this.totalTimeSeconds = totalTimeSeconds;\r\n            this.fromWhichStation = fromWhichStation;\r\n\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    setVisited() {\r\n        this.isVisited = true;\r\n    }\r\n    toString() {\r\n        var to, tr; //, from, p;\r\n        //if (this.fromWhichStation != null) from = this.fromWhichStation.name;\r\n        //else from = \"null\";\r\n        if (this.station != null) to = this.station.name;\r\n        else to = \"null\";\r\n        if (this.fromWhichRoute != null) tr = this.fromWhichRoute.type + \" \" + this.fromWhichRoute.number + \" \" + this.fromWhichRoute.from + \" - \" + this.fromWhichRoute.to;\r\n        else tr = \"пешком\";\r\n        //if (this.previousPoint != null) p = this.previousPoint.toString();\r\n        //else p = \"null\";\r\n        return /*p+\" -->> */\"(\" + this.totalTimeSeconds + \") \" + to + \" (\" + tr + \")\"; // from \" + from + \" to\r\n    }\r\n    getTotalGoingTime() {\r\n        var goingTime = 0;\r\n        var tmpP = this;\r\n        //this.points.Add(tmpP.ToString());\r\n        while (tmpP.previousPoint != null) {\r\n            if (tmpP.fromWhichRoute == null /*&& tmpP.fromWhichRoute.hashcode == null*/) goingTime += tmpP.totalTimeSeconds - tmpP.previousPoint.totalTimeSeconds;\r\n            tmpP = tmpP.previousPoint;\r\n        }\r\n        return goingTime;\r\n    }\r\n    getTotalTransportChangingCount() {\r\n        var result = 0;\r\n        var tmpP = this;\r\n        //this.points.Add(tmpP.ToString());\r\n        while (tmpP.previousPoint != null) {\r\n            if (tmpP.fromWhichRoute != null && tmpP.fromWhichRoute.hashcode != null && tmpP.fromWhichRoute !== tmpP.previousPoint.fromWhichRoute) result++;\r\n            tmpP = tmpP.previousPoint;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport default Point;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/point.js","import Point from './point';\r\nimport GeoCoords from './../geo-coords-functions/geoCoords';\r\nvar distance = GeoCoords.distance;\r\n\r\n\r\nfunction getTimeForGoingTo(distance, goingSpeed) {\r\n    return Math.floor(distance / (goingSpeed / 3.6));\r\n}\r\n\r\nconst TableType = { table: 1, periodic: 2 };\r\n\r\nclass Points {\r\n    constructor(nowPos, needPos) {\r\n        this.collection = [];\r\n        this.startPoint = new Point(0, nowPos, null, null);\r\n        this.finalPoint = new Point(2160000000, needPos, null, null);\r\n        this.currentSelectedPoint = null;\r\n    }\r\n    findElement(station_or_point) {\r\n        if (station_or_point.hashcode != null) {\r\n            if (station_or_point.point != null) return station_or_point.point;\r\n            var newCreatdPoint = new Point(2160000000, station_or_point, null, null);\r\n            newCreatdPoint.heuristicTimeToFinalPoint = distance(newCreatdPoint.coords, this.finalPoint.coords) / 5;\r\n            this.collection.push(newCreatdPoint);\r\n            return newCreatdPoint;\r\n        }\r\n        else {\r\n            for (var i = 0, n = this.collection.length, p = this.collection[0]; i < n; p = this.collection[++i]) {\r\n                if (p.coords === station_or_point.coords && p.stationCode === station_or_point.stationCode) return p;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    fillStartData(stationsList, goingSpeed, reservedTime, myIgnoringFragments) {\r\n        this.finalPoint.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, this.finalPoint.coords), goingSpeed) + 1800/*+ TimeSpan.FromMinutes(20)*/, this.startPoint, null, null);\r\n        const finalPointCoords = this.finalPoint.coords;\r\n        for (var i = 0, n = stationsList.length, st = stationsList[0]; i < n; st = stationsList[++i]) {\r\n            if (myIgnoringFragments != null && myIgnoringFragments.contains(st.hashcode, null, null)) continue;\r\n\r\n            var add = new Point(2160000000, st, null, null);\r\n            add.heuristicTimeToFinalPoint = distance(add.coords, finalPointCoords) / 5;\r\n            add.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, st.coords), goingSpeed) + reservedTime, this.startPoint, null, null);\r\n            this.collection.push(add);\r\n        }\r\n    }\r\n    getNextUnvisitedPoint() {\r\n        if (this.currentSelectedPoint != null) this.currentSelectedPoint.setVisited();\r\n\r\n        this.currentSelectedPoint = this.selectPointWithMinimalMark();\r\n\r\n        return this.currentSelectedPoint;\r\n    }\r\n    selectPointWithMinimalMark() {\r\n        var p = null;\r\n        for (var i = 0, n = this.collection.length, t = this.collection[0]; i < n; t = this.collection[++i]) {\r\n            if (!(t.isVisited)) {\r\n                p = t;\r\n                //var euristicTimeSecondsToFinalPoint = distance(p.coords, this.finalPoint.coords) / 5; // Оценка оставшегося времени пути в секундах.\r\n                for (t = this.collection[++i]; i < n; t = this.collection[++i]) {\r\n                    //var tmpEuristic = distance(t.coords, this.finalPoint.coords) / 5;\r\n                    if (!(t.isVisited) && t.totalTimeSeconds + t.heuristicTimeToFinalPoint < p.totalTimeSeconds + p.heuristicTimeToFinalPoint ) {\r\n                        p = t;\r\n                        //euristicTimeSecondsToFinalPoint = tmpEuristic;\r\n                    }\r\n                }\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    countShortWay(ignoringRoutes, myIgnoringFragments, time, types, speed, reservedTime) {\r\n        //TimeSpan overLimitResedvedTime = TimeSpan.FromMinutes(20);\r\n\r\n        for (var selectedPoint = this.getNextUnvisitedPoint(), selectedPointStation, selectedPointTotalTimeSeconds, selectedPointStationHashcode, selectedPointFromWhichRoute, momentWhenComingToStation, routesOnStation, selectedPointCoords; selectedPoint != null; selectedPoint = this.getNextUnvisitedPoint()) {\r\n            //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n            selectedPointTotalTimeSeconds = selectedPoint.totalTimeSeconds;\r\n            if (selectedPointTotalTimeSeconds > this.finalPoint.totalTimeSeconds/* + overLimitResedvedTime*/) //... Пропускаем и удаляем, если значение метки превышает минимальное время до пункта назначения.\r\n            {\r\n                break;\r\n            }\r\n            selectedPointStation = selectedPoint.station;\r\n            selectedPointStationHashcode = selectedPointStation.hashcode;\r\n            selectedPointFromWhichRoute = selectedPoint.fromWhichRoute;\r\n            if (selectedPointStation != null) {\r\n                // Момент, когда мы прибудем на остановку:\r\n                momentWhenComingToStation = time + selectedPointTotalTimeSeconds;\r\n                // Загружаем маршруты, проходящие через остановку:\r\n                routesOnStation = null;// = routesOnStation = Database.GetRoutesOnStation(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);\r\n                if (selectedPointStation.routes != null) routesOnStation = selectedPointStation.routes;\r\n                else continue;\r\n\r\n                for (var i = 0, n = routesOnStation.length, selectedRoute = routesOnStation[0], nextStation; i < n; selectedRoute = routesOnStation[++i]) {\r\n                    if (ignoringRoutes != null && ignoringRoutes.includes(selectedRoute)) continue;\r\n                    if (types.includes(selectedRoute.type)) {\r\n                        // Следующая остановка у данного тран спорта:\r\n                        nextStation = selectedRoute.getNextStation(selectedPointStation);\r\n\r\n                        /*// Код остановки, на которую попадем на данном транспорте:\r\n                        string nextCode = selectedRoute.getNextStationCodeAfter(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);*/\r\n                        if (nextStation/*nextCode*/ != null) // Если остановка не является конечной, то:\r\n                        {\r\n                            // Загружаем расписание:\r\n                            var table = selectedRoute.getTimetable(selectedPointStation);//Database.getTimetable(selectedPointStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\r\n                            // Блокируем попытку попасть указанным транспортом на указанную остановку:\r\n                            if (myIgnoringFragments!= null && myIgnoringFragments.contains(nextStation.hashcode/*nextCode*/, selectedRoute.hashcode, selectedPointStationHashcode)) continue;\r\n\r\n                            if (table.type === TableType.table) // Если это точное расписание, то:\r\n                            {\r\n                                // Минимальный начальный момент, с который можно начинать ожидать посадку:\r\n                                var momentWhenAskingForGoing = momentWhenComingToStation;\r\n\r\n                                // Резервируем дополнительное время, если будем пересаживаться на другой маршрут:\r\n                                //if (selectedPoint.RouteCode == null || selectedPoint.RouteCode != selectedRoute.hashcode) momentWhenAskingForGoing += reservedTime;\r\n                                if (selectedPointFromWhichRoute != null && selectedPointFromWhichRoute !== selectedRoute) momentWhenAskingForGoing += reservedTime;\r\n\r\n                                // Подсчитываем, сколько будем ожидать этот транспорт на остановке:\r\n                                var waitingTime = table.findTimeAfter(momentWhenAskingForGoing);\r\n\r\n                                // Момент, когда мы сядем в транспорт:\r\n                                var momentWhenSitInTransport = momentWhenAskingForGoing + waitingTime;\r\n\r\n                                /*// Следующая остановка у данного транспорта:\r\n                                Station nextStation = Database.GetStationByHashcode(nextCode, databaseMysqlConnection, canReadDataFromLocalCopy: true);*/\r\n\r\n                                // И соответствующее расписание на этой остановке:\r\n                                var tbl = selectedRoute.getTimetable(nextStation);//Database.getTimetable(nextStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\r\n                                \r\n                                // (сколько будем ехать до следующей остановки):\r\n                                var goingOnTransportTime = tbl.findTimeAfter(momentWhenSitInTransport);\r\n                                \r\n                                // Метка времени:\r\n                                var onNextPointtotalTimeSeconds = momentWhenSitInTransport - momentWhenComingToStation + goingOnTransportTime + selectedPointTotalTimeSeconds;\r\n                                \r\n                                if (this.findElement(nextStation).tryUpdate(onNextPointtotalTimeSeconds, selectedPoint, selectedPointStation, selectedRoute)) {\r\n                                    //console.log(\"upd...\");\r\n                                }\r\n                            }\r\n                            else if (table.type === TableType.periodic) {\r\n                                throw new Error();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            selectedPointCoords = selectedPoint.coords;\r\n            // Нет смысла идти пешком \"транзитом\" через остановку:\r\n            if (selectedPointFromWhichRoute == null) continue;\r\n\r\n            // Попробуем пройти пешком до других \"вершин\":\r\n            for (var j = 0, m = this.collection.length, p = this.collection[0], distanceToSelectedPoint, goingTime, newTime; j < m; p = this.collection[++j])\r\n                if (!p.isVisited && p !== selectedPoint) {\r\n                    // Блокируем попытку дойти пешком до указанной остановки:\r\n                    if (myIgnoringFragments != null && myIgnoringFragments.contains(p.stationCode, null, selectedPointStationHashcode)) continue;\r\n\r\n                    distanceToSelectedPoint = distance(selectedPointCoords, p.coords);\r\n                    \r\n                    goingTime = getTimeForGoingTo(distanceToSelectedPoint, speed/*, true, sp*/);\r\n\r\n                    newTime = selectedPointTotalTimeSeconds + goingTime + reservedTime;\r\n                    /*if (p != myFinishPoint)*/ // newTime += reservedTime;\r\n                    \r\n                    if (p.tryUpdate(newTime, selectedPoint, selectedPointStation, null)) {\r\n                        //console.log(\"upd...\");\r\n                    }\r\n                }\r\n\r\n            if (myIgnoringFragments != null && myIgnoringFragments.contains(null, null, selectedPointStationHashcode)) continue;\r\n            \r\n            var tryingNewTime = selectedPointTotalTimeSeconds + getTimeForGoingTo(distance(selectedPointCoords, this.finalPoint.coords), speed);\r\n            if (this.finalPoint.tryUpdate(tryingNewTime, selectedPoint, selectedPointStation, null)) {\r\n                //console.log(\"upd: \" + selectedPointStation.hashcode);\r\n            }\r\n        }\r\n\r\n        // Сокращаем время ходьбы пешком до минимума и избавляемся от \"бессмысленных\" пересадок, сохраняя общее время неизменным:\r\n        var currentPoint = this.finalPoint.previousPoint;\r\n        while (currentPoint !== this.startPoint) {\r\n            if(currentPoint == null){\r\n                console.log(\"err 1 in points.js\");\r\n                console.log(this.finalPoint);\r\n            }\r\n            var r = currentPoint.fromWhichRoute;\r\n            if (r != null) {\r\n                var previousPoint = currentPoint.previousPoint;\r\n                //if(previousPoint == null) console.log(\"err 2 in points.js\");\r\n                if (previousPoint !== this.startPoint && previousPoint.fromWhichRoute !== r) // Если на предыдущую остановку мы добрались другим транспортом, то:\r\n                {\r\n                    var previousRouteStation = r.getPreviousStation(previousPoint.station);\r\n                    if (previousRouteStation != null) {\r\n                        var point = previousRouteStation.point;\r\n                        if (point != null && point.isVisited) {\r\n                            var ttt = r.getTimetable(previousRouteStation);\r\n                            if (ttt != null) {\r\n                                //var ddd = time + previousPoint.totalTimeSeconds;\r\n                                //var moment = r.getTimetable(currentPoint.station).findTimeAfter(ddd);\r\n                                //var tmp_time = ttt.findTimeBefore(ddd + moment);\r\n\r\n                                //var momentArriveOnCurrent = previousPoint.totalTimeSeconds + moment;\r\n                                //var momentSittingOnPrevious = momentArriveOnCurrent + tmp_time;\r\n                                /*bool bbb = point.fromWhichRoute != null && point.fromWhichRoute.getTimetable(point.station) != null && point.fromWhichRoute.getTimetable(point.station).findTimeAfter(time + point.totalTimeSeconds) <= previousPoint.totalTimeSeconds + moment + tmp_time;\r\n                                if (bbb)\r\n                                {\r\n                                    previousPoint.fromWhichRoute = r;\r\n                                    previousPoint.previousPoint = point;////!bbb && point.totalTimeSeconds <= momentSittingOnPrevious &&\r\n                                }\r\n                                else */\r\n                                if (/*point.totalGoingTime>=previousPoint.totalGoingTime || */point.totalTimeSeconds <= previousPoint.totalTimeSeconds/* && point.totalGoingTime <= previousPoint.totalGoingTime*/) {\r\n                                    previousPoint.fromWhichRoute = r;\r\n                                    previousPoint.previousPoint = point;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            currentPoint = currentPoint.previousPoint;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Points;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/points.js","class WayPoint {\r\n    constructor(time, station, route, coords) {\r\n        this.time = time;\r\n        this.station = station == null ? null : { hashcode: station.hashcode, name: station.name, routes: null, Coords: { lat: station.coords.lat, lng: station.coords.lng } };\r\n        this.route = route == null ? null : { vehicles: [], gpsTrack: null, hashcode: route.hashcode, number: route.number, type: route.type, from: route.from, to: route.to, owner: \"\", stations: null, timetables: null, stationsJSON: null }\r\n        this.coords = coords;\r\n    }\r\n}\r\n\r\nexport default WayPoint;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/wayPoint.js","///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Initailize.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction getNextStation(currentStation) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let t = 0, nn = this.stations[j].length; t < nn; t++) {\r\n            if (this.stations[j][t] === currentStation) {\r\n                if (t + 1 !== nn) return this.stations[j][t + 1];\r\n                else return null;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getPreviousStation(currentStation) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let t = 0, nn = this.stations[j].length; t < nn; t++) {\r\n            if (this.stations[j][t] === currentStation) {\r\n                if (t !== nn) return this.stations[j][t - 1];\r\n                else return null;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getTimetable(station) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let i = 0, n = this.stations[j].length; i < n; i++) {\r\n            if (this.stations[j][i] === station) {\r\n                return this.timetables[j][i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction findTimeAfter(time) {\r\n    var dateTmp = new Date();\r\n    dateTmp.setMinutes(0);\r\n    dateTmp.setHours(0);\r\n    dateTmp.setSeconds(time);\r\n    var day = dateTmp.getDay();\r\n    //foreach (Table t in table)\r\n    for (let kkk = 0, mnkk = this.table.length, t = this.table[0]; kkk < mnkk; t = this.table[++kkk]) {\r\n        if (t.days.includes(day)) {\r\n\r\n            //foreach (SimpleTime st in t.times)\r\n            for (let iik = 0, mnii = t.times.length, st = t.times[0], stTime; iik < mnii; st = t.times[++iik]) {\r\n                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\r\n                //\r\n                stTime = st.hour * 3600 + st.minute * 60;\r\n                if (stTime >= time/*.Second + time.Minute * 60 + time.Hour * 3600*/ /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\r\n                    //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\r\n                    return stTime - time/*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/;\r\n                }\r\n            }\r\n            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time/*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/ + 86400;\r\n            break;\r\n        }\r\n    }\r\n    return 2160000000;\r\n    //throw new Exception();\r\n}\r\nfunction findTimeBefore(time) {\r\n    var dateTmp = new Date();\r\n    dateTmp.setMinutes(0);\r\n    dateTmp.setHours(0);\r\n    dateTmp.setSeconds(time);\r\n    var day = dateTmp.getDay();\r\n    for (let kkk = 0, mnkk = this.table.length, t = this.table[0], ok = false, st; kkk < mnkk; t = this.table[++kkk]) {\r\n        if (t.days.includes(day)) {\r\n            ok = false;\r\n            st = null;\r\n            for (let iik = 0, mnii = t.times.length, stt = t.times[0]; iik < mnii; stt = t.times[++iik]) {\r\n                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\r\n                //\r\n                if (stt.hour * 3600 + stt.minute * 60 <= time/*time.Hour >= st.hour && time.Minute >= st.minute*/) {\r\n                    ok = true;\r\n                    st = stt;\r\n                    //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\r\n                }\r\n                else break;\r\n            }\r\n            if (ok) return st.hour * 3600 + st.minute * 60 - time;\r\n            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time - 86400;\r\n            break;\r\n        }\r\n    }\r\n    return 0;//TimeSpan.FromDays(0/*-25000*/);\r\n    //throw new Exception();\r\n}\r\n\r\n\r\nfunction initialize(allStations, allRoutes, allTimetables) {\r\n    //alert(allStations.length);\r\n    //alert(allRoutes.length);\r\n    //alert(allTimetables.length);\r\n\r\n    console.log(\"Start initializing...\");\r\n    var startInitializingMoment = Date.now();\r\n\r\n    var tmpUsedStations = [];\r\n\r\n    function bindRoutesStationsTimetables(station, tmpArr, tabArr, rr) {\r\n        if (station.routes == null) station.routes = [];\r\n        //console.log(station.routes);//!!!\r\n        if (!(station.routes.includes(rr))) station.routes.push(rr);\r\n        tmpArr.push(station);\r\n\r\n        var tmp = allTimetables.find(function (element, index, array) {\r\n            return element.stationCode === station.hashcode && element.routeCode === rr.hashcode;\r\n        });\r\n        var tmpTab = (tmp == null) ? null : tmp;\r\n\r\n        tabArr.push(tmpTab);\r\n    }\r\n\r\n    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n        if (currentStation.routesCodes == null || currentStation.routesCodes.length === 0) {\r\n            allStations.splice(i, 1);\r\n            n = allStations.length;\r\n        }\r\n        else i++;\r\n    }\r\n\r\n    for (let i = 0, n = allRoutes.length, rr = allRoutes[0]; i < n; rr = allRoutes[++i]) {\r\n\r\n        rr.getNextStation = getNextStation; \r\n        rr.getPreviousStation = getPreviousStation;\r\n        rr.getTimetable = getTimetable;\r\n\r\n        if (rr.stationsCodes == null || rr.stationsCodes.length === 0) continue;\r\n\r\n        try {\r\n            //if (rr.stationsCodes[rr.stationsCodes.Length - 1] != ']') continue;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n\r\n            rr.stations = [[],[]];\r\n            rr.timetables = [[],[]];\r\n\r\n\r\n\r\n            for (let index = 0, tmpArr = [], tabArr = [] ; index <= 1; index++) {\r\n                var rr_stationsCodes = rr.stationsCodes;\r\n                if (rr_stationsCodes[index] == null || rr_stationsCodes[index].length === 0) continue;\r\n                for (let j = 0, m = rr_stationsCodes[index].length, stationCode = rr_stationsCodes[index][0]; j < m; stationCode = rr_stationsCodes[index][++j]) {\r\n                    var tmpUsed = false;\r\n                    for (let k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\r\n                        if (station != null && station.hashcode === stationCode) {\r\n                            bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\r\n                            tmpUsed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!tmpUsed) {\r\n                        for (let k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\r\n                            if (station != null && station.hashcode === stationCode) {\r\n                                bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\r\n                                if (!tmpUsedStations.includes(station)) tmpUsedStations.push(station);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                rr.stations[index] = tmpArr;\r\n                rr.timetables[index] = tabArr;\r\n\r\n            }\r\n        }\r\n        catch (ex) {\r\n            console.log(ex/*.message*/);\r\n            continue;\r\n        }\r\n    }\r\n\r\n    for (let i = 0, n = allTimetables.length, timetable = allTimetables[0]; i < n; timetable = allTimetables[++i]) {\r\n        timetable.findTimeAfter = findTimeAfter;\r\n        timetable.findTimeBefore = findTimeBefore;\r\n    }\r\n\r\n    //...\r\n    /*\r\n    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n        if (currentStation.routes == undefined || currentStation.routes == null || currentStation.routes.length == 0) {\r\n            allStations.splice(i, 1);\r\n            n = allStations.length;\r\n        }\r\n        else i++;\r\n    }\r\n    */\r\n\r\n    console.log(\"Initialized. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\r\n    //console.log(\"\\n\\n\" + JSON.stringify(allTimetables[0]) + \"\\n\\n\");\r\n    //alert(distance({ lat: allStations[0].xCoord, lng: allStations[0].yCoord }, { lat: allStations[5].xCoord, lng: allStations[5].yCoord }));\r\n\r\n\r\n    //for (let t = 0; t < 1000; t++) var ttt = GetStationsAround(allStations[0].coords, 30000).length;\r\n    //console.log(\"test. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\r\n\r\n\r\n    //global.initialized = true;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// End initailize.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport default initialize;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-initialize-data/initialize.js","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime-module.js\n// module id = 14\n// module chunks = 0","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime.js\n// module id = 15\n// module chunks = 0"],"sourceRoot":""}