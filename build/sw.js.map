{"version":3,"sources":["webpack:///sw.js","webpack:///webpack/bootstrap 974f0a1e5fc014b4e3a3","webpack:///./~/public-transport-client/lib/sw.js","webpack:///./~/geo-coords-distance/lib/distance.js","webpack:///./~/public-transport-client/lib/config.js","webpack:///./~/public-transport-client/lib/dataProvider.js","webpack:///./~/public-transport-client/lib/jsonDataStorage.js","webpack:///./~/public-transport-find-optimal-ways/lib/optimalRoute.js","webpack:///./~/public-transport-find-optimal-ways/lib/optimalRoutesCollection.js","webpack:///./~/public-transport-find-optimal-ways/lib/optimalWay.js","webpack:///./~/public-transport-find-optimal-ways/lib/point.js","webpack:///./~/public-transport-find-optimal-ways/lib/points.js","webpack:///./~/public-transport-find-optimal-ways/lib/wayPoint.js","webpack:///./~/public-transport-initialize-data/lib/initialize.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_dataProvider","_dataProvider2","_config","_config2","_optimalRoutesCollection","_optimalRoutesCollection2","console","log","APP_CACHE_NAME","TILE_CACHE_NAME","urlsToCache","self","addEventListener","event","cachePromise","caches","open","then","cache","addAll","waitUntil","loadDataAndInitialize","clients","sender","source","data","includes","push","postMessage","setInterval","clientVsSwNoKillingMessageInterval","requestType","rejected","resolved","params","res","getAllStations","startOptimalRoutePoint","finalOptimalRoutePoint","startTime","transportTypes","goingSpeed","dopTimeMinutes","getOptimalWays","e","result","url","request","respondWith","match","response","add","fetch","distance","a","b","earthRadius","pi180","lat1","lat","lat2","long1","lng","long2","Math","acos","sin","cos","Object","defineProperty","value","apiPublicTransportServer","apiGetStationsUrl","apiGetRoutesUrl","apiGetTimetablesUrl","_classCallCheck","instance","Constructor","TypeError","_asyncToGenerator","fn","gen","apply","this","arguments","Promise","resolve","reject","step","key","arg","info","error","done","err","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","protoProps","staticProps","prototype","_loadDataOnly","_ref","regeneratorRuntime","mark","_callee","_response","_response2","wrap","_context","prev","next","_jsonDataStorage2","allStationsJSON","sent","getAllRoutes","allRoutesJSON","getAllTimetables","allTimetablesJSON","allStationsLoaded","text","allStations","JSON","parse","undefined","pushAllStations","allRoutesLoaded","allRoutes","pushAllRoutes","allTimetablesLoaded","allTimetables","pushAllTimetables","stop","loadData","_ref2","_callee2","_context2","loadingStarted","_publicTransportInitializeData2","_jsonDataStorage","_publicTransportInitializeData","DataProvider","_ref3","_callee3","_context3","loadDataOnly","_ref4","_callee4","_context4","getJsonDataStorageConnection","promise","indexedDB","dbName","onerror","onsuccess","onupgradeneeded","db","objectStore","createObjectStore","storeName","keyPath","createIndex","unique","_x","abrupt","tryPush","transaction","name","json","_x3","_x4","_x2","getItem","_ref5","_callee6","_context6","_ref6","_callee5","_context5","get","_x6","_x7","_x5","JsonDataStorage","_ref7","_callee7","_context7","t0","_ref8","_callee8","_context8","_ref9","_callee9","_context9","_x8","_ref10","_callee10","allStationsJson","_context10","_x9","_ref11","_callee11","allRoutesJson","_context11","_x10","_ref12","_callee12","allTimetablesJson","_context12","OptimalRoute","myPoints","stationsList","time","types","ignoringRoutesAdd","ignoringList","ignoringRoutes","points","reservedTimeSeconds","myIgnoringFragments","fillStartData","countShortWay","tmpP","finalPoint","toString","previousPoint","coords","startPoint","Error","totalTimeSeconds","totalGoingTime","getTotalGoingTime","totalTransportChangingCount","getTotalTransportChangingCount","isVisited","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","getStationsAround","nowPos","needPos","heuristicBestTransportSpeed","fullDistance","_geoCoordsDistance2","n","s","_optimalRoute","_optimalRoute2","_optimalWay","_optimalWay2","_points","_points2","_geoCoordsDistance","OptimalRoutesCollection","_Array","speed","_this","getPrototypeOf","r","selectOptimalRouteWithMinimalMark","t","selectedOptimalRoute","setVisited","ddd","fromWhichRoute","concat","tmpOptimalRoute","tmpJSON","stringify","ok","j","opt","Array","_wayPoint","_wayPoint2","OptimalWay","optimalRoute","totalGoingTimeSeconds","station","reverse","Point","station_or_crds","fromWhichStation","hashcode","stationCode","point","to","tr","type","number","from","goingTime","getTimeForGoingTo","floor","_point","_point2","TableType","table","periodic","Points","collection","currentSelectedPoint","station_or_point","newCreatdPoint","heuristicTimeToFinalPoint","reservedTime","tryUpdate","finalPointCoords","st","contains","selectPointWithMinimalMark","selectedPointStation","selectedPointTotalTimeSeconds","selectedPointStationHashcode","selectedPointFromWhichRoute","momentWhenComingToStation","routesOnStation","selectedPointCoords","selectedPoint","getNextUnvisitedPoint","routes","nextStation","selectedRoute","getNextStation","getTimetable","momentWhenAskingForGoing","waitingTime","findTimeAfter","momentWhenSitInTransport","tbl","goingOnTransportTime","onNextPointtotalTimeSeconds","findElement","distanceToSelectedPoint","newTime","tryingNewTime","currentPoint","previousRouteStation","getPreviousStation","ttt","WayPoint","route","Coords","vehicles","gpsTrack","owner","stations","timetables","stationsJSON","currentStation","nn","dateTmp","Date","setMinutes","setHours","setSeconds","day","getDay","kkk","mnkk","days","stTime","iik","mnii","times","hour","minute","findTimeBefore","stt","initialize","bindRoutesStationsTimetables","tmpArr","tabArr","rr","tmp","find","element","index","array","routeCode","tmpTab","startInitializingMoment","now","tmpUsedStations","newAllStations","routesCodes","_i","_n","stationsCodes","rr_stationsCodes","tmpUsed","k","mn","_k","_mn","_station","ex","_i2","_n2","timetable"],"mappings":"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","file":"sw.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _dataProvider = __webpack_require__(3);\n\t\n\tvar _dataProvider2 = _interopRequireDefault(_dataProvider);\n\t\n\tvar _config = __webpack_require__(2);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tvar _optimalRoutesCollection = __webpack_require__(6);\n\t\n\tvar _optimalRoutesCollection2 = _interopRequireDefault(_optimalRoutesCollection);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t//import AppClient from './client';\n\t//let s = '123hello123';\n\tconsole.log('Hello from SW...');\n\t\n\tvar APP_CACHE_NAME = 'mosm-app-v1';\n\tvar TILE_CACHE_NAME = 'mosm-tiles-v1';\n\t\n\tvar urlsToCache = ['/', '/favicon.ico', '/static/js/bundle.js', '/static/css/style.css'];\n\t\n\tself.addEventListener('install', function (event) {\n\t  // Perform install steps\n\t  var cachePromise = caches.open(APP_CACHE_NAME).then(function (cache) {\n\t    console.log('install: opened cache');\n\t    return cache.addAll(urlsToCache);\n\t  }).then(function () {\n\t    console.log('install: added all urls to cache');\n\t  });\n\t\n\t  event.waitUntil(cachePromise);\n\t  //event.waitUntil(self.skipWaiting()); // Activate worker immediately\n\t});\n\t\n\tself.addEventListener('activate', function (event) {\n\t  _dataProvider2.default.loadDataAndInitialize();\n\t\n\t  //event.waitUntil(self.clients.claim()); // Become available to all pages\n\t  //console.log('!!!!!!!!!activate');\n\t\n\t  /**/\n\t});\n\t/*\r\n\tvar test = 0;\r\n\tsetInterval(function() {\r\n\t  test++\r\n\t}, 1000)\r\n\t*/\n\t//var ok = true;\n\t\n\tvar clients = [];\n\t\n\tself.addEventListener('message', function (event) {\n\t  var sender = event.source;\n\t  //console.log(event.data);\n\t  if (event.data === 'no-kill-sw') {\n\t    //console.log('SW: client call no-kill-sw.')\n\t    if (clients.includes(sender.id)) {\n\t      return;\n\t    } else {\n\t      clients.push(sender.id);\n\t      sender.postMessage('no-kill-sw-accepted');\n\t      setInterval(function () {\n\t        sender.postMessage(\"no-kill-sw-accepted\");\n\t      }, _config2.default.clientVsSwNoKillingMessageInterval);\n\t    }\n\t  } else if (event.data.requestType === 'optimalWay') {\n\t    console.log('SW: request for optimalWay.');\n\t\n\t    _dataProvider2.default.loadDataAndInitialize();\n\t\n\t    var params = event.data.params;\n\t    var rejected, resolved;\n\t    try {\n\t      var res = new _optimalRoutesCollection2.default(_dataProvider2.default.getAllStations(), params.startOptimalRoutePoint, params.finalOptimalRoutePoint, params.startTime, params.transportTypes, params.goingSpeed, params.dopTimeMinutes);\n\t      //console.log('res = ' + res);\n\t      resolved = res.getOptimalWays();\n\t      //console.log('resolved = ' + resolved);\n\t    } catch (e) {\n\t      console.log(e);\n\t      rejected = e;\n\t    } finally {\n\t      sender.postMessage({\n\t        requestType: 'optimalWayResult',\n\t        result: resolved\n\t      });\n\t    }\n\t  }\n\t  /*if(ok) {\r\n\t    //ok = false;\r\n\t    setInterval(function() {\r\n\t      sender.postMessage({\r\n\t        message: test\r\n\t      });\r\n\t    }, 1000)\r\n\t    //if (event.waitUntil) {\r\n\t    //  event.waitUntil(promise);\r\n\t    //}\r\n\t  }*/\n\t});\n\t\n\tself.addEventListener('fetch', function (event) {\n\t  var url = event.request.url;\n\t\n\t  event.respondWith(caches.match(event.request).then(function (response) {\n\t    // Cache hit - return response\n\t    if (response) {\n\t      return response;\n\t    }\n\t    caches.open(TILE_CACHE_NAME).then(function (cache) {\n\t      return cache.add(url);\n\t    });\n\t\n\t    return fetch(event.request);\n\t  }));\n\t});\n\t\n\t/*self.addEventListener('fetch', function(event) {\r\n\t  event.respondWith(\r\n\t    fetch(event.request).catch(function() {\r\n\t      return caches.match(event.request);\r\n\t    })\r\n\t  );\r\n\t});*/\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = distance;\n\tfunction distance(a, b) {\n\t    var earthRadius = 6372795;\n\t    var pi180 = 0.017453; // Math.PI / 180\n\t\n\t    // перевести координаты в радианы\n\t    var lat1 = a.lat * pi180;\n\t    var lat2 = b.lat * pi180;\n\t    var long1 = a.lng * pi180;\n\t    var long2 = b.lng * pi180;\n\t\n\t    //const pi2 = 1.5707963;\n\t    /*var zz = 1, yy = 1;\r\n\t    function taylorSin(x) {\r\n\t        yy = x * x;\r\n\t        zz = x;\r\n\t        return zz - (zz *= yy) / 6 + (zz *= yy) / 120;\r\n\t    }\r\n\t    function taylorCos(x) {\r\n\t        yy = x * x;\r\n\t        zz = yy;\r\n\t        return 1 - (yy) / 2 + (zz *= yy) / 24;\r\n\t    }*/\n\t    /*function taylorArcCos(x) {\r\n\t        yy = x * x;\r\n\t        zz = x;\r\n\t        return pi2 - zz - (zz *= yy)/6 - 3*(zz *= yy)/40;\r\n\t    }*/\n\t    /*function taylorAtan(x) {\r\n\t        yy = x * x;\r\n\t        zz = x;\r\n\t        return zz - (zz *= yy) / 3 + (zz *= yy) / 5 - (zz *= yy) / 7 + (zz *= yy) / 9 - (zz *= yy) / 20;\r\n\t    }*/\n\t    /*\r\n\t    // косинусы и синусы широт и разницы долгот\r\n\t    var cl1 = taylorCos(lat1);\r\n\t    var cl2 = taylorCos(lat2);\r\n\t    var sl1 = taylorSin(lat1);\r\n\t    var sl2 = taylorSin(lat2);\r\n\t    var delta = long2 - long1;\r\n\t    var cdelta = taylorCos(delta);\r\n\t    var sdelta = taylorSin(delta);\r\n\t      // вычисления длины большого круга\r\n\t    var tmp = cl2 * cdelta;\r\n\t    var y = Math.sqrt(cl2 * cl2 * sdelta * sdelta + (cl1 * sl2 - sl1 * tmp) * (cl1 * sl2 - sl1 * tmp));\r\n\t    var x = sl1 * sl2 + cl1 * tmp;\r\n\t      //\r\n\t    var ad = Math.atan2(y, x);//taylorAtan(y/x);\r\n\t    var dist = Math.ceil(ad * earthRadius);//(int)Math.Round(ad * earthRadius, 0);\r\n\t      //console.log(dist + \" vs \" + Math.acos(Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2))*earthRadius);\r\n\t    //console.log((taylorSin(lat1)*taylorSin(lat2)+taylorCos(lat1)*taylorCos(lat2)*taylorCos(long1-long2)) + \" vs \" + (Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2)));\r\n\t      return dist;\r\n\t    */\n\t\n\t    return Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(long1 - long2)) * earthRadius;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    apiPublicTransportServer: \"https://ptp-97126.app.xervo.io/\",\n\t    apiGetStationsUrl: \"https://publictransportproject.000webhostapp.com/new/json/stations.json\", //\"stations\"\n\t    apiGetRoutesUrl: \"https://publictransportproject.000webhostapp.com/new/json/routes.json\", //\"routes\"\n\t    apiGetTimetablesUrl: \"https://publictransportproject.000webhostapp.com/new/json/timetables.json\", //\"timetables\"\n\t\n\t    clientVsSwNoKillingMessageInterval: 30000\n\t};\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _loadDataOnly = function () {\n\t    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n\t        var response, _response, _response2;\n\t\n\t        return regeneratorRuntime.wrap(function _callee$(_context) {\n\t            while (1) {\n\t                switch (_context.prev = _context.next) {\n\t                    case 0:\n\t                        _context.next = 2;\n\t                        return _jsonDataStorage2.default.getAllStations();\n\t\n\t                    case 2:\n\t                        allStationsJSON = _context.sent;\n\t                        _context.next = 5;\n\t                        return _jsonDataStorage2.default.getAllRoutes();\n\t\n\t                    case 5:\n\t                        allRoutesJSON = _context.sent;\n\t                        _context.next = 8;\n\t                        return _jsonDataStorage2.default.getAllTimetables();\n\t\n\t                    case 8:\n\t                        allTimetablesJSON = _context.sent;\n\t\n\t                        if (allStationsLoaded) {\n\t                            _context.next = 27;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allStationsJSON == null)) {\n\t                            _context.next = 24;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allStationsJSON\"] === undefined || localStorage[\"allStationsJSON\"] == null\n\t                        console.log(\"Downloading stations from server...\");\n\t\n\t                        _context.next = 14;\n\t                        return fetch(_config2.default.apiGetStationsUrl);\n\t\n\t                    case 14:\n\t                        response = _context.sent;\n\t                        _context.next = 17;\n\t                        return response.text();\n\t\n\t                    case 17:\n\t                        allStationsJSON = _context.sent;\n\t\n\t                        allStations = JSON.parse(allStationsJSON); //await response.json();\n\t\n\t                        if (allStations !== undefined && allStations != null) _jsonDataStorage2.default.pushAllStations(allStationsJSON); //localStorage[\"allStationsJSON\"] = allStationsJSON;\n\t                        allStationsLoaded = true;\n\t                        console.log(\"Stations loaded from server.\");\n\t                        _context.next = 27;\n\t                        break;\n\t\n\t                    case 24:\n\t                        allStations = JSON.parse(allStationsJSON); //localStorage[\"allStationsJSON\"]\n\t                        allStationsLoaded = true;\n\t                        console.log(\"Stations loaded from localStorage.\");\n\t\n\t                    case 27:\n\t                        if (allRoutesLoaded) {\n\t                            _context.next = 45;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allRoutesJSON == null)) {\n\t                            _context.next = 42;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allRoutesJSON\"] === undefined || localStorage[\"allRoutesJSON\"] == null\n\t                        console.log(\"Downloading routes from server...\");\n\t\n\t                        _context.next = 32;\n\t                        return fetch(_config2.default.apiGetRoutesUrl);\n\t\n\t                    case 32:\n\t                        _response = _context.sent;\n\t                        _context.next = 35;\n\t                        return _response.text();\n\t\n\t                    case 35:\n\t                        allRoutesJSON = _context.sent;\n\t\n\t                        allRoutes = JSON.parse(allRoutesJSON); //await response.json();\n\t\n\t                        if (allRoutes !== undefined && allRoutes != null) _jsonDataStorage2.default.pushAllRoutes(allRoutesJSON); //localStorage[\"allRoutesJSON\"] = allRoutesJSON;\n\t                        allRoutesLoaded = true;\n\t                        console.log(\"Routes loaded from server.\");\n\t                        _context.next = 45;\n\t                        break;\n\t\n\t                    case 42:\n\t                        allRoutes = JSON.parse(allRoutesJSON); //localStorage[\"allRoutesJSON\"]\n\t                        allRoutesLoaded = true;\n\t                        console.log(\"Routes loaded from localStorage.\");\n\t\n\t                    case 45:\n\t                        if (allTimetablesLoaded) {\n\t                            _context.next = 63;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allTimetablesJSON == null)) {\n\t                            _context.next = 60;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allTimetablesJSON\"] === undefined || localStorage[\"allTimetablesJSON\"] == null\n\t                        console.log(\"Downloading timetables from server...\");\n\t\n\t                        _context.next = 50;\n\t                        return fetch(_config2.default.apiGetTimetablesUrl);\n\t\n\t                    case 50:\n\t                        _response2 = _context.sent;\n\t                        _context.next = 53;\n\t                        return _response2.text();\n\t\n\t                    case 53:\n\t                        allTimetablesJSON = _context.sent;\n\t\n\t                        allTimetables = JSON.parse(allTimetablesJSON); //await response.json();\n\t\n\t                        if (allTimetables !== undefined && allTimetables != null) _jsonDataStorage2.default.pushAllTimetables(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"] = allTimetablesJSON;\n\t                        allTimetablesLoaded = true;\n\t                        console.log(\"Timetables loaded from server.\");\n\t                        _context.next = 63;\n\t                        break;\n\t\n\t                    case 60:\n\t                        allTimetables = JSON.parse(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"]\n\t                        allTimetablesLoaded = true;\n\t                        console.log(\"Timetables loaded from localStorage.\");\n\t\n\t                    case 63:\n\t                    case 'end':\n\t                        return _context.stop();\n\t                }\n\t            }\n\t        }, _callee, this);\n\t    }));\n\t\n\t    return function _loadDataOnly() {\n\t        return _ref.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar loadData = function () {\n\t    var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {\n\t        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t            while (1) {\n\t                switch (_context2.prev = _context2.next) {\n\t                    case 0:\n\t                        if (loadingStarted) {\n\t                            _context2.next = 5;\n\t                            break;\n\t                        }\n\t\n\t                        loadingStarted = true;\n\t\n\t                        _context2.next = 4;\n\t                        return _loadDataOnly();\n\t\n\t                    case 4:\n\t\n\t                        if (allStationsLoaded && allRoutesLoaded && allTimetablesLoaded) {\n\t                            (0, _publicTransportInitializeData2.default)(allStations, allRoutes, allTimetables);\n\t                        }\n\t\n\t                    case 5:\n\t                    case 'end':\n\t                        return _context2.stop();\n\t                }\n\t            }\n\t        }, _callee2, this);\n\t    }));\n\t\n\t    return function loadData() {\n\t        return _ref2.apply(this, arguments);\n\t    };\n\t}();\n\t\n\t//loadData();\n\t\n\tvar _jsonDataStorage = __webpack_require__(4);\n\t\n\tvar _jsonDataStorage2 = _interopRequireDefault(_jsonDataStorage);\n\t\n\tvar _publicTransportInitializeData = __webpack_require__(11);\n\t\n\tvar _publicTransportInitializeData2 = _interopRequireDefault(_publicTransportInitializeData);\n\t\n\tvar _config = __webpack_require__(2);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Load data.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar allStations = null;\n\tvar allRoutes = null;\n\tvar allTimetables = null;\n\t\n\t//var updatingFromServerInterval = 5000;\n\t\n\tvar loadingStarted = false;\n\t\n\tvar allStationsLoaded = false,\n\t    allRoutesLoaded = false,\n\t    allTimetablesLoaded = false;\n\tvar allStationsJSON = null,\n\t    allRoutesJSON = null,\n\t    allTimetablesJSON = null;\n\t\n\tvar DataProvider = function () {\n\t    function DataProvider() {\n\t        _classCallCheck(this, DataProvider);\n\t    }\n\t\n\t    _createClass(DataProvider, null, [{\n\t        key: 'getAllStations',\n\t        value: function getAllStations() {\n\t            return allStations;\n\t        }\n\t    }, {\n\t        key: 'getAllRoutes',\n\t        value: function getAllRoutes() {\n\t            return allRoutes;\n\t        }\n\t    }, {\n\t        key: 'getAllTimetables',\n\t        value: function getAllTimetables() {\n\t            return allTimetables;\n\t        }\n\t    }, {\n\t        key: 'getAllStationsJSON',\n\t        value: function getAllStationsJSON() {\n\t            return allStationsJSON;\n\t        }\n\t    }, {\n\t        key: 'getAllRoutesJSON',\n\t        value: function getAllRoutesJSON() {\n\t            return allRoutesJSON;\n\t        }\n\t    }, {\n\t        key: 'getAllTimetablesJSON',\n\t        value: function getAllTimetablesJSON() {\n\t            return allTimetablesJSON;\n\t        }\n\t    }, {\n\t        key: 'loadDataAndInitialize',\n\t        value: function () {\n\t            var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n\t                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n\t                    while (1) {\n\t                        switch (_context3.prev = _context3.next) {\n\t                            case 0:\n\t                                _context3.next = 2;\n\t                                return loadData();\n\t\n\t                            case 2:\n\t                            case 'end':\n\t                                return _context3.stop();\n\t                        }\n\t                    }\n\t                }, _callee3, this);\n\t            }));\n\t\n\t            function loadDataAndInitialize() {\n\t                return _ref3.apply(this, arguments);\n\t            }\n\t\n\t            return loadDataAndInitialize;\n\t        }()\n\t    }, {\n\t        key: 'loadDataOnly',\n\t        value: function () {\n\t            var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n\t                return regeneratorRuntime.wrap(function _callee4$(_context4) {\n\t                    while (1) {\n\t                        switch (_context4.prev = _context4.next) {\n\t                            case 0:\n\t                                _context4.next = 2;\n\t                                return _loadDataOnly();\n\t\n\t                            case 2:\n\t                            case 'end':\n\t                                return _context4.stop();\n\t                        }\n\t                    }\n\t                }, _callee4, this);\n\t            }));\n\t\n\t            function loadDataOnly() {\n\t                return _ref4.apply(this, arguments);\n\t            }\n\t\n\t            return loadDataOnly;\n\t        }()\n\t    }]);\n\t\n\t    return DataProvider;\n\t}();\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End load data.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\texports.default = DataProvider;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar getJsonDataStorageConnection = function () {\n\t    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {\n\t        var promise;\n\t        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n\t            while (1) {\n\t                switch (_context2.prev = _context2.next) {\n\t                    case 0:\n\t                        promise = new Promise(function (resolve, reject) {\n\t\n\t                            var request = indexedDB.open(dbName, 1);\n\t                            request.onerror = function (event) {\n\t                                reject(event.target.error);\n\t                            };\n\t                            request.onsuccess = function (event) {\n\t                                resolve(event.target.result);\n\t                            };\n\t                            request.onupgradeneeded = function () {\n\t                                var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee(event) {\n\t                                    var db, objectStore, result;\n\t                                    return regeneratorRuntime.wrap(function _callee$(_context) {\n\t                                        while (1) {\n\t                                            switch (_context.prev = _context.next) {\n\t                                                case 0:\n\t                                                    db = event.target.result;\n\t                                                    objectStore = db.createObjectStore(storeName, { keyPath: \"name\" });\n\t\n\t                                                    objectStore.createIndex(\"json\", \"json\", { unique: false });\n\t\n\t                                                    _context.next = 5;\n\t                                                    return getJsonDataStorageConnection();\n\t\n\t                                                case 5:\n\t                                                    result = _context.sent;\n\t\n\t                                                    resolve(result);\n\t\n\t                                                case 7:\n\t                                                case \"end\":\n\t                                                    return _context.stop();\n\t                                            }\n\t                                        }\n\t                                    }, _callee, this);\n\t                                }));\n\t\n\t                                return function (_x) {\n\t                                    return _ref2.apply(this, arguments);\n\t                                };\n\t                            }();\n\t                        });\n\t                        _context2.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context2.abrupt(\"return\", _context2.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context2.stop();\n\t                }\n\t            }\n\t        }, _callee2, this);\n\t    }));\n\t\n\t    return function getJsonDataStorageConnection() {\n\t        return _ref.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar tryPush = function () {\n\t    var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(obj) {\n\t        var promise;\n\t        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n\t            while (1) {\n\t                switch (_context4.prev = _context4.next) {\n\t                    case 0:\n\t                        promise = new Promise(function () {\n\t                            var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(resolve, reject) {\n\t                                var db, transaction, objectStore, request;\n\t                                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n\t                                    while (1) {\n\t                                        switch (_context3.prev = _context3.next) {\n\t                                            case 0:\n\t                                                _context3.next = 2;\n\t                                                return getJsonDataStorageConnection();\n\t\n\t                                            case 2:\n\t                                                db = _context3.sent;\n\t\n\t                                                //console.log(db);\n\t                                                transaction = db.transaction([storeName], \"readwrite\");\n\t                                                objectStore = transaction.objectStore(storeName);\n\t                                                request = objectStore.add({\n\t                                                    name: obj.name,\n\t                                                    json: obj.json\n\t                                                });\n\t\n\t                                                request.onerror = function (event) {\n\t                                                    reject(event.target.error);\n\t                                                };\n\t                                                request.onsuccess = function (event) {\n\t                                                    resolve(event.target.result);\n\t                                                };\n\t\n\t                                            case 8:\n\t                                            case \"end\":\n\t                                                return _context3.stop();\n\t                                        }\n\t                                    }\n\t                                }, _callee3, this);\n\t                            }));\n\t\n\t                            return function (_x3, _x4) {\n\t                                return _ref4.apply(this, arguments);\n\t                            };\n\t                        }());\n\t                        _context4.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context4.abrupt(\"return\", _context4.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context4.stop();\n\t                }\n\t            }\n\t        }, _callee4, this);\n\t    }));\n\t\n\t    return function tryPush(_x2) {\n\t        return _ref3.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar getItem = function () {\n\t    var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(name) {\n\t        var promise;\n\t        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n\t            while (1) {\n\t                switch (_context6.prev = _context6.next) {\n\t                    case 0:\n\t                        promise = new Promise(function () {\n\t                            var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(resolve, reject) {\n\t                                var db, transaction, objectStore, request;\n\t                                return regeneratorRuntime.wrap(function _callee5$(_context5) {\n\t                                    while (1) {\n\t                                        switch (_context5.prev = _context5.next) {\n\t                                            case 0:\n\t                                                _context5.next = 2;\n\t                                                return getJsonDataStorageConnection();\n\t\n\t                                            case 2:\n\t                                                db = _context5.sent;\n\t                                                transaction = db.transaction([storeName]);\n\t                                                objectStore = transaction.objectStore(storeName);\n\t                                                request = objectStore.get(name);\n\t\n\t                                                request.onsuccess = function (event) {\n\t                                                    if (event.target.result !== undefined) {\n\t                                                        resolve(event.target.result.json);\n\t                                                    } else {\n\t                                                        //resolve(null);\n\t                                                        reject(event.target.error);\n\t                                                    }\n\t                                                };\n\t                                                request.onerror = function (event) {\n\t                                                    reject(event.target.error);\n\t                                                };\n\t\n\t                                            case 8:\n\t                                            case \"end\":\n\t                                                return _context5.stop();\n\t                                        }\n\t                                    }\n\t                                }, _callee5, this);\n\t                            }));\n\t\n\t                            return function (_x6, _x7) {\n\t                                return _ref6.apply(this, arguments);\n\t                            };\n\t                        }());\n\t                        _context6.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context6.abrupt(\"return\", _context6.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context6.stop();\n\t                }\n\t            }\n\t        }, _callee6, this);\n\t    }));\n\t\n\t    return function getItem(_x5) {\n\t        return _ref5.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\t//import ApiConfig from './config';\n\t\n\tvar dbName = \"public_transport2\";\n\tvar storeName = \"json_data\";\n\t\n\tvar JsonDataStorage = function () {\n\t    function JsonDataStorage() {\n\t        _classCallCheck(this, JsonDataStorage);\n\t    }\n\t\n\t    _createClass(JsonDataStorage, null, [{\n\t        key: \"getAllStations\",\n\t        value: function () {\n\t            var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {\n\t                return regeneratorRuntime.wrap(function _callee7$(_context7) {\n\t                    while (1) {\n\t                        switch (_context7.prev = _context7.next) {\n\t                            case 0:\n\t                                _context7.prev = 0;\n\t                                _context7.next = 3;\n\t                                return getItem('allStations');\n\t\n\t                            case 3:\n\t                                return _context7.abrupt(\"return\", _context7.sent);\n\t\n\t                            case 6:\n\t                                _context7.prev = 6;\n\t                                _context7.t0 = _context7[\"catch\"](0);\n\t                                return _context7.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context7.stop();\n\t                        }\n\t                    }\n\t                }, _callee7, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllStations() {\n\t                return _ref7.apply(this, arguments);\n\t            }\n\t\n\t            return getAllStations;\n\t        }()\n\t    }, {\n\t        key: \"getAllRoutes\",\n\t        value: function () {\n\t            var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {\n\t                return regeneratorRuntime.wrap(function _callee8$(_context8) {\n\t                    while (1) {\n\t                        switch (_context8.prev = _context8.next) {\n\t                            case 0:\n\t                                _context8.prev = 0;\n\t                                _context8.next = 3;\n\t                                return getItem('allRoutes');\n\t\n\t                            case 3:\n\t                                return _context8.abrupt(\"return\", _context8.sent);\n\t\n\t                            case 6:\n\t                                _context8.prev = 6;\n\t                                _context8.t0 = _context8[\"catch\"](0);\n\t                                return _context8.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context8.stop();\n\t                        }\n\t                    }\n\t                }, _callee8, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllRoutes() {\n\t                return _ref8.apply(this, arguments);\n\t            }\n\t\n\t            return getAllRoutes;\n\t        }()\n\t    }, {\n\t        key: \"getAllTimetables\",\n\t        value: function () {\n\t            var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {\n\t                return regeneratorRuntime.wrap(function _callee9$(_context9) {\n\t                    while (1) {\n\t                        switch (_context9.prev = _context9.next) {\n\t                            case 0:\n\t                                _context9.prev = 0;\n\t                                _context9.next = 3;\n\t                                return getItem('allTimetables');\n\t\n\t                            case 3:\n\t                                return _context9.abrupt(\"return\", _context9.sent);\n\t\n\t                            case 6:\n\t                                _context9.prev = 6;\n\t                                _context9.t0 = _context9[\"catch\"](0);\n\t                                return _context9.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context9.stop();\n\t                        }\n\t                    }\n\t                }, _callee9, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllTimetables() {\n\t                return _ref9.apply(this, arguments);\n\t            }\n\t\n\t            return getAllTimetables;\n\t        }()\n\t    }, {\n\t        key: \"pushAllStations\",\n\t        value: function () {\n\t            var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(allStationsJson) {\n\t                return regeneratorRuntime.wrap(function _callee10$(_context10) {\n\t                    while (1) {\n\t                        switch (_context10.prev = _context10.next) {\n\t                            case 0:\n\t                                _context10.prev = 0;\n\t                                _context10.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allStations',\n\t                                    json: allStationsJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context10.abrupt(\"return\", _context10.sent);\n\t\n\t                            case 6:\n\t                                _context10.prev = 6;\n\t                                _context10.t0 = _context10[\"catch\"](0);\n\t                                return _context10.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context10.stop();\n\t                        }\n\t                    }\n\t                }, _callee10, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllStations(_x8) {\n\t                return _ref10.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllStations;\n\t        }()\n\t    }, {\n\t        key: \"pushAllRoutes\",\n\t        value: function () {\n\t            var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(allRoutesJson) {\n\t                return regeneratorRuntime.wrap(function _callee11$(_context11) {\n\t                    while (1) {\n\t                        switch (_context11.prev = _context11.next) {\n\t                            case 0:\n\t                                _context11.prev = 0;\n\t                                _context11.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allRoutes',\n\t                                    json: allRoutesJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context11.abrupt(\"return\", _context11.sent);\n\t\n\t                            case 6:\n\t                                _context11.prev = 6;\n\t                                _context11.t0 = _context11[\"catch\"](0);\n\t                                return _context11.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context11.stop();\n\t                        }\n\t                    }\n\t                }, _callee11, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllRoutes(_x9) {\n\t                return _ref11.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllRoutes;\n\t        }()\n\t    }, {\n\t        key: \"pushAllTimetables\",\n\t        value: function () {\n\t            var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(allTimetablesJson) {\n\t                return regeneratorRuntime.wrap(function _callee12$(_context12) {\n\t                    while (1) {\n\t                        switch (_context12.prev = _context12.next) {\n\t                            case 0:\n\t                                _context12.prev = 0;\n\t                                _context12.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allTimetables',\n\t                                    json: allTimetablesJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context12.abrupt(\"return\", _context12.sent);\n\t\n\t                            case 6:\n\t                                _context12.prev = 6;\n\t                                _context12.t0 = _context12[\"catch\"](0);\n\t                                return _context12.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context12.stop();\n\t                        }\n\t                    }\n\t                }, _callee12, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllTimetables(_x10) {\n\t                return _ref12.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllTimetables;\n\t        }()\n\t    }]);\n\t\n\t    return JsonDataStorage;\n\t}();\n\t\n\texports.default = JsonDataStorage;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t        value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//import Points from './points';\n\t//import IgnoringFragments from './ignoringFragments';\n\t\n\tvar OptimalRoute = function () {\n\t        function OptimalRoute(myPoints, stationsList, /*nowPos, needPos,*/time, types, goingSpeed, dopTimeMinutes, ignoringRoutesAdd, ignoringList) {\n\t                _classCallCheck(this, OptimalRoute);\n\t\n\t                if (ignoringRoutesAdd != null) this.ignoringRoutes = ignoringRoutesAdd;else this.ignoringRoutes = [];\n\t\n\t                this.points = [];\n\t\n\t                //this.needPos = needPos;\n\t                //this.nowPos = nowPos;\n\t                this.goingSpeed = goingSpeed;\n\t                this.time = time;\n\t                var reservedTimeSeconds = 60 * dopTimeMinutes;\n\t\n\t                this.types = types;\n\t\n\t                this.myIgnoringFragments = null;\n\t                //if (ignoringList != null) this.myIgnoringFragments = new IgnoringFragments(ignoringList);\n\t                //else this.myIgnoringFragments = new IgnoringFragments();\n\t\n\t                //var myPoints = new Points(nowPos, needPos);\n\t\n\t                myPoints.fillStartData(stationsList, goingSpeed, reservedTimeSeconds, this.myIgnoringFragments);\n\t\n\t                // Находим кратчайшие пути до всех вершин:\n\t                myPoints.countShortWay(this.ignoringRoutes, this.myIgnoringFragments, time, types, goingSpeed, reservedTimeSeconds);\n\t\n\t                var tmpP = myPoints.finalPoint;\n\t                this.points.push(tmpP.toString()); ////\n\t                while (tmpP.previousPoint != null) {\n\t                        tmpP = tmpP.previousPoint; //\n\t                        this.points.push(tmpP.toString());\n\t                        if (tmpP.previousPoint == null && tmpP.coords !== myPoints.startPoint.coords) throw new Error(\"Где-то удалилась часть маршрута...\");\n\t                }\n\t\n\t                this.totalTimeSeconds = myPoints.finalPoint.totalTimeSeconds;\n\t                this.totalGoingTime = myPoints.finalPoint.getTotalGoingTime();\n\t                this.totalTransportChangingCount = myPoints.finalPoint.getTotalTransportChangingCount();\n\t\n\t                this.myPoints = myPoints;\n\t\n\t                this.isVisited = false;\n\t        }\n\t\n\t        _createClass(OptimalRoute, [{\n\t                key: \"setVisited\",\n\t                value: function setVisited() {\n\t                        this.isVisited = true;\n\t                }\n\t        }]);\n\t\n\t        return OptimalRoute;\n\t}();\n\t\n\texports.default = OptimalRoute;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _optimalRoute = __webpack_require__(5);\n\t\n\tvar _optimalRoute2 = _interopRequireDefault(_optimalRoute);\n\t\n\tvar _optimalWay = __webpack_require__(7);\n\t\n\tvar _optimalWay2 = _interopRequireDefault(_optimalWay);\n\t\n\tvar _points = __webpack_require__(9);\n\t\n\tvar _points2 = _interopRequireDefault(_points);\n\t\n\tvar _geoCoordsDistance = __webpack_require__(1);\n\t\n\tvar _geoCoordsDistance2 = _interopRequireDefault(_geoCoordsDistance);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //import IgnoringFragments from './ignoringFragments';\n\t\n\t\n\tvar heuristicBestTransportSpeed = 40;\n\t\n\tfunction getStationsAround(allStations, nowPos, needPos, goingSpeed, heuristicBestTransportSpeed) {\n\t    var result = [];\n\t    var fullDistance = (0, _geoCoordsDistance2.default)(nowPos, needPos);\n\t    for (var i = 0, n = allStations.length, s = allStations[0]; i < n; s = allStations[++i]) {\n\t        if (s != null && fullDistance > (0, _geoCoordsDistance2.default)(nowPos, s.coords) + goingSpeed * (0, _geoCoordsDistance2.default)(s.coords, needPos) / heuristicBestTransportSpeed) {\n\t            result.push(s);\n\t        }\n\t    }\n\t    return result;\n\t}\n\t\n\tvar OptimalRoutesCollection = function (_Array) {\n\t    _inherits(OptimalRoutesCollection, _Array);\n\t\n\t    /*getOptimalWays() {\r\n\t        var result = [];\r\n\t        for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n\t            result.push(new OptimalWay(r));\r\n\t        }\r\n\t        return result;\r\n\t    }*/\n\t    /*selectOptimalRouteWithMinimalMark() {\r\n\t        var p = null;\r\n\t        for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n\t            if (!(t.isVisited)) {\r\n\t                p = t;\r\n\t                for (t = this[++i]; i < n; t = this[++i]) {\r\n\t                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n\t                        p = t;\r\n\t                    }\r\n\t                }\r\n\t                return p;\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    }*/\n\t    function OptimalRoutesCollection(allStations, nowPos, needPos, time, types, speed, dopTimeMinutes) {\n\t        _classCallCheck(this, OptimalRoutesCollection);\n\t\n\t        var _this = _possibleConstructorReturn(this, (OptimalRoutesCollection.__proto__ || Object.getPrototypeOf(OptimalRoutesCollection)).call(this));\n\t\n\t        _this.getOptimalWays = function () {\n\t            var result = [];\n\t            for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\n\t                result.push(new _optimalWay2.default(r));\n\t            }\n\t            return result;\n\t        };\n\t        _this.selectOptimalRouteWithMinimalMark = function () {\n\t            var p = null;\n\t            for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\n\t                if (!t.isVisited) {\n\t                    p = t;\n\t                    for (t = this[++i]; i < n; t = this[++i]) {\n\t                        if (!t.isVisited && t.totalTimeSeconds < p.totalTimeSeconds) {\n\t                            p = t;\n\t                        }\n\t                    }\n\t                    return p;\n\t                }\n\t            }\n\t            return null;\n\t        };\n\t\n\t        var myPoints = new _points2.default(nowPos, needPos);\n\t        // Получим \"начальный\" список станций:\n\t        var stationsList = getStationsAround(allStations, nowPos, needPos, speed, heuristicBestTransportSpeed);\n\t\n\t        _this.push(new _optimalRoute2.default(myPoints, stationsList, /*nowPos, needPos,*/time, types, speed, dopTimeMinutes));\n\t\n\t        var ignoringRoutes = [];\n\t\n\t        //var ignoringFragments = new IgnoringFragments();\n\t\n\t        for (var selectedOptimalRoute = _this[0]; selectedOptimalRoute != null; selectedOptimalRoute.setVisited(), selectedOptimalRoute = _this.selectOptimalRouteWithMinimalMark()) {\n\t            var ddd = 0.25;\n\t\n\t            ignoringRoutes = [];\n\t            // Проходим по всем ребрам выбранного пути и строим новые маршруты при удалении ребер:\n\t            for (var tmpP = selectedOptimalRoute.myPoints.finalPoint; tmpP.previousPoint != null; tmpP = tmpP.previousPoint) {\n\t                //if(tmpP == null) console.log(\"err in optimalRoutesCollection.js\");\n\t                if (tmpP.fromWhichRoute != null && !ignoringRoutes.includes(tmpP.fromWhichRoute)) ignoringRoutes.push(tmpP.fromWhichRoute);\n\t            }\n\t            for (var i = 0, n = ignoringRoutes.length, r = ignoringRoutes[0]; i < n; r = ignoringRoutes[++i]) {\n\t                if (selectedOptimalRoute.ignoringRoutes.includes(r)) continue;\n\t                var ignoringRoutesAdd = [];\n\t                ignoringRoutesAdd = ignoringRoutesAdd.concat(selectedOptimalRoute.ignoringRoutes);\n\t                ignoringRoutesAdd.push(r);\n\t                myPoints = new _points2.default(nowPos, needPos);\n\t                var tmpOptimalRoute = new _optimalRoute2.default(myPoints, stationsList, /*nowPos, needPos,*/time, types, speed, dopTimeMinutes, ignoringRoutesAdd);\n\t\n\t                if (tmpOptimalRoute.totalTimeSeconds <= _this[0].totalTimeSeconds / ddd) {\n\t                    var tmpJSON = JSON.stringify(tmpOptimalRoute.points);\n\t                    var ok = false;\n\t                    for (var j = 0, m = _this.length, opt = _this[0]; j < m; opt = _this[++j]) {\n\t                        if (JSON.stringify(opt.points) === tmpJSON) {\n\t                            ok = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (ok) continue;\n\t                    _this.push(tmpOptimalRoute);\n\t                }\n\t            }\n\t        }\n\t        return _this;\n\t    }\n\t\n\t    return OptimalRoutesCollection;\n\t}(Array);\n\t\n\texports.default = OptimalRoutesCollection;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _wayPoint = __webpack_require__(10);\n\t\n\tvar _wayPoint2 = _interopRequireDefault(_wayPoint);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar OptimalWay = function OptimalWay(optimalRoute) {\n\t    _classCallCheck(this, OptimalWay);\n\t\n\t    this.totalTimeSeconds = optimalRoute.totalTimeSeconds;\n\t    this.totalGoingTimeSeconds = optimalRoute.totalGoingTime;\n\t    this.totalTransportChangingCount = optimalRoute.totalTransportChangingCount;\n\t    this.points = [];\n\t\n\t    for (var tmpP = optimalRoute.myPoints.finalPoint; tmpP != null; tmpP = tmpP.previousPoint) {\n\t        this.points.push(new _wayPoint2.default(tmpP.totalTimeSeconds, tmpP.station, tmpP.fromWhichRoute, tmpP.coords));\n\t    }\n\t    this.points.reverse();\n\t};\n\t\n\texports.default = OptimalWay;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Point = function () {\n\t    function Point(totalTimeSeconds, station_or_crds, fromWhichStation, fromWhichRoute) {\n\t        _classCallCheck(this, Point);\n\t\n\t        if (station_or_crds.hashcode !== undefined) {\n\t            this.station = station_or_crds;\n\t            this.stationCode = station_or_crds.hashcode;\n\t            station_or_crds.point = this;\n\t            this.coords = station_or_crds.coords;\n\t        } else {\n\t            this.coords = station_or_crds;\n\t            this.station = null;\n\t            this.stationCode = null;\n\t        }\n\t        this.totalTimeSeconds = totalTimeSeconds;\n\t        this.fromWhichStation = fromWhichStation;\n\t        this.fromWhichRoute = fromWhichRoute;\n\t\n\t        this.isVisited = false;\n\t\n\t        this.previousPoint = null;\n\t    }\n\t\n\t    _createClass(Point, [{\n\t        key: \"tryUpdate\",\n\t        value: function tryUpdate(totalTimeSeconds, previousPoint, fromWhichStation, fromWhichRoute) {\n\t            if (totalTimeSeconds < this.totalTimeSeconds) {\n\t                this.fromWhichRoute = fromWhichRoute;\n\t                this.previousPoint = previousPoint;\n\t                this.totalTimeSeconds = totalTimeSeconds;\n\t                this.fromWhichStation = fromWhichStation;\n\t\n\t                return true;\n\t            }\n\t            return false;\n\t        }\n\t    }, {\n\t        key: \"setVisited\",\n\t        value: function setVisited() {\n\t            this.isVisited = true;\n\t        }\n\t    }, {\n\t        key: \"toString\",\n\t        value: function toString() {\n\t            var to, tr; //, from, p;\n\t            //if (this.fromWhichStation != null) from = this.fromWhichStation.name;\n\t            //else from = \"null\";\n\t            if (this.station != null) to = this.station.name;else to = \"null\";\n\t            if (this.fromWhichRoute != null) tr = this.fromWhichRoute.type + \" \" + this.fromWhichRoute.number + \" \" + this.fromWhichRoute.from + \" - \" + this.fromWhichRoute.to;else tr = \"пешком\";\n\t            //if (this.previousPoint != null) p = this.previousPoint.toString();\n\t            //else p = \"null\";\n\t            return (/*p+\" -->> */\"(\" + this.totalTimeSeconds + \") \" + to + \" (\" + tr + \")\"\n\t            ); // from \" + from + \" to\n\t        }\n\t    }, {\n\t        key: \"getTotalGoingTime\",\n\t        value: function getTotalGoingTime() {\n\t            var goingTime = 0;\n\t            var tmpP = this;\n\t            //this.points.Add(tmpP.ToString());\n\t            while (tmpP.previousPoint != null) {\n\t                if (tmpP.fromWhichRoute == null /*&& tmpP.fromWhichRoute.hashcode == null*/) goingTime += tmpP.totalTimeSeconds - tmpP.previousPoint.totalTimeSeconds;\n\t                tmpP = tmpP.previousPoint;\n\t            }\n\t            return goingTime;\n\t        }\n\t    }, {\n\t        key: \"getTotalTransportChangingCount\",\n\t        value: function getTotalTransportChangingCount() {\n\t            var result = 0;\n\t            var tmpP = this;\n\t            //this.points.Add(tmpP.ToString());\n\t            while (tmpP.previousPoint != null) {\n\t                if (tmpP.fromWhichRoute != null && tmpP.fromWhichRoute.hashcode != null && tmpP.fromWhichRoute !== tmpP.previousPoint.fromWhichRoute) result++;\n\t                tmpP = tmpP.previousPoint;\n\t            }\n\t            return result;\n\t        }\n\t    }]);\n\t\n\t    return Point;\n\t}();\n\t\n\texports.default = Point;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _point = __webpack_require__(8);\n\t\n\tvar _point2 = _interopRequireDefault(_point);\n\t\n\tvar _geoCoordsDistance = __webpack_require__(1);\n\t\n\tvar _geoCoordsDistance2 = _interopRequireDefault(_geoCoordsDistance);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction getTimeForGoingTo(distance, goingSpeed) {\n\t    return Math.floor(distance / (goingSpeed / 3.6));\n\t}\n\t\n\tvar TableType = { table: 1, periodic: 2 };\n\t\n\tvar Points = function () {\n\t    function Points(nowPos, needPos) {\n\t        _classCallCheck(this, Points);\n\t\n\t        this.collection = [];\n\t        this.startPoint = new _point2.default(0, nowPos, null, null);\n\t        this.finalPoint = new _point2.default(2160000000, needPos, null, null);\n\t        this.currentSelectedPoint = null;\n\t    }\n\t\n\t    _createClass(Points, [{\n\t        key: 'findElement',\n\t        value: function findElement(station_or_point) {\n\t            if (station_or_point.hashcode != null) {\n\t                if (station_or_point.point != null) return station_or_point.point;\n\t                var newCreatdPoint = new _point2.default(2160000000, station_or_point, null, null);\n\t                newCreatdPoint.heuristicTimeToFinalPoint = (0, _geoCoordsDistance2.default)(newCreatdPoint.coords, this.finalPoint.coords) / 5;\n\t                this.collection.push(newCreatdPoint);\n\t                return newCreatdPoint;\n\t            } else {\n\t                for (var i = 0, n = this.collection.length, p = this.collection[0]; i < n; p = this.collection[++i]) {\n\t                    if (p.coords === station_or_point.coords && p.stationCode === station_or_point.stationCode) return p;\n\t                }\n\t                return null;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'fillStartData',\n\t        value: function fillStartData(stationsList, goingSpeed, reservedTime, myIgnoringFragments) {\n\t            this.finalPoint.tryUpdate(getTimeForGoingTo((0, _geoCoordsDistance2.default)(this.startPoint.coords, this.finalPoint.coords), goingSpeed) + 1800 /*+ TimeSpan.FromMinutes(20)*/, this.startPoint, null, null);\n\t            var finalPointCoords = this.finalPoint.coords;\n\t            for (var i = 0, n = stationsList.length, st = stationsList[0]; i < n; st = stationsList[++i]) {\n\t                if (myIgnoringFragments != null && myIgnoringFragments.contains(st.hashcode, null, null)) continue;\n\t\n\t                var add = new _point2.default(2160000000, st, null, null);\n\t                add.heuristicTimeToFinalPoint = (0, _geoCoordsDistance2.default)(add.coords, finalPointCoords) / 5;\n\t                add.tryUpdate(getTimeForGoingTo((0, _geoCoordsDistance2.default)(this.startPoint.coords, st.coords), goingSpeed) + reservedTime, this.startPoint, null, null);\n\t                this.collection.push(add);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getNextUnvisitedPoint',\n\t        value: function getNextUnvisitedPoint() {\n\t            if (this.currentSelectedPoint != null) this.currentSelectedPoint.setVisited();\n\t\n\t            this.currentSelectedPoint = this.selectPointWithMinimalMark();\n\t\n\t            return this.currentSelectedPoint;\n\t        }\n\t    }, {\n\t        key: 'selectPointWithMinimalMark',\n\t        value: function selectPointWithMinimalMark() {\n\t            var p = null;\n\t            for (var i = 0, n = this.collection.length, t = this.collection[0]; i < n; t = this.collection[++i]) {\n\t                if (!t.isVisited) {\n\t                    p = t;\n\t                    //var euristicTimeSecondsToFinalPoint = distance(p.coords, this.finalPoint.coords) / 5; // Оценка оставшегося времени пути в секундах.\n\t                    for (t = this.collection[++i]; i < n; t = this.collection[++i]) {\n\t                        //var tmpEuristic = distance(t.coords, this.finalPoint.coords) / 5;\n\t                        if (!t.isVisited && t.totalTimeSeconds + t.heuristicTimeToFinalPoint < p.totalTimeSeconds + p.heuristicTimeToFinalPoint) {\n\t                            p = t;\n\t                            //euristicTimeSecondsToFinalPoint = tmpEuristic;\n\t                        }\n\t                    }\n\t                    return p;\n\t                }\n\t            }\n\t            return null;\n\t        }\n\t    }, {\n\t        key: 'countShortWay',\n\t        value: function countShortWay(ignoringRoutes, myIgnoringFragments, time, types, speed, reservedTime) {\n\t            //TimeSpan overLimitResedvedTime = TimeSpan.FromMinutes(20);\n\t\n\t            for (var selectedPoint = this.getNextUnvisitedPoint(), selectedPointStation, selectedPointTotalTimeSeconds, selectedPointStationHashcode, selectedPointFromWhichRoute, momentWhenComingToStation, routesOnStation, selectedPointCoords; selectedPoint != null; selectedPoint = this.getNextUnvisitedPoint()) {\n\t                //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t                selectedPointTotalTimeSeconds = selectedPoint.totalTimeSeconds;\n\t                if (selectedPointTotalTimeSeconds > this.finalPoint.totalTimeSeconds /* + overLimitResedvedTime*/) //... Пропускаем и удаляем, если значение метки превышает минимальное время до пункта назначения.\n\t                    {\n\t                        break;\n\t                    }\n\t                selectedPointStation = selectedPoint.station;\n\t                selectedPointStationHashcode = selectedPointStation.hashcode;\n\t                selectedPointFromWhichRoute = selectedPoint.fromWhichRoute;\n\t                if (selectedPointStation != null) {\n\t                    // Момент, когда мы прибудем на остановку:\n\t                    momentWhenComingToStation = time + selectedPointTotalTimeSeconds;\n\t                    // Загружаем маршруты, проходящие через остановку:\n\t                    routesOnStation = null; // = routesOnStation = Database.GetRoutesOnStation(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);\n\t                    if (selectedPointStation.routes != null) routesOnStation = selectedPointStation.routes;else continue;\n\t\n\t                    for (var i = 0, n = routesOnStation.length, selectedRoute = routesOnStation[0], nextStation; i < n; selectedRoute = routesOnStation[++i]) {\n\t                        if (ignoringRoutes != null && ignoringRoutes.includes(selectedRoute)) continue;\n\t                        if (types.includes(selectedRoute.type)) {\n\t                            // Следующая остановка у данного тран спорта:\n\t                            nextStation = selectedRoute.getNextStation(selectedPointStation);\n\t\n\t                            /*// Код остановки, на которую попадем на данном транспорте:\r\n\t                            string nextCode = selectedRoute.getNextStationCodeAfter(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);*/\n\t                            if (nextStation /*nextCode*/ != null) // Если остановка не является конечной, то:\n\t                                {\n\t                                    // Загружаем расписание:\n\t                                    var table = selectedRoute.getTimetable(selectedPointStation); //Database.getTimetable(selectedPointStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\t                                    // Блокируем попытку попасть указанным транспортом на указанную остановку:\n\t                                    if (myIgnoringFragments != null && myIgnoringFragments.contains(nextStation.hashcode /*nextCode*/, selectedRoute.hashcode, selectedPointStationHashcode)) continue;\n\t\n\t                                    if (table.type === TableType.table) // Если это точное расписание, то:\n\t                                        {\n\t                                            // Минимальный начальный момент, с который можно начинать ожидать посадку:\n\t                                            var momentWhenAskingForGoing = momentWhenComingToStation;\n\t\n\t                                            // Резервируем дополнительное время, если будем пересаживаться на другой маршрут:\n\t                                            //if (selectedPoint.RouteCode == null || selectedPoint.RouteCode != selectedRoute.hashcode) momentWhenAskingForGoing += reservedTime;\n\t                                            if (selectedPointFromWhichRoute != null && selectedPointFromWhichRoute !== selectedRoute) momentWhenAskingForGoing += reservedTime;\n\t\n\t                                            // Подсчитываем, сколько будем ожидать этот транспорт на остановке:\n\t                                            var waitingTime = table.findTimeAfter(momentWhenAskingForGoing);\n\t\n\t                                            // Момент, когда мы сядем в транспорт:\n\t                                            var momentWhenSitInTransport = momentWhenAskingForGoing + waitingTime;\n\t\n\t                                            /*// Следующая остановка у данного транспорта:\r\n\t                                            Station nextStation = Database.GetStationByHashcode(nextCode, databaseMysqlConnection, canReadDataFromLocalCopy: true);*/\n\t\n\t                                            // И соответствующее расписание на этой остановке:\n\t                                            var tbl = selectedRoute.getTimetable(nextStation); //Database.getTimetable(nextStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\t\n\t                                            // (сколько будем ехать до следующей остановки):\n\t                                            var goingOnTransportTime = tbl.findTimeAfter(momentWhenSitInTransport);\n\t\n\t                                            // Метка времени:\n\t                                            var onNextPointtotalTimeSeconds = momentWhenSitInTransport - momentWhenComingToStation + goingOnTransportTime + selectedPointTotalTimeSeconds;\n\t\n\t                                            if (this.findElement(nextStation).tryUpdate(onNextPointtotalTimeSeconds, selectedPoint, selectedPointStation, selectedRoute)) {\n\t                                                //console.log(\"upd...\");\n\t                                            }\n\t                                        } else if (table.type === TableType.periodic) {\n\t                                        throw new Error();\n\t                                    }\n\t                                }\n\t                        }\n\t                    }\n\t                }\n\t                selectedPointCoords = selectedPoint.coords;\n\t                // Нет смысла идти пешком \"транзитом\" через остановку:\n\t                if (selectedPointFromWhichRoute == null) continue;\n\t\n\t                // Попробуем пройти пешком до других \"вершин\":\n\t                for (var j = 0, m = this.collection.length, p = this.collection[0], distanceToSelectedPoint, goingTime, newTime; j < m; p = this.collection[++j]) {\n\t                    if (!p.isVisited && p !== selectedPoint) {\n\t                        // Блокируем попытку дойти пешком до указанной остановки:\n\t                        if (myIgnoringFragments != null && myIgnoringFragments.contains(p.stationCode, null, selectedPointStationHashcode)) continue;\n\t\n\t                        distanceToSelectedPoint = (0, _geoCoordsDistance2.default)(selectedPointCoords, p.coords);\n\t\n\t                        goingTime = getTimeForGoingTo(distanceToSelectedPoint, speed /*, true, sp*/);\n\t\n\t                        newTime = selectedPointTotalTimeSeconds + goingTime + reservedTime;\n\t                        /*if (p != myFinishPoint)*/ // newTime += reservedTime;\n\t\n\t                        if (p.tryUpdate(newTime, selectedPoint, selectedPointStation, null)) {\n\t                            //console.log(\"upd...\");\n\t                        }\n\t                    }\n\t                }if (myIgnoringFragments != null && myIgnoringFragments.contains(null, null, selectedPointStationHashcode)) continue;\n\t\n\t                var tryingNewTime = selectedPointTotalTimeSeconds + getTimeForGoingTo((0, _geoCoordsDistance2.default)(selectedPointCoords, this.finalPoint.coords), speed);\n\t                if (this.finalPoint.tryUpdate(tryingNewTime, selectedPoint, selectedPointStation, null)) {\n\t                    //console.log(\"upd: \" + selectedPointStation.hashcode);\n\t                }\n\t            }\n\t\n\t            // Сокращаем время ходьбы пешком до минимума и избавляемся от \"бессмысленных\" пересадок, сохраняя общее время неизменным:\n\t            var currentPoint = this.finalPoint.previousPoint;\n\t            while (currentPoint !== this.startPoint) {\n\t                if (currentPoint == null) {\n\t                    console.log(\"err 1 in points.js\");\n\t                    console.log(this.finalPoint);\n\t                }\n\t                var r = currentPoint.fromWhichRoute;\n\t                if (r != null) {\n\t                    var previousPoint = currentPoint.previousPoint;\n\t                    //if(previousPoint == null) console.log(\"err 2 in points.js\");\n\t                    if (previousPoint !== this.startPoint && previousPoint.fromWhichRoute !== r) // Если на предыдущую остановку мы добрались другим транспортом, то:\n\t                        {\n\t                            var previousRouteStation = r.getPreviousStation(previousPoint.station);\n\t                            if (previousRouteStation != null) {\n\t                                var point = previousRouteStation.point;\n\t                                if (point != null && point.isVisited) {\n\t                                    var ttt = r.getTimetable(previousRouteStation);\n\t                                    if (ttt != null) {\n\t                                        //var ddd = time + previousPoint.totalTimeSeconds;\n\t                                        //var moment = r.getTimetable(currentPoint.station).findTimeAfter(ddd);\n\t                                        //var tmp_time = ttt.findTimeBefore(ddd + moment);\n\t\n\t                                        //var momentArriveOnCurrent = previousPoint.totalTimeSeconds + moment;\n\t                                        //var momentSittingOnPrevious = momentArriveOnCurrent + tmp_time;\n\t                                        /*bool bbb = point.fromWhichRoute != null && point.fromWhichRoute.getTimetable(point.station) != null && point.fromWhichRoute.getTimetable(point.station).findTimeAfter(time + point.totalTimeSeconds) <= previousPoint.totalTimeSeconds + moment + tmp_time;\r\n\t                                        if (bbb)\r\n\t                                        {\r\n\t                                            previousPoint.fromWhichRoute = r;\r\n\t                                            previousPoint.previousPoint = point;////!bbb && point.totalTimeSeconds <= momentSittingOnPrevious &&\r\n\t                                        }\r\n\t                                        else */\n\t                                        if ( /*point.totalGoingTime>=previousPoint.totalGoingTime || */point.totalTimeSeconds <= previousPoint.totalTimeSeconds /* && point.totalGoingTime <= previousPoint.totalGoingTime*/) {\n\t                                                previousPoint.fromWhichRoute = r;\n\t                                                previousPoint.previousPoint = point;\n\t                                            }\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                }\n\t                currentPoint = currentPoint.previousPoint;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return Points;\n\t}();\n\t\n\texports.default = Points;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar WayPoint = function WayPoint(time, station, route, coords) {\n\t    _classCallCheck(this, WayPoint);\n\t\n\t    this.time = time;\n\t    this.station = station == null ? null : { hashcode: station.hashcode, name: station.name, routes: null, Coords: { lat: station.coords.lat, lng: station.coords.lng } };\n\t    this.route = route == null ? null : { vehicles: [], gpsTrack: null, hashcode: route.hashcode, number: route.number, type: route.type, from: route.from, to: route.to, owner: \"\", stations: null, timetables: null, stationsJSON: null };\n\t    this.coords = coords;\n\t};\n\t\n\texports.default = WayPoint;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Initailize.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tfunction getNextStation(currentStation) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n\t            if (this.stations[j][t] === currentStation) {\n\t                if (t + 1 !== nn) return this.stations[j][t + 1];else return null;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction getPreviousStation(currentStation) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n\t            if (this.stations[j][t] === currentStation) {\n\t                if (t !== nn) return this.stations[j][t - 1];else return null;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction getTimetable(station) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var i = 0, n = this.stations[j].length; i < n; i++) {\n\t            if (this.stations[j][i] === station) {\n\t                return this.timetables[j][i];\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction findTimeAfter(time) {\n\t    var dateTmp = new Date();\n\t    dateTmp.setMinutes(0);\n\t    dateTmp.setHours(0);\n\t    dateTmp.setSeconds(time);\n\t    var day = dateTmp.getDay();\n\t    //foreach (Table t in table)\n\t    for (var kkk = 0, mnkk = this.table.length, t = this.table[0]; kkk < mnkk; t = this.table[++kkk]) {\n\t        if (t.days.includes(day)) {\n\t\n\t            //foreach (SimpleTime st in t.times)\n\t            for (var iik = 0, mnii = t.times.length, st = t.times[0], stTime; iik < mnii; st = t.times[++iik]) {\n\t                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n\t                //\n\t                stTime = st.hour * 3600 + st.minute * 60;\n\t                if (stTime >= time /*.Second + time.Minute * 60 + time.Hour * 3600*/ /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n\t                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n\t                        return stTime - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/;\n\t                    }\n\t            }\n\t            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/ + 86400;\n\t            break;\n\t        }\n\t    }\n\t    return 2160000000;\n\t    //throw new Exception();\n\t}\n\tfunction findTimeBefore(time) {\n\t    var dateTmp = new Date();\n\t    dateTmp.setMinutes(0);\n\t    dateTmp.setHours(0);\n\t    dateTmp.setSeconds(time);\n\t    var day = dateTmp.getDay();\n\t    for (var kkk = 0, mnkk = this.table.length, t = this.table[0], ok = false, st; kkk < mnkk; t = this.table[++kkk]) {\n\t        if (t.days.includes(day)) {\n\t            ok = false;\n\t            st = null;\n\t            for (var iik = 0, mnii = t.times.length, stt = t.times[0]; iik < mnii; stt = t.times[++iik]) {\n\t                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n\t                //\n\t                if (stt.hour * 3600 + stt.minute * 60 <= time /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n\t                        ok = true;\n\t                        st = stt;\n\t                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n\t                    } else break;\n\t            }\n\t            if (ok) return st.hour * 3600 + st.minute * 60 - time;\n\t            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time - 86400;\n\t            break;\n\t        }\n\t    }\n\t    return 0; //TimeSpan.FromDays(0/*-25000*/);\n\t    //throw new Exception();\n\t}\n\t\n\tfunction initialize(allStations, allRoutes, allTimetables) {\n\t    //alert(allStations.length);\n\t    //alert(allRoutes.length);\n\t    //alert(allTimetables.length);\n\t\n\t    console.log(\"Start initializing...\");\n\t    var startInitializingMoment = Date.now();\n\t\n\t    var tmpUsedStations = [];\n\t\n\t    function bindRoutesStationsTimetables(station, tmpArr, tabArr, rr) {\n\t        if (station.routes == null) station.routes = [];\n\t        //console.log(station.routes);//!!!\n\t        if (!station.routes.includes(rr)) station.routes.push(rr);\n\t        tmpArr.push(station);\n\t\n\t        var tmp = allTimetables.find(function (element, index, array) {\n\t            return element.stationCode === station.hashcode && element.routeCode === rr.hashcode;\n\t        });\n\t        var tmpTab = tmp == null ? null : tmp;\n\t\n\t        tabArr.push(tmpTab);\n\t    }\n\t\n\t    // Удаляем станции, через которые не идет ни один маршрут\n\t    var newAllStations = [];\n\t    for (var i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[++i]) {\n\t        if (currentStation.routesCodes != null && currentStation.routesCodes.length !== 0) {\n\t            newAllStations.push(currentStation);\n\t        }\n\t    }\n\t    allStations = newAllStations;\n\t\n\t    for (var _i = 0, _n = allRoutes.length, rr = allRoutes[0]; _i < _n; rr = allRoutes[++_i]) {\n\t\n\t        rr.getNextStation = getNextStation;\n\t        rr.getPreviousStation = getPreviousStation;\n\t        rr.getTimetable = getTimetable;\n\t\n\t        if (rr.stationsCodes == null || rr.stationsCodes.length === 0) {\n\t            continue;\n\t        }\n\t\n\t        try {\n\t            //if (rr.stationsCodes[rr.stationsCodes.Length - 1] != ']') continue;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\t            rr.stations = [[], []];\n\t            rr.timetables = [[], []];\n\t\n\t            for (var index = 0, tmpArr = [], tabArr = []; index <= 1; index++) {\n\t                var rr_stationsCodes = rr.stationsCodes;\n\t                if (rr_stationsCodes[index] == null || rr_stationsCodes[index].length === 0) continue;\n\t                for (var j = 0, m = rr_stationsCodes[index].length, stationCode = rr_stationsCodes[index][0]; j < m; stationCode = rr_stationsCodes[index][++j]) {\n\t                    var tmpUsed = false;\n\t                    for (var k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\n\t                        if (station != null && station.hashcode === stationCode) {\n\t                            bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\n\t                            tmpUsed = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (!tmpUsed) {\n\t                        for (var _k = 0, _mn = allStations.length, _station = allStations[0]; _k < _mn; _station = allStations[++_k]) {\n\t                            if (_station != null && _station.hashcode === stationCode) {\n\t                                bindRoutesStationsTimetables(_station, tmpArr, tabArr, rr);\n\t                                if (!tmpUsedStations.includes(_station)) tmpUsedStations.push(_station);\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                rr.stations[index] = tmpArr;\n\t                rr.timetables[index] = tabArr;\n\t            }\n\t        } catch (ex) {\n\t            console.log(ex /*.message*/);\n\t            continue;\n\t        }\n\t    }\n\t\n\t    console.log(\"Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t\n\t    for (var _i2 = 0, _n2 = allTimetables.length, timetable = allTimetables[0]; _i2 < _n2; timetable = allTimetables[++_i2]) {\n\t        timetable.findTimeAfter = findTimeAfter;\n\t        timetable.findTimeBefore = findTimeBefore;\n\t    }\n\t\n\t    //...\n\t    /*\r\n\t    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n\t        if (currentStation.routes == undefined || currentStation.routes == null || currentStation.routes.length == 0) {\r\n\t            allStations.splice(i, 1);\r\n\t            n = allStations.length;\r\n\t        }\r\n\t        else i++;\r\n\t    }\r\n\t    */\n\t\n\t    console.log(\"Initialized. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t    //console.log(\"\\n\\n\" + JSON.stringify(allTimetables[0]) + \"\\n\\n\");\n\t\n\t\n\t    //for (let t = 0; t < 1000; t++) var ttt = GetStationsAround(allStations[0].coords, 30000).length;\n\t    //console.log(\"test. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t\n\t\n\t    //global.initialized = true;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End initailize.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\texports.default = initialize;\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// sw.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 974f0a1e5fc014b4e3a3","'use strict';\n\nvar _dataProvider = require('./dataProvider');\n\nvar _dataProvider2 = _interopRequireDefault(_dataProvider);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _optimalRoutesCollection = require('public-transport-find-optimal-ways/lib/optimalRoutesCollection');\n\nvar _optimalRoutesCollection2 = _interopRequireDefault(_optimalRoutesCollection);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//import AppClient from './client';\n//let s = '123hello123';\nconsole.log('Hello from SW...');\n\nvar APP_CACHE_NAME = 'mosm-app-v1';\nvar TILE_CACHE_NAME = 'mosm-tiles-v1';\n\nvar urlsToCache = ['/', '/favicon.ico', '/static/js/bundle.js', '/static/css/style.css'];\n\nself.addEventListener('install', function (event) {\n  // Perform install steps\n  var cachePromise = caches.open(APP_CACHE_NAME).then(function (cache) {\n    console.log('install: opened cache');\n    return cache.addAll(urlsToCache);\n  }).then(function () {\n    console.log('install: added all urls to cache');\n  });\n\n  event.waitUntil(cachePromise);\n  //event.waitUntil(self.skipWaiting()); // Activate worker immediately\n});\n\nself.addEventListener('activate', function (event) {\n  _dataProvider2.default.loadDataAndInitialize();\n\n  //event.waitUntil(self.clients.claim()); // Become available to all pages\n  //console.log('!!!!!!!!!activate');\n\n  /**/\n});\n/*\r\nvar test = 0;\r\nsetInterval(function() {\r\n  test++\r\n}, 1000)\r\n*/\n//var ok = true;\n\nvar clients = [];\n\nself.addEventListener('message', function (event) {\n  var sender = event.source;\n  //console.log(event.data);\n  if (event.data === 'no-kill-sw') {\n    //console.log('SW: client call no-kill-sw.')\n    if (clients.includes(sender.id)) {\n      return;\n    } else {\n      clients.push(sender.id);\n      sender.postMessage('no-kill-sw-accepted');\n      setInterval(function () {\n        sender.postMessage(\"no-kill-sw-accepted\");\n      }, _config2.default.clientVsSwNoKillingMessageInterval);\n    }\n  } else if (event.data.requestType === 'optimalWay') {\n    console.log('SW: request for optimalWay.');\n\n    _dataProvider2.default.loadDataAndInitialize();\n\n    var params = event.data.params;\n    var rejected, resolved;\n    try {\n      var res = new _optimalRoutesCollection2.default(_dataProvider2.default.getAllStations(), params.startOptimalRoutePoint, params.finalOptimalRoutePoint, params.startTime, params.transportTypes, params.goingSpeed, params.dopTimeMinutes);\n      //console.log('res = ' + res);\n      resolved = res.getOptimalWays();\n      //console.log('resolved = ' + resolved);\n    } catch (e) {\n      console.log(e);\n      rejected = e;\n    } finally {\n      sender.postMessage({\n        requestType: 'optimalWayResult',\n        result: resolved\n      });\n    }\n  }\n  /*if(ok) {\r\n    //ok = false;\r\n    setInterval(function() {\r\n      sender.postMessage({\r\n        message: test\r\n      });\r\n    }, 1000)\r\n    //if (event.waitUntil) {\r\n    //  event.waitUntil(promise);\r\n    //}\r\n  }*/\n});\n\nself.addEventListener('fetch', function (event) {\n  var url = event.request.url;\n\n  event.respondWith(caches.match(event.request).then(function (response) {\n    // Cache hit - return response\n    if (response) {\n      return response;\n    }\n    caches.open(TILE_CACHE_NAME).then(function (cache) {\n      return cache.add(url);\n    });\n\n    return fetch(event.request);\n  }));\n});\n\n/*self.addEventListener('fetch', function(event) {\r\n  event.respondWith(\r\n    fetch(event.request).catch(function() {\r\n      return caches.match(event.request);\r\n    })\r\n  );\r\n});*/\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-client/lib/sw.js\n// module id = 0\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = distance;\nfunction distance(a, b) {\n    var earthRadius = 6372795;\n    var pi180 = 0.017453; // Math.PI / 180\n\n    // перевести координаты в радианы\n    var lat1 = a.lat * pi180;\n    var lat2 = b.lat * pi180;\n    var long1 = a.lng * pi180;\n    var long2 = b.lng * pi180;\n\n    //const pi2 = 1.5707963;\n    /*var zz = 1, yy = 1;\r\n    function taylorSin(x) {\r\n        yy = x * x;\r\n        zz = x;\r\n        return zz - (zz *= yy) / 6 + (zz *= yy) / 120;\r\n    }\r\n    function taylorCos(x) {\r\n        yy = x * x;\r\n        zz = yy;\r\n        return 1 - (yy) / 2 + (zz *= yy) / 24;\r\n    }*/\n    /*function taylorArcCos(x) {\r\n        yy = x * x;\r\n        zz = x;\r\n        return pi2 - zz - (zz *= yy)/6 - 3*(zz *= yy)/40;\r\n    }*/\n    /*function taylorAtan(x) {\r\n        yy = x * x;\r\n        zz = x;\r\n        return zz - (zz *= yy) / 3 + (zz *= yy) / 5 - (zz *= yy) / 7 + (zz *= yy) / 9 - (zz *= yy) / 20;\r\n    }*/\n    /*\r\n    // косинусы и синусы широт и разницы долгот\r\n    var cl1 = taylorCos(lat1);\r\n    var cl2 = taylorCos(lat2);\r\n    var sl1 = taylorSin(lat1);\r\n    var sl2 = taylorSin(lat2);\r\n    var delta = long2 - long1;\r\n    var cdelta = taylorCos(delta);\r\n    var sdelta = taylorSin(delta);\r\n      // вычисления длины большого круга\r\n    var tmp = cl2 * cdelta;\r\n    var y = Math.sqrt(cl2 * cl2 * sdelta * sdelta + (cl1 * sl2 - sl1 * tmp) * (cl1 * sl2 - sl1 * tmp));\r\n    var x = sl1 * sl2 + cl1 * tmp;\r\n      //\r\n    var ad = Math.atan2(y, x);//taylorAtan(y/x);\r\n    var dist = Math.ceil(ad * earthRadius);//(int)Math.Round(ad * earthRadius, 0);\r\n      //console.log(dist + \" vs \" + Math.acos(Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2))*earthRadius);\r\n    //console.log((taylorSin(lat1)*taylorSin(lat2)+taylorCos(lat1)*taylorCos(lat2)*taylorCos(long1-long2)) + \" vs \" + (Math.sin(lat1)*Math.sin(lat2)+Math.cos(lat1)*Math.cos(lat2)*Math.cos(long1-long2)));\r\n      return dist;\r\n    */\n\n    return Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(long1 - long2)) * earthRadius;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/geo-coords-distance/lib/distance.js\n// module id = 1\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = {\n    apiPublicTransportServer: \"https://ptp-97126.app.xervo.io/\",\n    apiGetStationsUrl: \"https://publictransportproject.000webhostapp.com/new/json/stations.json\", //\"stations\"\n    apiGetRoutesUrl: \"https://publictransportproject.000webhostapp.com/new/json/routes.json\", //\"routes\"\n    apiGetTimetablesUrl: \"https://publictransportproject.000webhostapp.com/new/json/timetables.json\", //\"timetables\"\n\n    clientVsSwNoKillingMessageInterval: 30000\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-client/lib/config.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _loadDataOnly = function () {\n    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee() {\n        var response, _response, _response2;\n\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n                switch (_context.prev = _context.next) {\n                    case 0:\n                        _context.next = 2;\n                        return _jsonDataStorage2.default.getAllStations();\n\n                    case 2:\n                        allStationsJSON = _context.sent;\n                        _context.next = 5;\n                        return _jsonDataStorage2.default.getAllRoutes();\n\n                    case 5:\n                        allRoutesJSON = _context.sent;\n                        _context.next = 8;\n                        return _jsonDataStorage2.default.getAllTimetables();\n\n                    case 8:\n                        allTimetablesJSON = _context.sent;\n\n                        if (allStationsLoaded) {\n                            _context.next = 27;\n                            break;\n                        }\n\n                        if (!(allStationsJSON == null)) {\n                            _context.next = 24;\n                            break;\n                        }\n\n                        //localStorage[\"allStationsJSON\"] === undefined || localStorage[\"allStationsJSON\"] == null\n                        console.log(\"Downloading stations from server...\");\n\n                        _context.next = 14;\n                        return fetch(_config2.default.apiGetStationsUrl);\n\n                    case 14:\n                        response = _context.sent;\n                        _context.next = 17;\n                        return response.text();\n\n                    case 17:\n                        allStationsJSON = _context.sent;\n\n                        allStations = JSON.parse(allStationsJSON); //await response.json();\n\n                        if (allStations !== undefined && allStations != null) _jsonDataStorage2.default.pushAllStations(allStationsJSON); //localStorage[\"allStationsJSON\"] = allStationsJSON;\n                        allStationsLoaded = true;\n                        console.log(\"Stations loaded from server.\");\n                        _context.next = 27;\n                        break;\n\n                    case 24:\n                        allStations = JSON.parse(allStationsJSON); //localStorage[\"allStationsJSON\"]\n                        allStationsLoaded = true;\n                        console.log(\"Stations loaded from localStorage.\");\n\n                    case 27:\n                        if (allRoutesLoaded) {\n                            _context.next = 45;\n                            break;\n                        }\n\n                        if (!(allRoutesJSON == null)) {\n                            _context.next = 42;\n                            break;\n                        }\n\n                        //localStorage[\"allRoutesJSON\"] === undefined || localStorage[\"allRoutesJSON\"] == null\n                        console.log(\"Downloading routes from server...\");\n\n                        _context.next = 32;\n                        return fetch(_config2.default.apiGetRoutesUrl);\n\n                    case 32:\n                        _response = _context.sent;\n                        _context.next = 35;\n                        return _response.text();\n\n                    case 35:\n                        allRoutesJSON = _context.sent;\n\n                        allRoutes = JSON.parse(allRoutesJSON); //await response.json();\n\n                        if (allRoutes !== undefined && allRoutes != null) _jsonDataStorage2.default.pushAllRoutes(allRoutesJSON); //localStorage[\"allRoutesJSON\"] = allRoutesJSON;\n                        allRoutesLoaded = true;\n                        console.log(\"Routes loaded from server.\");\n                        _context.next = 45;\n                        break;\n\n                    case 42:\n                        allRoutes = JSON.parse(allRoutesJSON); //localStorage[\"allRoutesJSON\"]\n                        allRoutesLoaded = true;\n                        console.log(\"Routes loaded from localStorage.\");\n\n                    case 45:\n                        if (allTimetablesLoaded) {\n                            _context.next = 63;\n                            break;\n                        }\n\n                        if (!(allTimetablesJSON == null)) {\n                            _context.next = 60;\n                            break;\n                        }\n\n                        //localStorage[\"allTimetablesJSON\"] === undefined || localStorage[\"allTimetablesJSON\"] == null\n                        console.log(\"Downloading timetables from server...\");\n\n                        _context.next = 50;\n                        return fetch(_config2.default.apiGetTimetablesUrl);\n\n                    case 50:\n                        _response2 = _context.sent;\n                        _context.next = 53;\n                        return _response2.text();\n\n                    case 53:\n                        allTimetablesJSON = _context.sent;\n\n                        allTimetables = JSON.parse(allTimetablesJSON); //await response.json();\n\n                        if (allTimetables !== undefined && allTimetables != null) _jsonDataStorage2.default.pushAllTimetables(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"] = allTimetablesJSON;\n                        allTimetablesLoaded = true;\n                        console.log(\"Timetables loaded from server.\");\n                        _context.next = 63;\n                        break;\n\n                    case 60:\n                        allTimetables = JSON.parse(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"]\n                        allTimetablesLoaded = true;\n                        console.log(\"Timetables loaded from localStorage.\");\n\n                    case 63:\n                    case 'end':\n                        return _context.stop();\n                }\n            }\n        }, _callee, this);\n    }));\n\n    return function _loadDataOnly() {\n        return _ref.apply(this, arguments);\n    };\n}();\n\nvar loadData = function () {\n    var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n                switch (_context2.prev = _context2.next) {\n                    case 0:\n                        if (loadingStarted) {\n                            _context2.next = 5;\n                            break;\n                        }\n\n                        loadingStarted = true;\n\n                        _context2.next = 4;\n                        return _loadDataOnly();\n\n                    case 4:\n\n                        if (allStationsLoaded && allRoutesLoaded && allTimetablesLoaded) {\n                            (0, _publicTransportInitializeData2.default)(allStations, allRoutes, allTimetables);\n                        }\n\n                    case 5:\n                    case 'end':\n                        return _context2.stop();\n                }\n            }\n        }, _callee2, this);\n    }));\n\n    return function loadData() {\n        return _ref2.apply(this, arguments);\n    };\n}();\n\n//loadData();\n\nvar _jsonDataStorage = require('./jsonDataStorage');\n\nvar _jsonDataStorage2 = _interopRequireDefault(_jsonDataStorage);\n\nvar _publicTransportInitializeData = require('public-transport-initialize-data');\n\nvar _publicTransportInitializeData2 = _interopRequireDefault(_publicTransportInitializeData);\n\nvar _config = require('./config');\n\nvar _config2 = _interopRequireDefault(_config);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Load data.\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvar allStations = null;\nvar allRoutes = null;\nvar allTimetables = null;\n\n//var updatingFromServerInterval = 5000;\n\nvar loadingStarted = false;\n\nvar allStationsLoaded = false,\n    allRoutesLoaded = false,\n    allTimetablesLoaded = false;\nvar allStationsJSON = null,\n    allRoutesJSON = null,\n    allTimetablesJSON = null;\n\nvar DataProvider = function () {\n    function DataProvider() {\n        _classCallCheck(this, DataProvider);\n    }\n\n    _createClass(DataProvider, null, [{\n        key: 'getAllStations',\n        value: function getAllStations() {\n            return allStations;\n        }\n    }, {\n        key: 'getAllRoutes',\n        value: function getAllRoutes() {\n            return allRoutes;\n        }\n    }, {\n        key: 'getAllTimetables',\n        value: function getAllTimetables() {\n            return allTimetables;\n        }\n    }, {\n        key: 'getAllStationsJSON',\n        value: function getAllStationsJSON() {\n            return allStationsJSON;\n        }\n    }, {\n        key: 'getAllRoutesJSON',\n        value: function getAllRoutesJSON() {\n            return allRoutesJSON;\n        }\n    }, {\n        key: 'getAllTimetablesJSON',\n        value: function getAllTimetablesJSON() {\n            return allTimetablesJSON;\n        }\n    }, {\n        key: 'loadDataAndInitialize',\n        value: function () {\n            var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {\n                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                        switch (_context3.prev = _context3.next) {\n                            case 0:\n                                _context3.next = 2;\n                                return loadData();\n\n                            case 2:\n                            case 'end':\n                                return _context3.stop();\n                        }\n                    }\n                }, _callee3, this);\n            }));\n\n            function loadDataAndInitialize() {\n                return _ref3.apply(this, arguments);\n            }\n\n            return loadDataAndInitialize;\n        }()\n    }, {\n        key: 'loadDataOnly',\n        value: function () {\n            var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {\n                return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                    while (1) {\n                        switch (_context4.prev = _context4.next) {\n                            case 0:\n                                _context4.next = 2;\n                                return _loadDataOnly();\n\n                            case 2:\n                            case 'end':\n                                return _context4.stop();\n                        }\n                    }\n                }, _callee4, this);\n            }));\n\n            function loadDataOnly() {\n                return _ref4.apply(this, arguments);\n            }\n\n            return loadDataOnly;\n        }()\n    }]);\n\n    return DataProvider;\n}();\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// End load data.\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nexports.default = DataProvider;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-client/lib/dataProvider.js\n// module id = 3\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar getJsonDataStorageConnection = function () {\n    var _ref = _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {\n        var promise;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n                switch (_context2.prev = _context2.next) {\n                    case 0:\n                        promise = new Promise(function (resolve, reject) {\n\n                            var request = indexedDB.open(dbName, 1);\n                            request.onerror = function (event) {\n                                reject(event.target.error);\n                            };\n                            request.onsuccess = function (event) {\n                                resolve(event.target.result);\n                            };\n                            request.onupgradeneeded = function () {\n                                var _ref2 = _asyncToGenerator(regeneratorRuntime.mark(function _callee(event) {\n                                    var db, objectStore, result;\n                                    return regeneratorRuntime.wrap(function _callee$(_context) {\n                                        while (1) {\n                                            switch (_context.prev = _context.next) {\n                                                case 0:\n                                                    db = event.target.result;\n                                                    objectStore = db.createObjectStore(storeName, { keyPath: \"name\" });\n\n                                                    objectStore.createIndex(\"json\", \"json\", { unique: false });\n\n                                                    _context.next = 5;\n                                                    return getJsonDataStorageConnection();\n\n                                                case 5:\n                                                    result = _context.sent;\n\n                                                    resolve(result);\n\n                                                case 7:\n                                                case \"end\":\n                                                    return _context.stop();\n                                            }\n                                        }\n                                    }, _callee, this);\n                                }));\n\n                                return function (_x) {\n                                    return _ref2.apply(this, arguments);\n                                };\n                            }();\n                        });\n                        _context2.next = 3;\n                        return promise;\n\n                    case 3:\n                        return _context2.abrupt(\"return\", _context2.sent);\n\n                    case 4:\n                    case \"end\":\n                        return _context2.stop();\n                }\n            }\n        }, _callee2, this);\n    }));\n\n    return function getJsonDataStorageConnection() {\n        return _ref.apply(this, arguments);\n    };\n}();\n\nvar tryPush = function () {\n    var _ref3 = _asyncToGenerator(regeneratorRuntime.mark(function _callee4(obj) {\n        var promise;\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n            while (1) {\n                switch (_context4.prev = _context4.next) {\n                    case 0:\n                        promise = new Promise(function () {\n                            var _ref4 = _asyncToGenerator(regeneratorRuntime.mark(function _callee3(resolve, reject) {\n                                var db, transaction, objectStore, request;\n                                return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                                    while (1) {\n                                        switch (_context3.prev = _context3.next) {\n                                            case 0:\n                                                _context3.next = 2;\n                                                return getJsonDataStorageConnection();\n\n                                            case 2:\n                                                db = _context3.sent;\n\n                                                //console.log(db);\n                                                transaction = db.transaction([storeName], \"readwrite\");\n                                                objectStore = transaction.objectStore(storeName);\n                                                request = objectStore.add({\n                                                    name: obj.name,\n                                                    json: obj.json\n                                                });\n\n                                                request.onerror = function (event) {\n                                                    reject(event.target.error);\n                                                };\n                                                request.onsuccess = function (event) {\n                                                    resolve(event.target.result);\n                                                };\n\n                                            case 8:\n                                            case \"end\":\n                                                return _context3.stop();\n                                        }\n                                    }\n                                }, _callee3, this);\n                            }));\n\n                            return function (_x3, _x4) {\n                                return _ref4.apply(this, arguments);\n                            };\n                        }());\n                        _context4.next = 3;\n                        return promise;\n\n                    case 3:\n                        return _context4.abrupt(\"return\", _context4.sent);\n\n                    case 4:\n                    case \"end\":\n                        return _context4.stop();\n                }\n            }\n        }, _callee4, this);\n    }));\n\n    return function tryPush(_x2) {\n        return _ref3.apply(this, arguments);\n    };\n}();\n\nvar getItem = function () {\n    var _ref5 = _asyncToGenerator(regeneratorRuntime.mark(function _callee6(name) {\n        var promise;\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n            while (1) {\n                switch (_context6.prev = _context6.next) {\n                    case 0:\n                        promise = new Promise(function () {\n                            var _ref6 = _asyncToGenerator(regeneratorRuntime.mark(function _callee5(resolve, reject) {\n                                var db, transaction, objectStore, request;\n                                return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                                    while (1) {\n                                        switch (_context5.prev = _context5.next) {\n                                            case 0:\n                                                _context5.next = 2;\n                                                return getJsonDataStorageConnection();\n\n                                            case 2:\n                                                db = _context5.sent;\n                                                transaction = db.transaction([storeName]);\n                                                objectStore = transaction.objectStore(storeName);\n                                                request = objectStore.get(name);\n\n                                                request.onsuccess = function (event) {\n                                                    if (event.target.result !== undefined) {\n                                                        resolve(event.target.result.json);\n                                                    } else {\n                                                        //resolve(null);\n                                                        reject(event.target.error);\n                                                    }\n                                                };\n                                                request.onerror = function (event) {\n                                                    reject(event.target.error);\n                                                };\n\n                                            case 8:\n                                            case \"end\":\n                                                return _context5.stop();\n                                        }\n                                    }\n                                }, _callee5, this);\n                            }));\n\n                            return function (_x6, _x7) {\n                                return _ref6.apply(this, arguments);\n                            };\n                        }());\n                        _context6.next = 3;\n                        return promise;\n\n                    case 3:\n                        return _context6.abrupt(\"return\", _context6.sent);\n\n                    case 4:\n                    case \"end\":\n                        return _context6.stop();\n                }\n            }\n        }, _callee6, this);\n    }));\n\n    return function getItem(_x5) {\n        return _ref5.apply(this, arguments);\n    };\n}();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\n//import ApiConfig from './config';\n\nvar dbName = \"public_transport2\";\nvar storeName = \"json_data\";\n\nvar JsonDataStorage = function () {\n    function JsonDataStorage() {\n        _classCallCheck(this, JsonDataStorage);\n    }\n\n    _createClass(JsonDataStorage, null, [{\n        key: \"getAllStations\",\n        value: function () {\n            var _ref7 = _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {\n                return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                    while (1) {\n                        switch (_context7.prev = _context7.next) {\n                            case 0:\n                                _context7.prev = 0;\n                                _context7.next = 3;\n                                return getItem('allStations');\n\n                            case 3:\n                                return _context7.abrupt(\"return\", _context7.sent);\n\n                            case 6:\n                                _context7.prev = 6;\n                                _context7.t0 = _context7[\"catch\"](0);\n                                return _context7.abrupt(\"return\", null);\n\n                            case 9:\n                            case \"end\":\n                                return _context7.stop();\n                        }\n                    }\n                }, _callee7, this, [[0, 6]]);\n            }));\n\n            function getAllStations() {\n                return _ref7.apply(this, arguments);\n            }\n\n            return getAllStations;\n        }()\n    }, {\n        key: \"getAllRoutes\",\n        value: function () {\n            var _ref8 = _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {\n                return regeneratorRuntime.wrap(function _callee8$(_context8) {\n                    while (1) {\n                        switch (_context8.prev = _context8.next) {\n                            case 0:\n                                _context8.prev = 0;\n                                _context8.next = 3;\n                                return getItem('allRoutes');\n\n                            case 3:\n                                return _context8.abrupt(\"return\", _context8.sent);\n\n                            case 6:\n                                _context8.prev = 6;\n                                _context8.t0 = _context8[\"catch\"](0);\n                                return _context8.abrupt(\"return\", null);\n\n                            case 9:\n                            case \"end\":\n                                return _context8.stop();\n                        }\n                    }\n                }, _callee8, this, [[0, 6]]);\n            }));\n\n            function getAllRoutes() {\n                return _ref8.apply(this, arguments);\n            }\n\n            return getAllRoutes;\n        }()\n    }, {\n        key: \"getAllTimetables\",\n        value: function () {\n            var _ref9 = _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {\n                return regeneratorRuntime.wrap(function _callee9$(_context9) {\n                    while (1) {\n                        switch (_context9.prev = _context9.next) {\n                            case 0:\n                                _context9.prev = 0;\n                                _context9.next = 3;\n                                return getItem('allTimetables');\n\n                            case 3:\n                                return _context9.abrupt(\"return\", _context9.sent);\n\n                            case 6:\n                                _context9.prev = 6;\n                                _context9.t0 = _context9[\"catch\"](0);\n                                return _context9.abrupt(\"return\", null);\n\n                            case 9:\n                            case \"end\":\n                                return _context9.stop();\n                        }\n                    }\n                }, _callee9, this, [[0, 6]]);\n            }));\n\n            function getAllTimetables() {\n                return _ref9.apply(this, arguments);\n            }\n\n            return getAllTimetables;\n        }()\n    }, {\n        key: \"pushAllStations\",\n        value: function () {\n            var _ref10 = _asyncToGenerator(regeneratorRuntime.mark(function _callee10(allStationsJson) {\n                return regeneratorRuntime.wrap(function _callee10$(_context10) {\n                    while (1) {\n                        switch (_context10.prev = _context10.next) {\n                            case 0:\n                                _context10.prev = 0;\n                                _context10.next = 3;\n                                return tryPush({\n                                    name: 'allStations',\n                                    json: allStationsJson\n                                });\n\n                            case 3:\n                                return _context10.abrupt(\"return\", _context10.sent);\n\n                            case 6:\n                                _context10.prev = 6;\n                                _context10.t0 = _context10[\"catch\"](0);\n                                return _context10.abrupt(\"return\", null);\n\n                            case 9:\n                            case \"end\":\n                                return _context10.stop();\n                        }\n                    }\n                }, _callee10, this, [[0, 6]]);\n            }));\n\n            function pushAllStations(_x8) {\n                return _ref10.apply(this, arguments);\n            }\n\n            return pushAllStations;\n        }()\n    }, {\n        key: \"pushAllRoutes\",\n        value: function () {\n            var _ref11 = _asyncToGenerator(regeneratorRuntime.mark(function _callee11(allRoutesJson) {\n                return regeneratorRuntime.wrap(function _callee11$(_context11) {\n                    while (1) {\n                        switch (_context11.prev = _context11.next) {\n                            case 0:\n                                _context11.prev = 0;\n                                _context11.next = 3;\n                                return tryPush({\n                                    name: 'allRoutes',\n                                    json: allRoutesJson\n                                });\n\n                            case 3:\n                                return _context11.abrupt(\"return\", _context11.sent);\n\n                            case 6:\n                                _context11.prev = 6;\n                                _context11.t0 = _context11[\"catch\"](0);\n                                return _context11.abrupt(\"return\", null);\n\n                            case 9:\n                            case \"end\":\n                                return _context11.stop();\n                        }\n                    }\n                }, _callee11, this, [[0, 6]]);\n            }));\n\n            function pushAllRoutes(_x9) {\n                return _ref11.apply(this, arguments);\n            }\n\n            return pushAllRoutes;\n        }()\n    }, {\n        key: \"pushAllTimetables\",\n        value: function () {\n            var _ref12 = _asyncToGenerator(regeneratorRuntime.mark(function _callee12(allTimetablesJson) {\n                return regeneratorRuntime.wrap(function _callee12$(_context12) {\n                    while (1) {\n                        switch (_context12.prev = _context12.next) {\n                            case 0:\n                                _context12.prev = 0;\n                                _context12.next = 3;\n                                return tryPush({\n                                    name: 'allTimetables',\n                                    json: allTimetablesJson\n                                });\n\n                            case 3:\n                                return _context12.abrupt(\"return\", _context12.sent);\n\n                            case 6:\n                                _context12.prev = 6;\n                                _context12.t0 = _context12[\"catch\"](0);\n                                return _context12.abrupt(\"return\", null);\n\n                            case 9:\n                            case \"end\":\n                                return _context12.stop();\n                        }\n                    }\n                }, _callee12, this, [[0, 6]]);\n            }));\n\n            function pushAllTimetables(_x10) {\n                return _ref12.apply(this, arguments);\n            }\n\n            return pushAllTimetables;\n        }()\n    }]);\n\n    return JsonDataStorage;\n}();\n\nexports.default = JsonDataStorage;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-client/lib/jsonDataStorage.js\n// module id = 4\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//import Points from './points';\n//import IgnoringFragments from './ignoringFragments';\n\nvar OptimalRoute = function () {\n        function OptimalRoute(myPoints, stationsList, /*nowPos, needPos,*/time, types, goingSpeed, dopTimeMinutes, ignoringRoutesAdd, ignoringList) {\n                _classCallCheck(this, OptimalRoute);\n\n                if (ignoringRoutesAdd != null) this.ignoringRoutes = ignoringRoutesAdd;else this.ignoringRoutes = [];\n\n                this.points = [];\n\n                //this.needPos = needPos;\n                //this.nowPos = nowPos;\n                this.goingSpeed = goingSpeed;\n                this.time = time;\n                var reservedTimeSeconds = 60 * dopTimeMinutes;\n\n                this.types = types;\n\n                this.myIgnoringFragments = null;\n                //if (ignoringList != null) this.myIgnoringFragments = new IgnoringFragments(ignoringList);\n                //else this.myIgnoringFragments = new IgnoringFragments();\n\n                //var myPoints = new Points(nowPos, needPos);\n\n                myPoints.fillStartData(stationsList, goingSpeed, reservedTimeSeconds, this.myIgnoringFragments);\n\n                // Находим кратчайшие пути до всех вершин:\n                myPoints.countShortWay(this.ignoringRoutes, this.myIgnoringFragments, time, types, goingSpeed, reservedTimeSeconds);\n\n                var tmpP = myPoints.finalPoint;\n                this.points.push(tmpP.toString()); ////\n                while (tmpP.previousPoint != null) {\n                        tmpP = tmpP.previousPoint; //\n                        this.points.push(tmpP.toString());\n                        if (tmpP.previousPoint == null && tmpP.coords !== myPoints.startPoint.coords) throw new Error(\"Где-то удалилась часть маршрута...\");\n                }\n\n                this.totalTimeSeconds = myPoints.finalPoint.totalTimeSeconds;\n                this.totalGoingTime = myPoints.finalPoint.getTotalGoingTime();\n                this.totalTransportChangingCount = myPoints.finalPoint.getTotalTransportChangingCount();\n\n                this.myPoints = myPoints;\n\n                this.isVisited = false;\n        }\n\n        _createClass(OptimalRoute, [{\n                key: \"setVisited\",\n                value: function setVisited() {\n                        this.isVisited = true;\n                }\n        }]);\n\n        return OptimalRoute;\n}();\n\nexports.default = OptimalRoute;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-find-optimal-ways/lib/optimalRoute.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _optimalRoute = require('./optimalRoute');\n\nvar _optimalRoute2 = _interopRequireDefault(_optimalRoute);\n\nvar _optimalWay = require('./optimalWay');\n\nvar _optimalWay2 = _interopRequireDefault(_optimalWay);\n\nvar _points = require('./points');\n\nvar _points2 = _interopRequireDefault(_points);\n\nvar _geoCoordsDistance = require('geo-coords-distance');\n\nvar _geoCoordsDistance2 = _interopRequireDefault(_geoCoordsDistance);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //import IgnoringFragments from './ignoringFragments';\n\n\nvar heuristicBestTransportSpeed = 40;\n\nfunction getStationsAround(allStations, nowPos, needPos, goingSpeed, heuristicBestTransportSpeed) {\n    var result = [];\n    var fullDistance = (0, _geoCoordsDistance2.default)(nowPos, needPos);\n    for (var i = 0, n = allStations.length, s = allStations[0]; i < n; s = allStations[++i]) {\n        if (s != null && fullDistance > (0, _geoCoordsDistance2.default)(nowPos, s.coords) + goingSpeed * (0, _geoCoordsDistance2.default)(s.coords, needPos) / heuristicBestTransportSpeed) {\n            result.push(s);\n        }\n    }\n    return result;\n}\n\nvar OptimalRoutesCollection = function (_Array) {\n    _inherits(OptimalRoutesCollection, _Array);\n\n    /*getOptimalWays() {\r\n        var result = [];\r\n        for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n            result.push(new OptimalWay(r));\r\n        }\r\n        return result;\r\n    }*/\n    /*selectOptimalRouteWithMinimalMark() {\r\n        var p = null;\r\n        for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n            if (!(t.isVisited)) {\r\n                p = t;\r\n                for (t = this[++i]; i < n; t = this[++i]) {\r\n                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                        p = t;\r\n                    }\r\n                }\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }*/\n    function OptimalRoutesCollection(allStations, nowPos, needPos, time, types, speed, dopTimeMinutes) {\n        _classCallCheck(this, OptimalRoutesCollection);\n\n        var _this = _possibleConstructorReturn(this, (OptimalRoutesCollection.__proto__ || Object.getPrototypeOf(OptimalRoutesCollection)).call(this));\n\n        _this.getOptimalWays = function () {\n            var result = [];\n            for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\n                result.push(new _optimalWay2.default(r));\n            }\n            return result;\n        };\n        _this.selectOptimalRouteWithMinimalMark = function () {\n            var p = null;\n            for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\n                if (!t.isVisited) {\n                    p = t;\n                    for (t = this[++i]; i < n; t = this[++i]) {\n                        if (!t.isVisited && t.totalTimeSeconds < p.totalTimeSeconds) {\n                            p = t;\n                        }\n                    }\n                    return p;\n                }\n            }\n            return null;\n        };\n\n        var myPoints = new _points2.default(nowPos, needPos);\n        // Получим \"начальный\" список станций:\n        var stationsList = getStationsAround(allStations, nowPos, needPos, speed, heuristicBestTransportSpeed);\n\n        _this.push(new _optimalRoute2.default(myPoints, stationsList, /*nowPos, needPos,*/time, types, speed, dopTimeMinutes));\n\n        var ignoringRoutes = [];\n\n        //var ignoringFragments = new IgnoringFragments();\n\n        for (var selectedOptimalRoute = _this[0]; selectedOptimalRoute != null; selectedOptimalRoute.setVisited(), selectedOptimalRoute = _this.selectOptimalRouteWithMinimalMark()) {\n            var ddd = 0.25;\n\n            ignoringRoutes = [];\n            // Проходим по всем ребрам выбранного пути и строим новые маршруты при удалении ребер:\n            for (var tmpP = selectedOptimalRoute.myPoints.finalPoint; tmpP.previousPoint != null; tmpP = tmpP.previousPoint) {\n                //if(tmpP == null) console.log(\"err in optimalRoutesCollection.js\");\n                if (tmpP.fromWhichRoute != null && !ignoringRoutes.includes(tmpP.fromWhichRoute)) ignoringRoutes.push(tmpP.fromWhichRoute);\n            }\n            for (var i = 0, n = ignoringRoutes.length, r = ignoringRoutes[0]; i < n; r = ignoringRoutes[++i]) {\n                if (selectedOptimalRoute.ignoringRoutes.includes(r)) continue;\n                var ignoringRoutesAdd = [];\n                ignoringRoutesAdd = ignoringRoutesAdd.concat(selectedOptimalRoute.ignoringRoutes);\n                ignoringRoutesAdd.push(r);\n                myPoints = new _points2.default(nowPos, needPos);\n                var tmpOptimalRoute = new _optimalRoute2.default(myPoints, stationsList, /*nowPos, needPos,*/time, types, speed, dopTimeMinutes, ignoringRoutesAdd);\n\n                if (tmpOptimalRoute.totalTimeSeconds <= _this[0].totalTimeSeconds / ddd) {\n                    var tmpJSON = JSON.stringify(tmpOptimalRoute.points);\n                    var ok = false;\n                    for (var j = 0, m = _this.length, opt = _this[0]; j < m; opt = _this[++j]) {\n                        if (JSON.stringify(opt.points) === tmpJSON) {\n                            ok = true;\n                            break;\n                        }\n                    }\n                    if (ok) continue;\n                    _this.push(tmpOptimalRoute);\n                }\n            }\n        }\n        return _this;\n    }\n\n    return OptimalRoutesCollection;\n}(Array);\n\nexports.default = OptimalRoutesCollection;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-find-optimal-ways/lib/optimalRoutesCollection.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _wayPoint = require('./wayPoint');\n\nvar _wayPoint2 = _interopRequireDefault(_wayPoint);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar OptimalWay = function OptimalWay(optimalRoute) {\n    _classCallCheck(this, OptimalWay);\n\n    this.totalTimeSeconds = optimalRoute.totalTimeSeconds;\n    this.totalGoingTimeSeconds = optimalRoute.totalGoingTime;\n    this.totalTransportChangingCount = optimalRoute.totalTransportChangingCount;\n    this.points = [];\n\n    for (var tmpP = optimalRoute.myPoints.finalPoint; tmpP != null; tmpP = tmpP.previousPoint) {\n        this.points.push(new _wayPoint2.default(tmpP.totalTimeSeconds, tmpP.station, tmpP.fromWhichRoute, tmpP.coords));\n    }\n    this.points.reverse();\n};\n\nexports.default = OptimalWay;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-find-optimal-ways/lib/optimalWay.js\n// module id = 7\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Point = function () {\n    function Point(totalTimeSeconds, station_or_crds, fromWhichStation, fromWhichRoute) {\n        _classCallCheck(this, Point);\n\n        if (station_or_crds.hashcode !== undefined) {\n            this.station = station_or_crds;\n            this.stationCode = station_or_crds.hashcode;\n            station_or_crds.point = this;\n            this.coords = station_or_crds.coords;\n        } else {\n            this.coords = station_or_crds;\n            this.station = null;\n            this.stationCode = null;\n        }\n        this.totalTimeSeconds = totalTimeSeconds;\n        this.fromWhichStation = fromWhichStation;\n        this.fromWhichRoute = fromWhichRoute;\n\n        this.isVisited = false;\n\n        this.previousPoint = null;\n    }\n\n    _createClass(Point, [{\n        key: \"tryUpdate\",\n        value: function tryUpdate(totalTimeSeconds, previousPoint, fromWhichStation, fromWhichRoute) {\n            if (totalTimeSeconds < this.totalTimeSeconds) {\n                this.fromWhichRoute = fromWhichRoute;\n                this.previousPoint = previousPoint;\n                this.totalTimeSeconds = totalTimeSeconds;\n                this.fromWhichStation = fromWhichStation;\n\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: \"setVisited\",\n        value: function setVisited() {\n            this.isVisited = true;\n        }\n    }, {\n        key: \"toString\",\n        value: function toString() {\n            var to, tr; //, from, p;\n            //if (this.fromWhichStation != null) from = this.fromWhichStation.name;\n            //else from = \"null\";\n            if (this.station != null) to = this.station.name;else to = \"null\";\n            if (this.fromWhichRoute != null) tr = this.fromWhichRoute.type + \" \" + this.fromWhichRoute.number + \" \" + this.fromWhichRoute.from + \" - \" + this.fromWhichRoute.to;else tr = \"пешком\";\n            //if (this.previousPoint != null) p = this.previousPoint.toString();\n            //else p = \"null\";\n            return (/*p+\" -->> */\"(\" + this.totalTimeSeconds + \") \" + to + \" (\" + tr + \")\"\n            ); // from \" + from + \" to\n        }\n    }, {\n        key: \"getTotalGoingTime\",\n        value: function getTotalGoingTime() {\n            var goingTime = 0;\n            var tmpP = this;\n            //this.points.Add(tmpP.ToString());\n            while (tmpP.previousPoint != null) {\n                if (tmpP.fromWhichRoute == null /*&& tmpP.fromWhichRoute.hashcode == null*/) goingTime += tmpP.totalTimeSeconds - tmpP.previousPoint.totalTimeSeconds;\n                tmpP = tmpP.previousPoint;\n            }\n            return goingTime;\n        }\n    }, {\n        key: \"getTotalTransportChangingCount\",\n        value: function getTotalTransportChangingCount() {\n            var result = 0;\n            var tmpP = this;\n            //this.points.Add(tmpP.ToString());\n            while (tmpP.previousPoint != null) {\n                if (tmpP.fromWhichRoute != null && tmpP.fromWhichRoute.hashcode != null && tmpP.fromWhichRoute !== tmpP.previousPoint.fromWhichRoute) result++;\n                tmpP = tmpP.previousPoint;\n            }\n            return result;\n        }\n    }]);\n\n    return Point;\n}();\n\nexports.default = Point;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-find-optimal-ways/lib/point.js\n// module id = 8\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _point = require('./point');\n\nvar _point2 = _interopRequireDefault(_point);\n\nvar _geoCoordsDistance = require('geo-coords-distance');\n\nvar _geoCoordsDistance2 = _interopRequireDefault(_geoCoordsDistance);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getTimeForGoingTo(distance, goingSpeed) {\n    return Math.floor(distance / (goingSpeed / 3.6));\n}\n\nvar TableType = { table: 1, periodic: 2 };\n\nvar Points = function () {\n    function Points(nowPos, needPos) {\n        _classCallCheck(this, Points);\n\n        this.collection = [];\n        this.startPoint = new _point2.default(0, nowPos, null, null);\n        this.finalPoint = new _point2.default(2160000000, needPos, null, null);\n        this.currentSelectedPoint = null;\n    }\n\n    _createClass(Points, [{\n        key: 'findElement',\n        value: function findElement(station_or_point) {\n            if (station_or_point.hashcode != null) {\n                if (station_or_point.point != null) return station_or_point.point;\n                var newCreatdPoint = new _point2.default(2160000000, station_or_point, null, null);\n                newCreatdPoint.heuristicTimeToFinalPoint = (0, _geoCoordsDistance2.default)(newCreatdPoint.coords, this.finalPoint.coords) / 5;\n                this.collection.push(newCreatdPoint);\n                return newCreatdPoint;\n            } else {\n                for (var i = 0, n = this.collection.length, p = this.collection[0]; i < n; p = this.collection[++i]) {\n                    if (p.coords === station_or_point.coords && p.stationCode === station_or_point.stationCode) return p;\n                }\n                return null;\n            }\n        }\n    }, {\n        key: 'fillStartData',\n        value: function fillStartData(stationsList, goingSpeed, reservedTime, myIgnoringFragments) {\n            this.finalPoint.tryUpdate(getTimeForGoingTo((0, _geoCoordsDistance2.default)(this.startPoint.coords, this.finalPoint.coords), goingSpeed) + 1800 /*+ TimeSpan.FromMinutes(20)*/, this.startPoint, null, null);\n            var finalPointCoords = this.finalPoint.coords;\n            for (var i = 0, n = stationsList.length, st = stationsList[0]; i < n; st = stationsList[++i]) {\n                if (myIgnoringFragments != null && myIgnoringFragments.contains(st.hashcode, null, null)) continue;\n\n                var add = new _point2.default(2160000000, st, null, null);\n                add.heuristicTimeToFinalPoint = (0, _geoCoordsDistance2.default)(add.coords, finalPointCoords) / 5;\n                add.tryUpdate(getTimeForGoingTo((0, _geoCoordsDistance2.default)(this.startPoint.coords, st.coords), goingSpeed) + reservedTime, this.startPoint, null, null);\n                this.collection.push(add);\n            }\n        }\n    }, {\n        key: 'getNextUnvisitedPoint',\n        value: function getNextUnvisitedPoint() {\n            if (this.currentSelectedPoint != null) this.currentSelectedPoint.setVisited();\n\n            this.currentSelectedPoint = this.selectPointWithMinimalMark();\n\n            return this.currentSelectedPoint;\n        }\n    }, {\n        key: 'selectPointWithMinimalMark',\n        value: function selectPointWithMinimalMark() {\n            var p = null;\n            for (var i = 0, n = this.collection.length, t = this.collection[0]; i < n; t = this.collection[++i]) {\n                if (!t.isVisited) {\n                    p = t;\n                    //var euristicTimeSecondsToFinalPoint = distance(p.coords, this.finalPoint.coords) / 5; // Оценка оставшегося времени пути в секундах.\n                    for (t = this.collection[++i]; i < n; t = this.collection[++i]) {\n                        //var tmpEuristic = distance(t.coords, this.finalPoint.coords) / 5;\n                        if (!t.isVisited && t.totalTimeSeconds + t.heuristicTimeToFinalPoint < p.totalTimeSeconds + p.heuristicTimeToFinalPoint) {\n                            p = t;\n                            //euristicTimeSecondsToFinalPoint = tmpEuristic;\n                        }\n                    }\n                    return p;\n                }\n            }\n            return null;\n        }\n    }, {\n        key: 'countShortWay',\n        value: function countShortWay(ignoringRoutes, myIgnoringFragments, time, types, speed, reservedTime) {\n            //TimeSpan overLimitResedvedTime = TimeSpan.FromMinutes(20);\n\n            for (var selectedPoint = this.getNextUnvisitedPoint(), selectedPointStation, selectedPointTotalTimeSeconds, selectedPointStationHashcode, selectedPointFromWhichRoute, momentWhenComingToStation, routesOnStation, selectedPointCoords; selectedPoint != null; selectedPoint = this.getNextUnvisitedPoint()) {\n                //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n                selectedPointTotalTimeSeconds = selectedPoint.totalTimeSeconds;\n                if (selectedPointTotalTimeSeconds > this.finalPoint.totalTimeSeconds /* + overLimitResedvedTime*/) //... Пропускаем и удаляем, если значение метки превышает минимальное время до пункта назначения.\n                    {\n                        break;\n                    }\n                selectedPointStation = selectedPoint.station;\n                selectedPointStationHashcode = selectedPointStation.hashcode;\n                selectedPointFromWhichRoute = selectedPoint.fromWhichRoute;\n                if (selectedPointStation != null) {\n                    // Момент, когда мы прибудем на остановку:\n                    momentWhenComingToStation = time + selectedPointTotalTimeSeconds;\n                    // Загружаем маршруты, проходящие через остановку:\n                    routesOnStation = null; // = routesOnStation = Database.GetRoutesOnStation(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);\n                    if (selectedPointStation.routes != null) routesOnStation = selectedPointStation.routes;else continue;\n\n                    for (var i = 0, n = routesOnStation.length, selectedRoute = routesOnStation[0], nextStation; i < n; selectedRoute = routesOnStation[++i]) {\n                        if (ignoringRoutes != null && ignoringRoutes.includes(selectedRoute)) continue;\n                        if (types.includes(selectedRoute.type)) {\n                            // Следующая остановка у данного тран спорта:\n                            nextStation = selectedRoute.getNextStation(selectedPointStation);\n\n                            /*// Код остановки, на которую попадем на данном транспорте:\r\n                            string nextCode = selectedRoute.getNextStationCodeAfter(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);*/\n                            if (nextStation /*nextCode*/ != null) // Если остановка не является конечной, то:\n                                {\n                                    // Загружаем расписание:\n                                    var table = selectedRoute.getTimetable(selectedPointStation); //Database.getTimetable(selectedPointStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n                                    // Блокируем попытку попасть указанным транспортом на указанную остановку:\n                                    if (myIgnoringFragments != null && myIgnoringFragments.contains(nextStation.hashcode /*nextCode*/, selectedRoute.hashcode, selectedPointStationHashcode)) continue;\n\n                                    if (table.type === TableType.table) // Если это точное расписание, то:\n                                        {\n                                            // Минимальный начальный момент, с который можно начинать ожидать посадку:\n                                            var momentWhenAskingForGoing = momentWhenComingToStation;\n\n                                            // Резервируем дополнительное время, если будем пересаживаться на другой маршрут:\n                                            //if (selectedPoint.RouteCode == null || selectedPoint.RouteCode != selectedRoute.hashcode) momentWhenAskingForGoing += reservedTime;\n                                            if (selectedPointFromWhichRoute != null && selectedPointFromWhichRoute !== selectedRoute) momentWhenAskingForGoing += reservedTime;\n\n                                            // Подсчитываем, сколько будем ожидать этот транспорт на остановке:\n                                            var waitingTime = table.findTimeAfter(momentWhenAskingForGoing);\n\n                                            // Момент, когда мы сядем в транспорт:\n                                            var momentWhenSitInTransport = momentWhenAskingForGoing + waitingTime;\n\n                                            /*// Следующая остановка у данного транспорта:\r\n                                            Station nextStation = Database.GetStationByHashcode(nextCode, databaseMysqlConnection, canReadDataFromLocalCopy: true);*/\n\n                                            // И соответствующее расписание на этой остановке:\n                                            var tbl = selectedRoute.getTimetable(nextStation); //Database.getTimetable(nextStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\n                                            // (сколько будем ехать до следующей остановки):\n                                            var goingOnTransportTime = tbl.findTimeAfter(momentWhenSitInTransport);\n\n                                            // Метка времени:\n                                            var onNextPointtotalTimeSeconds = momentWhenSitInTransport - momentWhenComingToStation + goingOnTransportTime + selectedPointTotalTimeSeconds;\n\n                                            if (this.findElement(nextStation).tryUpdate(onNextPointtotalTimeSeconds, selectedPoint, selectedPointStation, selectedRoute)) {\n                                                //console.log(\"upd...\");\n                                            }\n                                        } else if (table.type === TableType.periodic) {\n                                        throw new Error();\n                                    }\n                                }\n                        }\n                    }\n                }\n                selectedPointCoords = selectedPoint.coords;\n                // Нет смысла идти пешком \"транзитом\" через остановку:\n                if (selectedPointFromWhichRoute == null) continue;\n\n                // Попробуем пройти пешком до других \"вершин\":\n                for (var j = 0, m = this.collection.length, p = this.collection[0], distanceToSelectedPoint, goingTime, newTime; j < m; p = this.collection[++j]) {\n                    if (!p.isVisited && p !== selectedPoint) {\n                        // Блокируем попытку дойти пешком до указанной остановки:\n                        if (myIgnoringFragments != null && myIgnoringFragments.contains(p.stationCode, null, selectedPointStationHashcode)) continue;\n\n                        distanceToSelectedPoint = (0, _geoCoordsDistance2.default)(selectedPointCoords, p.coords);\n\n                        goingTime = getTimeForGoingTo(distanceToSelectedPoint, speed /*, true, sp*/);\n\n                        newTime = selectedPointTotalTimeSeconds + goingTime + reservedTime;\n                        /*if (p != myFinishPoint)*/ // newTime += reservedTime;\n\n                        if (p.tryUpdate(newTime, selectedPoint, selectedPointStation, null)) {\n                            //console.log(\"upd...\");\n                        }\n                    }\n                }if (myIgnoringFragments != null && myIgnoringFragments.contains(null, null, selectedPointStationHashcode)) continue;\n\n                var tryingNewTime = selectedPointTotalTimeSeconds + getTimeForGoingTo((0, _geoCoordsDistance2.default)(selectedPointCoords, this.finalPoint.coords), speed);\n                if (this.finalPoint.tryUpdate(tryingNewTime, selectedPoint, selectedPointStation, null)) {\n                    //console.log(\"upd: \" + selectedPointStation.hashcode);\n                }\n            }\n\n            // Сокращаем время ходьбы пешком до минимума и избавляемся от \"бессмысленных\" пересадок, сохраняя общее время неизменным:\n            var currentPoint = this.finalPoint.previousPoint;\n            while (currentPoint !== this.startPoint) {\n                if (currentPoint == null) {\n                    console.log(\"err 1 in points.js\");\n                    console.log(this.finalPoint);\n                }\n                var r = currentPoint.fromWhichRoute;\n                if (r != null) {\n                    var previousPoint = currentPoint.previousPoint;\n                    //if(previousPoint == null) console.log(\"err 2 in points.js\");\n                    if (previousPoint !== this.startPoint && previousPoint.fromWhichRoute !== r) // Если на предыдущую остановку мы добрались другим транспортом, то:\n                        {\n                            var previousRouteStation = r.getPreviousStation(previousPoint.station);\n                            if (previousRouteStation != null) {\n                                var point = previousRouteStation.point;\n                                if (point != null && point.isVisited) {\n                                    var ttt = r.getTimetable(previousRouteStation);\n                                    if (ttt != null) {\n                                        //var ddd = time + previousPoint.totalTimeSeconds;\n                                        //var moment = r.getTimetable(currentPoint.station).findTimeAfter(ddd);\n                                        //var tmp_time = ttt.findTimeBefore(ddd + moment);\n\n                                        //var momentArriveOnCurrent = previousPoint.totalTimeSeconds + moment;\n                                        //var momentSittingOnPrevious = momentArriveOnCurrent + tmp_time;\n                                        /*bool bbb = point.fromWhichRoute != null && point.fromWhichRoute.getTimetable(point.station) != null && point.fromWhichRoute.getTimetable(point.station).findTimeAfter(time + point.totalTimeSeconds) <= previousPoint.totalTimeSeconds + moment + tmp_time;\r\n                                        if (bbb)\r\n                                        {\r\n                                            previousPoint.fromWhichRoute = r;\r\n                                            previousPoint.previousPoint = point;////!bbb && point.totalTimeSeconds <= momentSittingOnPrevious &&\r\n                                        }\r\n                                        else */\n                                        if ( /*point.totalGoingTime>=previousPoint.totalGoingTime || */point.totalTimeSeconds <= previousPoint.totalTimeSeconds /* && point.totalGoingTime <= previousPoint.totalGoingTime*/) {\n                                                previousPoint.fromWhichRoute = r;\n                                                previousPoint.previousPoint = point;\n                                            }\n                                    }\n                                }\n                            }\n                        }\n                }\n                currentPoint = currentPoint.previousPoint;\n            }\n        }\n    }]);\n\n    return Points;\n}();\n\nexports.default = Points;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-find-optimal-ways/lib/points.js\n// module id = 9\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar WayPoint = function WayPoint(time, station, route, coords) {\n    _classCallCheck(this, WayPoint);\n\n    this.time = time;\n    this.station = station == null ? null : { hashcode: station.hashcode, name: station.name, routes: null, Coords: { lat: station.coords.lat, lng: station.coords.lng } };\n    this.route = route == null ? null : { vehicles: [], gpsTrack: null, hashcode: route.hashcode, number: route.number, type: route.type, from: route.from, to: route.to, owner: \"\", stations: null, timetables: null, stationsJSON: null };\n    this.coords = coords;\n};\n\nexports.default = WayPoint;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-find-optimal-ways/lib/wayPoint.js\n// module id = 10\n// module chunks = 0","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// Initailize.\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfunction getNextStation(currentStation) {\n    for (var j = 0; j <= 1; j++) {\n        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n            if (this.stations[j][t] === currentStation) {\n                if (t + 1 !== nn) return this.stations[j][t + 1];else return null;\n            }\n        }\n    }\n    return null;\n}\nfunction getPreviousStation(currentStation) {\n    for (var j = 0; j <= 1; j++) {\n        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n            if (this.stations[j][t] === currentStation) {\n                if (t !== nn) return this.stations[j][t - 1];else return null;\n            }\n        }\n    }\n    return null;\n}\nfunction getTimetable(station) {\n    for (var j = 0; j <= 1; j++) {\n        for (var i = 0, n = this.stations[j].length; i < n; i++) {\n            if (this.stations[j][i] === station) {\n                return this.timetables[j][i];\n            }\n        }\n    }\n    return null;\n}\nfunction findTimeAfter(time) {\n    var dateTmp = new Date();\n    dateTmp.setMinutes(0);\n    dateTmp.setHours(0);\n    dateTmp.setSeconds(time);\n    var day = dateTmp.getDay();\n    //foreach (Table t in table)\n    for (var kkk = 0, mnkk = this.table.length, t = this.table[0]; kkk < mnkk; t = this.table[++kkk]) {\n        if (t.days.includes(day)) {\n\n            //foreach (SimpleTime st in t.times)\n            for (var iik = 0, mnii = t.times.length, st = t.times[0], stTime; iik < mnii; st = t.times[++iik]) {\n                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n                //\n                stTime = st.hour * 3600 + st.minute * 60;\n                if (stTime >= time /*.Second + time.Minute * 60 + time.Hour * 3600*/ /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n                        return stTime - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/;\n                    }\n            }\n            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/ + 86400;\n            break;\n        }\n    }\n    return 2160000000;\n    //throw new Exception();\n}\nfunction findTimeBefore(time) {\n    var dateTmp = new Date();\n    dateTmp.setMinutes(0);\n    dateTmp.setHours(0);\n    dateTmp.setSeconds(time);\n    var day = dateTmp.getDay();\n    for (var kkk = 0, mnkk = this.table.length, t = this.table[0], ok = false, st; kkk < mnkk; t = this.table[++kkk]) {\n        if (t.days.includes(day)) {\n            ok = false;\n            st = null;\n            for (var iik = 0, mnii = t.times.length, stt = t.times[0]; iik < mnii; stt = t.times[++iik]) {\n                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n                //\n                if (stt.hour * 3600 + stt.minute * 60 <= time /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n                        ok = true;\n                        st = stt;\n                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n                    } else break;\n            }\n            if (ok) return st.hour * 3600 + st.minute * 60 - time;\n            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time - 86400;\n            break;\n        }\n    }\n    return 0; //TimeSpan.FromDays(0/*-25000*/);\n    //throw new Exception();\n}\n\nfunction initialize(allStations, allRoutes, allTimetables) {\n    //alert(allStations.length);\n    //alert(allRoutes.length);\n    //alert(allTimetables.length);\n\n    console.log(\"Start initializing...\");\n    var startInitializingMoment = Date.now();\n\n    var tmpUsedStations = [];\n\n    function bindRoutesStationsTimetables(station, tmpArr, tabArr, rr) {\n        if (station.routes == null) station.routes = [];\n        //console.log(station.routes);//!!!\n        if (!station.routes.includes(rr)) station.routes.push(rr);\n        tmpArr.push(station);\n\n        var tmp = allTimetables.find(function (element, index, array) {\n            return element.stationCode === station.hashcode && element.routeCode === rr.hashcode;\n        });\n        var tmpTab = tmp == null ? null : tmp;\n\n        tabArr.push(tmpTab);\n    }\n\n    // Удаляем станции, через которые не идет ни один маршрут\n    var newAllStations = [];\n    for (var i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[++i]) {\n        if (currentStation.routesCodes != null && currentStation.routesCodes.length !== 0) {\n            newAllStations.push(currentStation);\n        }\n    }\n    allStations = newAllStations;\n\n    for (var _i = 0, _n = allRoutes.length, rr = allRoutes[0]; _i < _n; rr = allRoutes[++_i]) {\n\n        rr.getNextStation = getNextStation;\n        rr.getPreviousStation = getPreviousStation;\n        rr.getTimetable = getTimetable;\n\n        if (rr.stationsCodes == null || rr.stationsCodes.length === 0) {\n            continue;\n        }\n\n        try {\n            //if (rr.stationsCodes[rr.stationsCodes.Length - 1] != ']') continue;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n            rr.stations = [[], []];\n            rr.timetables = [[], []];\n\n            for (var index = 0, tmpArr = [], tabArr = []; index <= 1; index++) {\n                var rr_stationsCodes = rr.stationsCodes;\n                if (rr_stationsCodes[index] == null || rr_stationsCodes[index].length === 0) continue;\n                for (var j = 0, m = rr_stationsCodes[index].length, stationCode = rr_stationsCodes[index][0]; j < m; stationCode = rr_stationsCodes[index][++j]) {\n                    var tmpUsed = false;\n                    for (var k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\n                        if (station != null && station.hashcode === stationCode) {\n                            bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\n                            tmpUsed = true;\n                            break;\n                        }\n                    }\n                    if (!tmpUsed) {\n                        for (var _k = 0, _mn = allStations.length, _station = allStations[0]; _k < _mn; _station = allStations[++_k]) {\n                            if (_station != null && _station.hashcode === stationCode) {\n                                bindRoutesStationsTimetables(_station, tmpArr, tabArr, rr);\n                                if (!tmpUsedStations.includes(_station)) tmpUsedStations.push(_station);\n                                break;\n                            }\n                        }\n                    }\n                }\n                rr.stations[index] = tmpArr;\n                rr.timetables[index] = tabArr;\n            }\n        } catch (ex) {\n            console.log(ex /*.message*/);\n            continue;\n        }\n    }\n\n    console.log(\"Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\n    for (var _i2 = 0, _n2 = allTimetables.length, timetable = allTimetables[0]; _i2 < _n2; timetable = allTimetables[++_i2]) {\n        timetable.findTimeAfter = findTimeAfter;\n        timetable.findTimeBefore = findTimeBefore;\n    }\n\n    //...\n    /*\r\n    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n        if (currentStation.routes == undefined || currentStation.routes == null || currentStation.routes.length == 0) {\r\n            allStations.splice(i, 1);\r\n            n = allStations.length;\r\n        }\r\n        else i++;\r\n    }\r\n    */\n\n    console.log(\"Initialized. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n    //console.log(\"\\n\\n\" + JSON.stringify(allTimetables[0]) + \"\\n\\n\");\n\n\n    //for (let t = 0; t < 1000; t++) var ttt = GetStationsAround(allStations[0].coords, 30000).length;\n    //console.log(\"test. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\n\n    //global.initialized = true;\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// End initailize.\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nexports.default = initialize;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/public-transport-initialize-data/lib/initialize.js\n// module id = 11\n// module chunks = 0"],"sourceRoot":""}