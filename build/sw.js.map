{"version":3,"sources":["webpack:///sw.js","webpack:///webpack/bootstrap f2d06cd4aab4c3e78d05","webpack:///./src/modules/public-transport-client/sw.js","webpack:///./~/babel-preset-react-app/~/babel-runtime/regenerator/index.js","webpack:///./src/modules/geo-coords-functions/geoCoords.js","webpack:///./src/modules/public-transport-client/config.js","webpack:///./~/process/browser.js","webpack:///./src/modules/public-transport-client/dataProvider.js","webpack:///./src/modules/public-transport-client/jsonDataStorage.js","webpack:///./src/modules/public-transport-find-optimal-ways/optimalRoute.js","webpack:///./src/modules/public-transport-find-optimal-ways/optimalRoutesCollection.js","webpack:///./src/modules/public-transport-find-optimal-ways/optimalWay.js","webpack:///./src/modules/public-transport-find-optimal-ways/point.js","webpack:///./src/modules/public-transport-find-optimal-ways/points.js","webpack:///./src/modules/public-transport-find-optimal-ways/wayPoint.js","webpack:///./src/modules/public-transport-initialize-data/initialize.js","webpack:///./~/regenerator-runtime/runtime-module.js","webpack:///./~/regenerator-runtime/runtime.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_dataProvider","_dataProvider2","_config","_config2","_optimalRoutesCollection","_optimalRoutesCollection2","console","log","APP_CACHE_NAME","TILE_CACHE_NAME","urlsToCache","self","addEventListener","event","cachePromise","caches","open","then","cache","addAll","waitUntil","loadDataAndInitialize","clients","sender","source","data","includes","push","postMessage","setInterval","clientVsSwNoKillingMessageInterval","requestType","rejected","resolved","params","res","getAllStations","startOptimalRoutePoint","finalOptimalRoutePoint","startTime","transportTypes","goingSpeed","dopTimeMinutes","getOptimalWays","e","result","url","request","respondWith","match","response","add","fetch","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","GeoCoords","this","a","b","taylorSin","x","yy","zz","taylorCos","earthRadius","pi180","lat1","lat","lat2","long1","lng","long2","cl1","cl2","sl1","sl2","delta","cdelta","sdelta","tmp","y","Math","sqrt","ad","atan2","dist","ceil","apiPublicTransportServer","apiGetStationsUrl","apiGetRoutesUrl","apiGetTimetablesUrl","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","process","nextTick","args","Array","arguments","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","_asyncToGenerator","fn","gen","Promise","resolve","reject","step","arg","info","error","done","err","_regenerator","_regenerator2","_loadDataOnly","_ref","mark","_callee","_response","_response2","wrap","_context","prev","next","_jsonDataStorage2","allStationsJSON","sent","getAllRoutes","allRoutesJSON","getAllTimetables","allTimetablesJSON","allStationsLoaded","text","allStations","JSON","parse","undefined","pushAllStations","allRoutesLoaded","allRoutes","pushAllRoutes","allTimetablesLoaded","allTimetables","pushAllTimetables","stop","loadData","_ref2","_callee2","_context2","loadingStarted","loadDataOnly","_initialize2","_jsonDataStorage","_initialize","DataProvider","_ref3","_callee3","_context3","_ref4","_callee4","_context4","getJsonDataStorageConnection","promise","indexedDB","dbName","onerror","onsuccess","onupgradeneeded","db","objectStore","createObjectStore","storeName","keyPath","createIndex","unique","_x","abrupt","tryPush","transaction","json","_x3","_x4","_x2","getItem","_ref5","_callee6","_context6","_ref6","_callee5","_context5","get","_x6","_x7","_x5","JsonDataStorage","_ref7","_callee7","_context7","t0","_ref8","_callee8","_context8","_ref9","_callee9","_context9","_x8","_ref10","_callee10","allStationsJson","_context10","_x9","_ref11","_callee11","allRoutesJson","_context11","_x10","_ref12","_callee12","allTimetablesJson","_context12","OptimalRoute","myPoints","stationsList","time","types","ignoringRoutesAdd","ignoringList","ignoringRoutes","points","reservedTimeSeconds","myIgnoringFragments","fillStartData","countShortWay","tmpP","finalPoint","toString","previousPoint","coords","startPoint","totalTimeSeconds","totalGoingTime","getTotalGoingTime","totalTransportChangingCount","getTotalTransportChangingCount","isVisited","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","getStationsAround","radius","n","s","distance","_optimalRoute","_optimalRoute2","_optimalWay","_optimalWay2","_points","_points2","_geoCoords","_geoCoords2","OptimalRoutesCollection","_Array","nowPos","needPos","speed","_this","getPrototypeOf","r","selectOptimalRouteWithMinimalMark","t","selectedOptimalRoute","setVisited","ddd","fromWhichRoute","tmpOptimalRoute","tmpJSON","stringify","ok","j","opt","_wayPoint","_wayPoint2","OptimalWay","optimalRoute","totalGoingTimeSeconds","station","reverse","Point","station_or_crds","fromWhichStation","hashcode","stationCode","point","to","tr","type","number","from","goingTime","getTimeForGoingTo","floor","_point","_point2","TableType","table","periodic","Points","collection","currentSelectedPoint","station_or_point","newCreatdPoint","reservedTime","tryUpdate","st","contains","selectPointWithMinimalMark","selectedPointStation","selectedPointTotalTimeSeconds","selectedPointStationHashcode","selectedPointFromWhichRoute","momentWhenComingToStation","routesOnStation","selectedPointCoords","selectedPoint","getNextUnvisitedPoint","routes","nextStation","selectedRoute","getNextStation","getTimetable","momentWhenAskingForGoing","waitingTime","findTimeAfter","momentWhenSitInTransport","tbl","goingOnTransportTime","onNextPointtotalTimeSeconds","findElement","distanceToSelectedPoint","newTime","tryingNewTime","currentPoint","previousRouteStation","getPreviousStation","ttt","WayPoint","route","Coords","vehicles","gpsTrack","owner","stations","timetables","stationsJSON","currentStation","nn","dateTmp","Date","setMinutes","setHours","setSeconds","day","getDay","kkk","mnkk","days","stTime","iik","mnii","times","hour","minute","findTimeBefore","stt","initialize","bindRoutesStationsTimetables","tmpArr","tabArr","rr","find","element","index","routeCode","tmpTab","startInitializingMoment","now","tmpUsedStations","routesCodes","splice","stationsCodes","rr_stationsCodes","tmpUsed","k","mn","ex","timetable","global","g","window","hadRuntime","regeneratorRuntime","getOwnPropertyNames","indexOf","oldRuntime","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","makeInvokeMethod","tryCatch","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","forEach","method","AsyncIterator","invoke","record","hasOwn","__await","unwrapped","enqueue","callInvokeWithMethodAndArg","previousPromise","domain","bind","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","_sent","dispatchException","GenStateSuspendedYield","iterator","return","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","values","iterable","iteratorMethod","iteratorSymbol","isNaN","Op","hasOwnProperty","$Symbol","Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","ctor","awrap","async","iter","keys","object","pop","skipTempReset","charAt","slice","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield"],"mappings":"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","file":"sw.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _dataProvider = __webpack_require__(5);\n\t\n\tvar _dataProvider2 = _interopRequireDefault(_dataProvider);\n\t\n\tvar _config = __webpack_require__(3);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tvar _optimalRoutesCollection = __webpack_require__(8);\n\t\n\tvar _optimalRoutesCollection2 = _interopRequireDefault(_optimalRoutesCollection);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t//import AppClient from './client';\n\t//let s = '123hello123';\n\tconsole.log('Hello from SW...');\n\t\n\tvar APP_CACHE_NAME = 'mosm-app-v1';\n\tvar TILE_CACHE_NAME = 'mosm-tiles-v1';\n\t\n\tvar urlsToCache = ['/', '/favicon.ico', '/static/js/bundle.js', '/static/css/style.css'];\n\t\n\tself.addEventListener('install', function (event) {\n\t  // Perform install steps\n\t  var cachePromise = caches.open(APP_CACHE_NAME).then(function (cache) {\n\t    console.log('install: opened cache');\n\t    return cache.addAll(urlsToCache);\n\t  }).then(function () {\n\t    console.log('install: added all urls to cache');\n\t  });\n\t\n\t  event.waitUntil(cachePromise);\n\t  //event.waitUntil(self.skipWaiting()); // Activate worker immediately\n\t});\n\t\n\tself.addEventListener('activate', function (event) {\n\t  _dataProvider2.default.loadDataAndInitialize();\n\t\n\t  //event.waitUntil(self.clients.claim()); // Become available to all pages\n\t  //console.log('!!!!!!!!!activate');\n\t\n\t  /**/\n\t});\n\t/*\r\n\tvar test = 0;\r\n\tsetInterval(function() {\r\n\t  test++\r\n\t}, 1000)\r\n\t*/\n\t//var ok = true;\n\t\n\tvar clients = [];\n\t\n\tself.addEventListener('message', function (event) {\n\t  var sender = event.source;\n\t  //console.log(event.data);\n\t  if (event.data === 'no-kill-sw') {\n\t    //console.log('SW: client call no-kill-sw.')\n\t    if (clients.includes(sender.id)) {\n\t      return;\n\t    } else {\n\t      clients.push(sender.id);\n\t      sender.postMessage('no-kill-sw-accepted');\n\t      setInterval(function () {\n\t        sender.postMessage(\"no-kill-sw-accepted\");\n\t      }, _config2.default.clientVsSwNoKillingMessageInterval);\n\t    }\n\t  } else if (event.data.requestType === 'optimalWay') {\n\t    console.log('SW: request for optimalWay.');\n\t\n\t    _dataProvider2.default.loadDataAndInitialize();\n\t\n\t    var params = event.data.params;\n\t    var rejected, resolved;\n\t    try {\n\t      var res = new _optimalRoutesCollection2.default(_dataProvider2.default.getAllStations(), params.startOptimalRoutePoint, params.finalOptimalRoutePoint, params.startTime, params.transportTypes, params.goingSpeed, params.dopTimeMinutes);\n\t      //console.log('res = ' + res);\n\t      resolved = res.getOptimalWays();\n\t      //console.log('resolved = ' + resolved);\n\t    } catch (e) {\n\t      console.log(e);\n\t      rejected = e;\n\t    } finally {\n\t      sender.postMessage({\n\t        requestType: 'optimalWayResult',\n\t        result: resolved\n\t      });\n\t    }\n\t  }\n\t  /*if(ok) {\r\n\t    //ok = false;\r\n\t    setInterval(function() {\r\n\t      sender.postMessage({\r\n\t        message: test\r\n\t      });\r\n\t    }, 1000)\r\n\t    //if (event.waitUntil) {\r\n\t    //  event.waitUntil(promise);\r\n\t    //}\r\n\t  }*/\n\t});\n\t\n\tself.addEventListener('fetch', function (event) {\n\t  var url = event.request.url;\n\t\n\t  event.respondWith(caches.match(event.request).then(function (response) {\n\t    // Cache hit - return response\n\t    if (response) {\n\t      return response;\n\t    }\n\t    caches.open(TILE_CACHE_NAME).then(function (cache) {\n\t      return cache.add(url);\n\t    });\n\t\n\t    return fetch(event.request);\n\t  }));\n\t});\n\t\n\t/*self.addEventListener('fetch', function(event) {\r\n\t  event.respondWith(\r\n\t    fetch(event.request).catch(function() {\r\n\t      return caches.match(event.request);\r\n\t    })\r\n\t  );\r\n\t});*/\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(14);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GeoCoords = function () {\n\t    function GeoCoords() {\n\t        _classCallCheck(this, GeoCoords);\n\t    }\n\t\n\t    _createClass(GeoCoords, null, [{\n\t        key: \"distance\",\n\t        value: function distance(a, b) {\n\t            var earthRadius = 6372795;\n\t            var pi180 = 0.017453; // 29251//Math.Round(Math.PI / 180, 5);\n\t            var zz = 1,\n\t                yy = 1;\n\t            function taylorSin(x) {\n\t                yy = x * x;\n\t                zz = x;\n\t                return zz - (zz *= yy) / 6 + (zz *= yy) / 120;\n\t            }\n\t            function taylorCos(x) {\n\t                yy = x * x;\n\t                zz = yy;\n\t                return 1 - yy / 2 + (zz *= yy) / 24;\n\t            }\n\t            /*function taylorAtan(x) {\r\n\t                yy = x * x;\r\n\t                zz = x;\r\n\t                return zz - (zz *= yy) / 3 + (zz *= yy) / 5 - (zz *= yy) / 7 + (zz *= yy) / 9 - (zz *= yy) / 20;\r\n\t            }*/\n\t\n\t            // перевести координаты в радианы\n\t            var lat1 = a.lat * pi180;\n\t            var lat2 = b.lat * pi180;\n\t            var long1 = a.lng * pi180;\n\t            var long2 = b.lng * pi180;\n\t\n\t            // косинусы и синусы широт и разницы долгот\n\t            var cl1 = taylorCos(lat1);\n\t            var cl2 = taylorCos(lat2);\n\t            var sl1 = taylorSin(lat1);\n\t            var sl2 = taylorSin(lat2);\n\t            var delta = long2 - long1;\n\t            var cdelta = taylorCos(delta);\n\t            var sdelta = taylorSin(delta);\n\t\n\t            // вычисления длины большого круга\n\t            var tmp = cl2 * cdelta;\n\t            var y = Math.sqrt(cl2 * cl2 * sdelta * sdelta + (cl1 * sl2 - sl1 * tmp) * (cl1 * sl2 - sl1 * tmp));\n\t            var x = sl1 * sl2 + cl1 * tmp;\n\t\n\t            //\n\t            var ad = Math.atan2(y, x); //taylorAtan(y/x);\n\t            var dist = Math.ceil(ad * earthRadius); //(int)Math.Round(ad * earthRadius, 0);\n\t\n\t            return dist;\n\t        }\n\t    }]);\n\t\n\t    return GeoCoords;\n\t}();\n\t\n\texports.default = GeoCoords;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = {\n\t    apiPublicTransportServer: \"https://ptp-97126.app.xervo.io/\",\n\t    apiGetStationsUrl: \"https://publictransportproject.000webhostapp.com/new/json/stations.json\", //\"stations\"\n\t    apiGetRoutesUrl: \"https://publictransportproject.000webhostapp.com/new/json/routes.json\", //\"routes\"\n\t    apiGetTimetablesUrl: \"https://publictransportproject.000webhostapp.com/new/json/timetables.json\", //\"timetables\"\n\t\n\t    clientVsSwNoKillingMessageInterval: 30000\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _regenerator = __webpack_require__(1);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _loadDataOnly = function () {\n\t    var _ref = _asyncToGenerator(_regenerator2.default.mark(function _callee() {\n\t        var response, _response, _response2;\n\t\n\t        return _regenerator2.default.wrap(function _callee$(_context) {\n\t            while (1) {\n\t                switch (_context.prev = _context.next) {\n\t                    case 0:\n\t                        _context.next = 2;\n\t                        return _jsonDataStorage2.default.getAllStations();\n\t\n\t                    case 2:\n\t                        allStationsJSON = _context.sent;\n\t                        _context.next = 5;\n\t                        return _jsonDataStorage2.default.getAllRoutes();\n\t\n\t                    case 5:\n\t                        allRoutesJSON = _context.sent;\n\t                        _context.next = 8;\n\t                        return _jsonDataStorage2.default.getAllTimetables();\n\t\n\t                    case 8:\n\t                        allTimetablesJSON = _context.sent;\n\t\n\t                        if (allStationsLoaded) {\n\t                            _context.next = 27;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allStationsJSON == null)) {\n\t                            _context.next = 24;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allStationsJSON\"] === undefined || localStorage[\"allStationsJSON\"] == null\n\t                        console.log(\"Downloading stations from server...\");\n\t\n\t                        _context.next = 14;\n\t                        return fetch(_config2.default.apiGetStationsUrl);\n\t\n\t                    case 14:\n\t                        response = _context.sent;\n\t                        _context.next = 17;\n\t                        return response.text();\n\t\n\t                    case 17:\n\t                        allStationsJSON = _context.sent;\n\t\n\t                        allStations = JSON.parse(allStationsJSON); //await response.json();\n\t\n\t                        if (allStations !== undefined && allStations != null) _jsonDataStorage2.default.pushAllStations(allStationsJSON); //localStorage[\"allStationsJSON\"] = allStationsJSON;\n\t                        allStationsLoaded = true;\n\t                        console.log(\"Stations loaded from server.\");\n\t                        _context.next = 27;\n\t                        break;\n\t\n\t                    case 24:\n\t                        allStations = JSON.parse(allStationsJSON); //localStorage[\"allStationsJSON\"]\n\t                        allStationsLoaded = true;\n\t                        console.log(\"Stations loaded from localStorage.\");\n\t\n\t                    case 27:\n\t                        if (allRoutesLoaded) {\n\t                            _context.next = 45;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allRoutesJSON == null)) {\n\t                            _context.next = 42;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allRoutesJSON\"] === undefined || localStorage[\"allRoutesJSON\"] == null\n\t                        console.log(\"Downloading routes from server...\");\n\t\n\t                        _context.next = 32;\n\t                        return fetch(_config2.default.apiGetRoutesUrl);\n\t\n\t                    case 32:\n\t                        _response = _context.sent;\n\t                        _context.next = 35;\n\t                        return _response.text();\n\t\n\t                    case 35:\n\t                        allRoutesJSON = _context.sent;\n\t\n\t                        allRoutes = JSON.parse(allRoutesJSON); //await response.json();\n\t\n\t                        if (allRoutes !== undefined && allRoutes != null) _jsonDataStorage2.default.pushAllRoutes(allRoutesJSON); //localStorage[\"allRoutesJSON\"] = allRoutesJSON;\n\t                        allRoutesLoaded = true;\n\t                        console.log(\"Routes loaded from server.\");\n\t                        _context.next = 45;\n\t                        break;\n\t\n\t                    case 42:\n\t                        allRoutes = JSON.parse(allRoutesJSON); //localStorage[\"allRoutesJSON\"]\n\t                        allRoutesLoaded = true;\n\t                        console.log(\"Routes loaded from localStorage.\");\n\t\n\t                    case 45:\n\t                        if (allTimetablesLoaded) {\n\t                            _context.next = 63;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(allTimetablesJSON == null)) {\n\t                            _context.next = 60;\n\t                            break;\n\t                        }\n\t\n\t                        //localStorage[\"allTimetablesJSON\"] === undefined || localStorage[\"allTimetablesJSON\"] == null\n\t                        console.log(\"Downloading timetables from server...\");\n\t\n\t                        _context.next = 50;\n\t                        return fetch(_config2.default.apiGetTimetablesUrl);\n\t\n\t                    case 50:\n\t                        _response2 = _context.sent;\n\t                        _context.next = 53;\n\t                        return _response2.text();\n\t\n\t                    case 53:\n\t                        allTimetablesJSON = _context.sent;\n\t\n\t                        allTimetables = JSON.parse(allTimetablesJSON); //await response.json();\n\t\n\t                        if (allTimetables !== undefined && allTimetables != null) _jsonDataStorage2.default.pushAllTimetables(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"] = allTimetablesJSON;\n\t                        allTimetablesLoaded = true;\n\t                        console.log(\"Timetables loaded from server.\");\n\t                        _context.next = 63;\n\t                        break;\n\t\n\t                    case 60:\n\t                        allTimetables = JSON.parse(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"]\n\t                        allTimetablesLoaded = true;\n\t                        console.log(\"Timetables loaded from localStorage.\");\n\t\n\t                    case 63:\n\t                    case 'end':\n\t                        return _context.stop();\n\t                }\n\t            }\n\t        }, _callee, this);\n\t    }));\n\t\n\t    return function _loadDataOnly() {\n\t        return _ref.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar loadData = function () {\n\t    var _ref2 = _asyncToGenerator(_regenerator2.default.mark(function _callee2() {\n\t        return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t            while (1) {\n\t                switch (_context2.prev = _context2.next) {\n\t                    case 0:\n\t                        if (loadingStarted) {\n\t                            _context2.next = 5;\n\t                            break;\n\t                        }\n\t\n\t                        loadingStarted = true;\n\t\n\t                        _context2.next = 4;\n\t                        return _loadDataOnly();\n\t\n\t                    case 4:\n\t\n\t                        if (allStationsLoaded && allRoutesLoaded && allTimetablesLoaded) {\n\t                            (0, _initialize2.default)(allStations, allRoutes, allTimetables);\n\t                        }\n\t\n\t                    case 5:\n\t                    case 'end':\n\t                        return _context2.stop();\n\t                }\n\t            }\n\t        }, _callee2, this);\n\t    }));\n\t\n\t    return function loadData() {\n\t        return _ref2.apply(this, arguments);\n\t    };\n\t}();\n\t\n\t//loadData();\n\t\n\tvar _jsonDataStorage = __webpack_require__(6);\n\t\n\tvar _jsonDataStorage2 = _interopRequireDefault(_jsonDataStorage);\n\t\n\tvar _initialize = __webpack_require__(13);\n\t\n\tvar _initialize2 = _interopRequireDefault(_initialize);\n\t\n\tvar _config = __webpack_require__(3);\n\t\n\tvar _config2 = _interopRequireDefault(_config);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Load data.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar allStations = null;\n\tvar allRoutes = null;\n\tvar allTimetables = null;\n\t\n\t//var updatingFromServerInterval = 5000;\n\t\n\tvar loadingStarted = false;\n\t\n\tvar allStationsLoaded = false,\n\t    allRoutesLoaded = false,\n\t    allTimetablesLoaded = false;\n\tvar allStationsJSON = null,\n\t    allRoutesJSON = null,\n\t    allTimetablesJSON = null;\n\t\n\tvar DataProvider = function () {\n\t    function DataProvider() {\n\t        _classCallCheck(this, DataProvider);\n\t    }\n\t\n\t    _createClass(DataProvider, null, [{\n\t        key: 'getAllStations',\n\t        value: function getAllStations() {\n\t            return allStations;\n\t        }\n\t    }, {\n\t        key: 'getAllRoutes',\n\t        value: function getAllRoutes() {\n\t            return allRoutes;\n\t        }\n\t    }, {\n\t        key: 'getAllTimetables',\n\t        value: function getAllTimetables() {\n\t            return allTimetables;\n\t        }\n\t    }, {\n\t        key: 'getAllStationsJSON',\n\t        value: function getAllStationsJSON() {\n\t            return allStationsJSON;\n\t        }\n\t    }, {\n\t        key: 'getAllRoutesJSON',\n\t        value: function getAllRoutesJSON() {\n\t            return allRoutesJSON;\n\t        }\n\t    }, {\n\t        key: 'getAllTimetablesJSON',\n\t        value: function getAllTimetablesJSON() {\n\t            return allTimetablesJSON;\n\t        }\n\t    }, {\n\t        key: 'loadDataAndInitialize',\n\t        value: function () {\n\t            var _ref3 = _asyncToGenerator(_regenerator2.default.mark(function _callee3() {\n\t                return _regenerator2.default.wrap(function _callee3$(_context3) {\n\t                    while (1) {\n\t                        switch (_context3.prev = _context3.next) {\n\t                            case 0:\n\t                                _context3.next = 2;\n\t                                return loadData();\n\t\n\t                            case 2:\n\t                            case 'end':\n\t                                return _context3.stop();\n\t                        }\n\t                    }\n\t                }, _callee3, this);\n\t            }));\n\t\n\t            function loadDataAndInitialize() {\n\t                return _ref3.apply(this, arguments);\n\t            }\n\t\n\t            return loadDataAndInitialize;\n\t        }()\n\t    }, {\n\t        key: 'loadDataOnly',\n\t        value: function () {\n\t            var _ref4 = _asyncToGenerator(_regenerator2.default.mark(function _callee4() {\n\t                return _regenerator2.default.wrap(function _callee4$(_context4) {\n\t                    while (1) {\n\t                        switch (_context4.prev = _context4.next) {\n\t                            case 0:\n\t                                _context4.next = 2;\n\t                                return _loadDataOnly();\n\t\n\t                            case 2:\n\t                            case 'end':\n\t                                return _context4.stop();\n\t                        }\n\t                    }\n\t                }, _callee4, this);\n\t            }));\n\t\n\t            function loadDataOnly() {\n\t                return _ref4.apply(this, arguments);\n\t            }\n\t\n\t            return loadDataOnly;\n\t        }()\n\t    }]);\n\t\n\t    return DataProvider;\n\t}();\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End load data.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\texports.default = DataProvider;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _regenerator = __webpack_require__(1);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar getJsonDataStorageConnection = function () {\n\t    var _ref = _asyncToGenerator(_regenerator2.default.mark(function _callee2() {\n\t        var promise;\n\t        return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t            while (1) {\n\t                switch (_context2.prev = _context2.next) {\n\t                    case 0:\n\t                        promise = new Promise(function (resolve, reject) {\n\t\n\t                            var request = indexedDB.open(dbName, 1);\n\t                            request.onerror = function (event) {\n\t                                reject(event.target.error);\n\t                            };\n\t                            request.onsuccess = function (event) {\n\t                                resolve(event.target.result);\n\t                            };\n\t                            request.onupgradeneeded = function () {\n\t                                var _ref2 = _asyncToGenerator(_regenerator2.default.mark(function _callee(event) {\n\t                                    var db, objectStore, result;\n\t                                    return _regenerator2.default.wrap(function _callee$(_context) {\n\t                                        while (1) {\n\t                                            switch (_context.prev = _context.next) {\n\t                                                case 0:\n\t                                                    db = event.target.result;\n\t                                                    objectStore = db.createObjectStore(storeName, { keyPath: \"name\" });\n\t\n\t                                                    objectStore.createIndex(\"json\", \"json\", { unique: false });\n\t\n\t                                                    _context.next = 5;\n\t                                                    return getJsonDataStorageConnection();\n\t\n\t                                                case 5:\n\t                                                    result = _context.sent;\n\t\n\t                                                    resolve(result);\n\t\n\t                                                case 7:\n\t                                                case \"end\":\n\t                                                    return _context.stop();\n\t                                            }\n\t                                        }\n\t                                    }, _callee, this);\n\t                                }));\n\t\n\t                                return function (_x) {\n\t                                    return _ref2.apply(this, arguments);\n\t                                };\n\t                            }();\n\t                        });\n\t                        _context2.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context2.abrupt(\"return\", _context2.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context2.stop();\n\t                }\n\t            }\n\t        }, _callee2, this);\n\t    }));\n\t\n\t    return function getJsonDataStorageConnection() {\n\t        return _ref.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar tryPush = function () {\n\t    var _ref3 = _asyncToGenerator(_regenerator2.default.mark(function _callee4(obj) {\n\t        var promise;\n\t        return _regenerator2.default.wrap(function _callee4$(_context4) {\n\t            while (1) {\n\t                switch (_context4.prev = _context4.next) {\n\t                    case 0:\n\t                        promise = new Promise(function () {\n\t                            var _ref4 = _asyncToGenerator(_regenerator2.default.mark(function _callee3(resolve, reject) {\n\t                                var db, transaction, objectStore, request;\n\t                                return _regenerator2.default.wrap(function _callee3$(_context3) {\n\t                                    while (1) {\n\t                                        switch (_context3.prev = _context3.next) {\n\t                                            case 0:\n\t                                                _context3.next = 2;\n\t                                                return getJsonDataStorageConnection();\n\t\n\t                                            case 2:\n\t                                                db = _context3.sent;\n\t\n\t                                                //console.log(db);\n\t                                                transaction = db.transaction([storeName], \"readwrite\");\n\t                                                objectStore = transaction.objectStore(storeName);\n\t                                                request = objectStore.add({\n\t                                                    name: obj.name,\n\t                                                    json: obj.json\n\t                                                });\n\t\n\t                                                request.onerror = function (event) {\n\t                                                    reject(event.target.error);\n\t                                                };\n\t                                                request.onsuccess = function (event) {\n\t                                                    resolve(event.target.result);\n\t                                                };\n\t\n\t                                            case 8:\n\t                                            case \"end\":\n\t                                                return _context3.stop();\n\t                                        }\n\t                                    }\n\t                                }, _callee3, this);\n\t                            }));\n\t\n\t                            return function (_x3, _x4) {\n\t                                return _ref4.apply(this, arguments);\n\t                            };\n\t                        }());\n\t                        _context4.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context4.abrupt(\"return\", _context4.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context4.stop();\n\t                }\n\t            }\n\t        }, _callee4, this);\n\t    }));\n\t\n\t    return function tryPush(_x2) {\n\t        return _ref3.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar getItem = function () {\n\t    var _ref5 = _asyncToGenerator(_regenerator2.default.mark(function _callee6(name) {\n\t        var promise;\n\t        return _regenerator2.default.wrap(function _callee6$(_context6) {\n\t            while (1) {\n\t                switch (_context6.prev = _context6.next) {\n\t                    case 0:\n\t                        promise = new Promise(function () {\n\t                            var _ref6 = _asyncToGenerator(_regenerator2.default.mark(function _callee5(resolve, reject) {\n\t                                var db, transaction, objectStore, request;\n\t                                return _regenerator2.default.wrap(function _callee5$(_context5) {\n\t                                    while (1) {\n\t                                        switch (_context5.prev = _context5.next) {\n\t                                            case 0:\n\t                                                _context5.next = 2;\n\t                                                return getJsonDataStorageConnection();\n\t\n\t                                            case 2:\n\t                                                db = _context5.sent;\n\t                                                transaction = db.transaction([storeName]);\n\t                                                objectStore = transaction.objectStore(storeName);\n\t                                                request = objectStore.get(name);\n\t\n\t                                                request.onsuccess = function (event) {\n\t                                                    if (event.target.result !== undefined) {\n\t                                                        resolve(event.target.result.json);\n\t                                                    } else {\n\t                                                        //resolve(null);\n\t                                                        reject(event.target.error);\n\t                                                    }\n\t                                                };\n\t                                                request.onerror = function (event) {\n\t                                                    reject(event.target.error);\n\t                                                };\n\t\n\t                                            case 8:\n\t                                            case \"end\":\n\t                                                return _context5.stop();\n\t                                        }\n\t                                    }\n\t                                }, _callee5, this);\n\t                            }));\n\t\n\t                            return function (_x6, _x7) {\n\t                                return _ref6.apply(this, arguments);\n\t                            };\n\t                        }());\n\t                        _context6.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context6.abrupt(\"return\", _context6.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context6.stop();\n\t                }\n\t            }\n\t        }, _callee6, this);\n\t    }));\n\t\n\t    return function getItem(_x5) {\n\t        return _ref5.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\t//import ApiConfig from './config';\n\t\n\tvar dbName = \"public_transport2\";\n\tvar storeName = \"json_data\";\n\t\n\tvar JsonDataStorage = function () {\n\t    function JsonDataStorage() {\n\t        _classCallCheck(this, JsonDataStorage);\n\t    }\n\t\n\t    _createClass(JsonDataStorage, null, [{\n\t        key: \"getAllStations\",\n\t        value: function () {\n\t            var _ref7 = _asyncToGenerator(_regenerator2.default.mark(function _callee7() {\n\t                return _regenerator2.default.wrap(function _callee7$(_context7) {\n\t                    while (1) {\n\t                        switch (_context7.prev = _context7.next) {\n\t                            case 0:\n\t                                _context7.prev = 0;\n\t                                _context7.next = 3;\n\t                                return getItem('allStations');\n\t\n\t                            case 3:\n\t                                return _context7.abrupt(\"return\", _context7.sent);\n\t\n\t                            case 6:\n\t                                _context7.prev = 6;\n\t                                _context7.t0 = _context7[\"catch\"](0);\n\t                                return _context7.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context7.stop();\n\t                        }\n\t                    }\n\t                }, _callee7, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllStations() {\n\t                return _ref7.apply(this, arguments);\n\t            }\n\t\n\t            return getAllStations;\n\t        }()\n\t    }, {\n\t        key: \"getAllRoutes\",\n\t        value: function () {\n\t            var _ref8 = _asyncToGenerator(_regenerator2.default.mark(function _callee8() {\n\t                return _regenerator2.default.wrap(function _callee8$(_context8) {\n\t                    while (1) {\n\t                        switch (_context8.prev = _context8.next) {\n\t                            case 0:\n\t                                _context8.prev = 0;\n\t                                _context8.next = 3;\n\t                                return getItem('allRoutes');\n\t\n\t                            case 3:\n\t                                return _context8.abrupt(\"return\", _context8.sent);\n\t\n\t                            case 6:\n\t                                _context8.prev = 6;\n\t                                _context8.t0 = _context8[\"catch\"](0);\n\t                                return _context8.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context8.stop();\n\t                        }\n\t                    }\n\t                }, _callee8, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllRoutes() {\n\t                return _ref8.apply(this, arguments);\n\t            }\n\t\n\t            return getAllRoutes;\n\t        }()\n\t    }, {\n\t        key: \"getAllTimetables\",\n\t        value: function () {\n\t            var _ref9 = _asyncToGenerator(_regenerator2.default.mark(function _callee9() {\n\t                return _regenerator2.default.wrap(function _callee9$(_context9) {\n\t                    while (1) {\n\t                        switch (_context9.prev = _context9.next) {\n\t                            case 0:\n\t                                _context9.prev = 0;\n\t                                _context9.next = 3;\n\t                                return getItem('allTimetables');\n\t\n\t                            case 3:\n\t                                return _context9.abrupt(\"return\", _context9.sent);\n\t\n\t                            case 6:\n\t                                _context9.prev = 6;\n\t                                _context9.t0 = _context9[\"catch\"](0);\n\t                                return _context9.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context9.stop();\n\t                        }\n\t                    }\n\t                }, _callee9, this, [[0, 6]]);\n\t            }));\n\t\n\t            function getAllTimetables() {\n\t                return _ref9.apply(this, arguments);\n\t            }\n\t\n\t            return getAllTimetables;\n\t        }()\n\t    }, {\n\t        key: \"pushAllStations\",\n\t        value: function () {\n\t            var _ref10 = _asyncToGenerator(_regenerator2.default.mark(function _callee10(allStationsJson) {\n\t                return _regenerator2.default.wrap(function _callee10$(_context10) {\n\t                    while (1) {\n\t                        switch (_context10.prev = _context10.next) {\n\t                            case 0:\n\t                                _context10.prev = 0;\n\t                                _context10.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allStations',\n\t                                    json: allStationsJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context10.abrupt(\"return\", _context10.sent);\n\t\n\t                            case 6:\n\t                                _context10.prev = 6;\n\t                                _context10.t0 = _context10[\"catch\"](0);\n\t                                return _context10.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context10.stop();\n\t                        }\n\t                    }\n\t                }, _callee10, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllStations(_x8) {\n\t                return _ref10.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllStations;\n\t        }()\n\t    }, {\n\t        key: \"pushAllRoutes\",\n\t        value: function () {\n\t            var _ref11 = _asyncToGenerator(_regenerator2.default.mark(function _callee11(allRoutesJson) {\n\t                return _regenerator2.default.wrap(function _callee11$(_context11) {\n\t                    while (1) {\n\t                        switch (_context11.prev = _context11.next) {\n\t                            case 0:\n\t                                _context11.prev = 0;\n\t                                _context11.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allRoutes',\n\t                                    json: allRoutesJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context11.abrupt(\"return\", _context11.sent);\n\t\n\t                            case 6:\n\t                                _context11.prev = 6;\n\t                                _context11.t0 = _context11[\"catch\"](0);\n\t                                return _context11.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context11.stop();\n\t                        }\n\t                    }\n\t                }, _callee11, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllRoutes(_x9) {\n\t                return _ref11.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllRoutes;\n\t        }()\n\t    }, {\n\t        key: \"pushAllTimetables\",\n\t        value: function () {\n\t            var _ref12 = _asyncToGenerator(_regenerator2.default.mark(function _callee12(allTimetablesJson) {\n\t                return _regenerator2.default.wrap(function _callee12$(_context12) {\n\t                    while (1) {\n\t                        switch (_context12.prev = _context12.next) {\n\t                            case 0:\n\t                                _context12.prev = 0;\n\t                                _context12.next = 3;\n\t                                return tryPush({\n\t                                    name: 'allTimetables',\n\t                                    json: allTimetablesJson\n\t                                });\n\t\n\t                            case 3:\n\t                                return _context12.abrupt(\"return\", _context12.sent);\n\t\n\t                            case 6:\n\t                                _context12.prev = 6;\n\t                                _context12.t0 = _context12[\"catch\"](0);\n\t                                return _context12.abrupt(\"return\", null);\n\t\n\t                            case 9:\n\t                            case \"end\":\n\t                                return _context12.stop();\n\t                        }\n\t                    }\n\t                }, _callee12, this, [[0, 6]]);\n\t            }));\n\t\n\t            function pushAllTimetables(_x10) {\n\t                return _ref12.apply(this, arguments);\n\t            }\n\t\n\t            return pushAllTimetables;\n\t        }()\n\t    }]);\n\t\n\t    return JsonDataStorage;\n\t}();\n\t\n\texports.default = JsonDataStorage;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t        value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//import Points from './points';\n\t//import IgnoringFragments from './ignoringFragments';\n\t\n\tvar OptimalRoute = function () {\n\t        function OptimalRoute(myPoints, stationsList, /*nowPos, needPos,*/time, types, goingSpeed, dopTimeMinutes, ignoringRoutesAdd, ignoringList) {\n\t                _classCallCheck(this, OptimalRoute);\n\t\n\t                if (ignoringRoutesAdd != null) this.ignoringRoutes = ignoringRoutesAdd;else this.ignoringRoutes = [];\n\t\n\t                this.points = [];\n\t\n\t                //this.needPos = needPos;\n\t                //this.nowPos = nowPos;\n\t                this.goingSpeed = goingSpeed;\n\t                this.time = time;\n\t                var reservedTimeSeconds = 60 * dopTimeMinutes;\n\t\n\t                this.types = types;\n\t\n\t                this.myIgnoringFragments = null;\n\t                //if (ignoringList != null) this.myIgnoringFragments = new IgnoringFragments(ignoringList);\n\t                //else this.myIgnoringFragments = new IgnoringFragments();\n\t\n\t                //var myPoints = new Points(nowPos, needPos);\n\t\n\t                myPoints.fillStartData(stationsList, goingSpeed, reservedTimeSeconds, this.myIgnoringFragments);\n\t\n\t                // Находим кратчайшие пути до всех вершин:\n\t                myPoints.countShortWay(this.ignoringRoutes, this.myIgnoringFragments, time, types, goingSpeed, reservedTimeSeconds);\n\t\n\t                var tmpP = myPoints.finalPoint;\n\t                this.points.push(tmpP.toString()); ////\n\t                while (tmpP.previousPoint != null) {\n\t                        tmpP = tmpP.previousPoint; //\n\t                        this.points.push(tmpP.toString());\n\t                        if (tmpP.previousPoint == null && tmpP.coords !== myPoints.startPoint.coords) throw new Error(\"Где-то удалилась часть маршрута...\");\n\t                }\n\t\n\t                this.totalTimeSeconds = myPoints.finalPoint.totalTimeSeconds;\n\t                this.totalGoingTime = myPoints.finalPoint.getTotalGoingTime();\n\t                this.totalTransportChangingCount = myPoints.finalPoint.getTotalTransportChangingCount();\n\t\n\t                this.myPoints = myPoints;\n\t\n\t                this.isVisited = false;\n\t        }\n\t\n\t        _createClass(OptimalRoute, [{\n\t                key: \"setVisited\",\n\t                value: function setVisited() {\n\t                        this.isVisited = true;\n\t                }\n\t        }]);\n\t\n\t        return OptimalRoute;\n\t}();\n\t\n\texports.default = OptimalRoute;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _optimalRoute = __webpack_require__(7);\n\t\n\tvar _optimalRoute2 = _interopRequireDefault(_optimalRoute);\n\t\n\tvar _optimalWay = __webpack_require__(9);\n\t\n\tvar _optimalWay2 = _interopRequireDefault(_optimalWay);\n\t\n\tvar _points = __webpack_require__(11);\n\t\n\tvar _points2 = _interopRequireDefault(_points);\n\t\n\tvar _geoCoords = __webpack_require__(2);\n\t\n\tvar _geoCoords2 = _interopRequireDefault(_geoCoords);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //import IgnoringFragments from './ignoringFragments';\n\t\n\t\n\tvar distance = _geoCoords2.default.distance;\n\tfunction getStationsAround(allStations, coords, radius) {\n\t    var result = [];\n\t    for (var i = 0, n = allStations.length, s = allStations[0]; i < n; s = allStations[++i]) {\n\t        if (s != null && distance(s.coords, coords) < radius) result.push(s);\n\t    }\n\t    return result;\n\t}\n\t\n\tvar OptimalRoutesCollection = function (_Array) {\n\t    _inherits(OptimalRoutesCollection, _Array);\n\t\n\t    /*getOptimalWays() {\r\n\t        var result = [];\r\n\t        for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n\t            result.push(new OptimalWay(r));\r\n\t        }\r\n\t        return result;\r\n\t    }*/\n\t    /*selectOptimalRouteWithMinimalMark() {\r\n\t        var p = null;\r\n\t        for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n\t            if (!(t.isVisited)) {\r\n\t                p = t;\r\n\t                for (t = this[++i]; i < n; t = this[++i]) {\r\n\t                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n\t                        p = t;\r\n\t                    }\r\n\t                }\r\n\t                return p;\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    }*/\n\t    function OptimalRoutesCollection(allStations, nowPos, needPos, time, types, speed, dopTimeMinutes) {\n\t        _classCallCheck(this, OptimalRoutesCollection);\n\t\n\t        var _this = _possibleConstructorReturn(this, (OptimalRoutesCollection.__proto__ || Object.getPrototypeOf(OptimalRoutesCollection)).call(this));\n\t\n\t        _this.getOptimalWays = function () {\n\t            var result = [];\n\t            for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\n\t                result.push(new _optimalWay2.default(r));\n\t            }\n\t            return result;\n\t        };\n\t        _this.selectOptimalRouteWithMinimalMark = function () {\n\t            var p = null;\n\t            for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\n\t                if (!t.isVisited) {\n\t                    p = t;\n\t                    for (t = this[++i]; i < n; t = this[++i]) {\n\t                        if (!t.isVisited && t.totalTimeSeconds < p.totalTimeSeconds) {\n\t                            p = t;\n\t                        }\n\t                    }\n\t                    return p;\n\t                }\n\t            }\n\t            return null;\n\t        };\n\t\n\t        var myPoints = new _points2.default(nowPos, needPos);\n\t        // Получим \"начальный\" список станций:\n\t        var stationsList = getStationsAround(allStations, nowPos, distance(nowPos, needPos));\n\t\n\t        _this.push(new _optimalRoute2.default(myPoints, stationsList, /*nowPos, needPos,*/time, types, speed, dopTimeMinutes));\n\t\n\t        var ignoringRoutes = [];\n\t\n\t        //var ignoringFragments = new IgnoringFragments();\n\t\n\t        for (var selectedOptimalRoute = _this[0]; selectedOptimalRoute != null; selectedOptimalRoute.setVisited(), selectedOptimalRoute = _this.selectOptimalRouteWithMinimalMark()) {\n\t            var ddd = 0.25;\n\t\n\t            ignoringRoutes = [];\n\t            // Проходим по всем ребрам выбранного пути и строим новые маршруты при удалении ребер:\n\t            for (var tmpP = selectedOptimalRoute.myPoints.finalPoint; tmpP.previousPoint != null; tmpP = tmpP.previousPoint) {\n\t                if (tmpP.fromWhichRoute != null && !ignoringRoutes.includes(tmpP.fromWhichRoute)) ignoringRoutes.push(tmpP.fromWhichRoute);\n\t            }\n\t            for (var i = 0, n = ignoringRoutes.length, r = ignoringRoutes[0]; i < n; r = ignoringRoutes[++i]) {\n\t                if (selectedOptimalRoute.ignoringRoutes.includes(r)) continue;\n\t                var ignoringRoutesAdd = [];\n\t                ignoringRoutesAdd = ignoringRoutesAdd.concat(selectedOptimalRoute.ignoringRoutes);\n\t                ignoringRoutesAdd.push(r);\n\t                myPoints = new _points2.default(nowPos, needPos);\n\t                var tmpOptimalRoute = new _optimalRoute2.default(myPoints, stationsList, /*nowPos, needPos,*/time, types, speed, dopTimeMinutes, ignoringRoutesAdd);\n\t\n\t                if (tmpOptimalRoute.totalTimeSeconds <= _this[0].totalTimeSeconds / ddd) {\n\t                    var tmpJSON = JSON.stringify(tmpOptimalRoute.points);\n\t                    var ok = false;\n\t                    for (var j = 0, m = _this.length, opt = _this[0]; j < m; opt = _this[++j]) {\n\t                        if (JSON.stringify(opt.points) === tmpJSON) {\n\t                            ok = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (ok) continue;\n\t                    _this.push(tmpOptimalRoute);\n\t                }\n\t            }\n\t        }\n\t        return _this;\n\t    }\n\t\n\t    return OptimalRoutesCollection;\n\t}(Array);\n\t\n\texports.default = OptimalRoutesCollection;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _wayPoint = __webpack_require__(12);\n\t\n\tvar _wayPoint2 = _interopRequireDefault(_wayPoint);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar OptimalWay = function OptimalWay(optimalRoute) {\n\t    _classCallCheck(this, OptimalWay);\n\t\n\t    this.totalTimeSeconds = optimalRoute.totalTimeSeconds;\n\t    this.totalGoingTimeSeconds = optimalRoute.totalGoingTime;\n\t    this.totalTransportChangingCount = optimalRoute.totalTransportChangingCount;\n\t    this.points = [];\n\t\n\t    for (var tmpP = optimalRoute.myPoints.finalPoint; tmpP != null; tmpP = tmpP.previousPoint) {\n\t        this.points.push(new _wayPoint2.default(tmpP.totalTimeSeconds, tmpP.station, tmpP.fromWhichRoute, tmpP.coords));\n\t    }\n\t    this.points.reverse();\n\t};\n\t\n\texports.default = OptimalWay;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Point = function () {\n\t    function Point(totalTimeSeconds, station_or_crds, fromWhichStation, fromWhichRoute) {\n\t        _classCallCheck(this, Point);\n\t\n\t        if (station_or_crds.hashcode !== undefined) {\n\t            this.station = station_or_crds;\n\t            this.stationCode = station_or_crds.hashcode;\n\t            station_or_crds.point = this;\n\t            this.coords = station_or_crds.coords;\n\t        } else {\n\t            this.coords = station_or_crds;\n\t            this.station = null;\n\t            this.stationCode = null;\n\t        }\n\t        this.totalTimeSeconds = totalTimeSeconds;\n\t        this.fromWhichStation = fromWhichStation;\n\t        this.fromWhichRoute = fromWhichRoute;\n\t\n\t        this.isVisited = false;\n\t\n\t        this.previousPoint = null;\n\t    }\n\t\n\t    _createClass(Point, [{\n\t        key: \"tryUpdate\",\n\t        value: function tryUpdate(totalTimeSeconds, previousPoint, fromWhichStation, fromWhichRoute) {\n\t            if (totalTimeSeconds < this.totalTimeSeconds) {\n\t                this.fromWhichRoute = fromWhichRoute;\n\t                this.previousPoint = previousPoint;\n\t                this.totalTimeSeconds = totalTimeSeconds;\n\t                this.fromWhichStation = fromWhichStation;\n\t\n\t                return true;\n\t            }\n\t            return false;\n\t        }\n\t    }, {\n\t        key: \"setVisited\",\n\t        value: function setVisited() {\n\t            this.isVisited = true;\n\t        }\n\t    }, {\n\t        key: \"toString\",\n\t        value: function toString() {\n\t            var to, tr; //, from, p;\n\t            //if (this.fromWhichStation != null) from = this.fromWhichStation.name;\n\t            //else from = \"null\";\n\t            if (this.station != null) to = this.station.name;else to = \"null\";\n\t            if (this.fromWhichRoute != null) tr = this.fromWhichRoute.type + \" \" + this.fromWhichRoute.number + \" \" + this.fromWhichRoute.from + \" - \" + this.fromWhichRoute.to;else tr = \"пешком\";\n\t            //if (this.previousPoint != null) p = this.previousPoint.toString();\n\t            //else p = \"null\";\n\t            return (/*p+\" -->> */\"(\" + this.totalTimeSeconds + \") \" + to + \" (\" + tr + \")\"\n\t            ); // from \" + from + \" to\n\t        }\n\t    }, {\n\t        key: \"getTotalGoingTime\",\n\t        value: function getTotalGoingTime() {\n\t            var goingTime = 0;\n\t            var tmpP = this;\n\t            //this.points.Add(tmpP.ToString());\n\t            while (tmpP.previousPoint != null) {\n\t                if (tmpP.fromWhichRoute == null /*&& tmpP.fromWhichRoute.hashcode == null*/) goingTime += tmpP.totalTimeSeconds - tmpP.previousPoint.totalTimeSeconds;\n\t                tmpP = tmpP.previousPoint;\n\t            }\n\t            return goingTime;\n\t        }\n\t    }, {\n\t        key: \"getTotalTransportChangingCount\",\n\t        value: function getTotalTransportChangingCount() {\n\t            var result = 0;\n\t            var tmpP = this;\n\t            //this.points.Add(tmpP.ToString());\n\t            while (tmpP.previousPoint != null) {\n\t                if (tmpP.fromWhichRoute != null && tmpP.fromWhichRoute.hashcode != null && tmpP.fromWhichRoute !== tmpP.previousPoint.fromWhichRoute) result++;\n\t                tmpP = tmpP.previousPoint;\n\t            }\n\t            return result;\n\t        }\n\t    }]);\n\t\n\t    return Point;\n\t}();\n\t\n\texports.default = Point;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _point = __webpack_require__(10);\n\t\n\tvar _point2 = _interopRequireDefault(_point);\n\t\n\tvar _geoCoords = __webpack_require__(2);\n\t\n\tvar _geoCoords2 = _interopRequireDefault(_geoCoords);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar distance = _geoCoords2.default.distance;\n\t\n\tfunction getTimeForGoingTo(distance, goingSpeed) {\n\t    return Math.floor(distance / (goingSpeed / 3.6));\n\t}\n\t\n\tvar TableType = { table: 1, periodic: 2 };\n\t\n\tvar Points = function () {\n\t    function Points(nowPos, needPos) {\n\t        _classCallCheck(this, Points);\n\t\n\t        this.collection = [];\n\t        this.startPoint = new _point2.default(0, nowPos, null, null);\n\t        this.finalPoint = new _point2.default(2160000000, needPos, null, null);\n\t        this.currentSelectedPoint = null;\n\t    }\n\t\n\t    _createClass(Points, [{\n\t        key: 'findElement',\n\t        value: function findElement(station_or_point) {\n\t            if (station_or_point.hashcode != null) {\n\t                if (station_or_point.point != null) return station_or_point.point;\n\t                var newCreatdPoint = new _point2.default(2160000000, station_or_point, null, null);\n\t                this.collection.push(newCreatdPoint);\n\t                return newCreatdPoint;\n\t            } else {\n\t                for (var i = 0, n = this.collection.length, p = this.collection[0]; i < n; p = this.collection[++i]) {\n\t                    if (p.coords === station_or_point.coords && p.stationCode === station_or_point.stationCode) return p;\n\t                }\n\t                return null;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'fillStartData',\n\t        value: function fillStartData(stationsList, goingSpeed, reservedTime, myIgnoringFragments) {\n\t            this.finalPoint.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, this.finalPoint.coords), goingSpeed) + 1800 /*+ TimeSpan.FromMinutes(20)*/, this.startPoint, null, null);\n\t            for (var i = 0, n = stationsList.length, st = stationsList[0]; i < n; st = stationsList[++i]) {\n\t                if (myIgnoringFragments != null && myIgnoringFragments.contains(st.hashcode, null, null)) continue;\n\t\n\t                var add = new _point2.default(2160000000, st, null, null);\n\t                add.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, st.coords), goingSpeed) + reservedTime, this.startPoint, null, null);\n\t                this.collection.push(add);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getNextUnvisitedPoint',\n\t        value: function getNextUnvisitedPoint() {\n\t            if (this.currentSelectedPoint != null) this.currentSelectedPoint.setVisited();\n\t\n\t            this.currentSelectedPoint = this.selectPointWithMinimalMark();\n\t\n\t            return this.currentSelectedPoint;\n\t        }\n\t    }, {\n\t        key: 'selectPointWithMinimalMark',\n\t        value: function selectPointWithMinimalMark() {\n\t            var p = null;\n\t            for (var i = 0, n = this.collection.length, t = this.collection[0]; i < n; t = this.collection[++i]) {\n\t                if (!t.isVisited) {\n\t                    p = t;\n\t                    for (t = this.collection[++i]; i < n; t = this.collection[++i]) {\n\t                        if (!t.isVisited && t.totalTimeSeconds < p.totalTimeSeconds) {\n\t                            p = t;\n\t                        }\n\t                    }\n\t                    return p;\n\t                }\n\t            }\n\t            return null;\n\t        }\n\t    }, {\n\t        key: 'countShortWay',\n\t        value: function countShortWay(ignoringRoutes, myIgnoringFragments, time, types, speed, reservedTime) {\n\t            //TimeSpan overLimitResedvedTime = TimeSpan.FromMinutes(20);\n\t\n\t            for (var selectedPoint = this.getNextUnvisitedPoint(), selectedPointStation, selectedPointTotalTimeSeconds, selectedPointStationHashcode, selectedPointFromWhichRoute, momentWhenComingToStation, routesOnStation, selectedPointCoords; selectedPoint != null; selectedPoint = this.getNextUnvisitedPoint()) {\n\t                //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t                selectedPointTotalTimeSeconds = selectedPoint.totalTimeSeconds;\n\t                if (selectedPointTotalTimeSeconds > this.finalPoint.totalTimeSeconds /* + overLimitResedvedTime*/) //... Пропускаем и удаляем, если значение метки превышает минимальное время до пункта назначения.\n\t                    {\n\t                        break;\n\t                    }\n\t                selectedPointStation = selectedPoint.station;\n\t                selectedPointStationHashcode = selectedPointStation.hashcode;\n\t                selectedPointFromWhichRoute = selectedPoint.fromWhichRoute;\n\t                if (selectedPointStation != null) {\n\t                    // Момент, когда мы прибудем на остановку:\n\t                    momentWhenComingToStation = time + selectedPointTotalTimeSeconds;\n\t                    // Загружаем маршруты, проходящие через остановку:\n\t                    routesOnStation = null; // = routesOnStation = Database.GetRoutesOnStation(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);\n\t                    if (selectedPointStation.routes != null) routesOnStation = selectedPointStation.routes;else continue;\n\t\n\t                    for (var i = 0, n = routesOnStation.length, selectedRoute = routesOnStation[0], nextStation; i < n; selectedRoute = routesOnStation[++i]) {\n\t                        if (ignoringRoutes != null && ignoringRoutes.includes(selectedRoute)) continue;\n\t                        if (types.includes(selectedRoute.type)) {\n\t                            // Следующая остановка у данного тран спорта:\n\t                            nextStation = selectedRoute.getNextStation(selectedPointStation);\n\t\n\t                            /*// Код остановки, на которую попадем на данном транспорте:\r\n\t                            string nextCode = selectedRoute.getNextStationCodeAfter(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);*/\n\t                            if (nextStation /*nextCode*/ != null) // Если остановка не является конечной, то:\n\t                                {\n\t                                    // Загружаем расписание:\n\t                                    var table = selectedRoute.getTimetable(selectedPointStation); //Database.getTimetable(selectedPointStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\t                                    // Блокируем попытку попасть указанным транспортом на указанную остановку:\n\t                                    if (myIgnoringFragments != null && myIgnoringFragments.contains(nextStation.hashcode /*nextCode*/, selectedRoute.hashcode, selectedPointStationHashcode)) continue;\n\t\n\t                                    if (table.type === TableType.table) // Если это точное расписание, то:\n\t                                        {\n\t                                            // Минимальный начальный момент, с который можно начинать ожидать посадку:\n\t                                            var momentWhenAskingForGoing = momentWhenComingToStation;\n\t\n\t                                            // Резервируем дополнительное время, если будем пересаживаться на другой маршрут:\n\t                                            //if (selectedPoint.RouteCode == null || selectedPoint.RouteCode != selectedRoute.hashcode) momentWhenAskingForGoing += reservedTime;\n\t                                            if (selectedPointFromWhichRoute != null && selectedPointFromWhichRoute !== selectedRoute) momentWhenAskingForGoing += reservedTime;\n\t\n\t                                            // Подсчитываем, сколько будем ожидать этот транспорт на остановке:\n\t                                            var waitingTime = table.findTimeAfter(momentWhenAskingForGoing);\n\t\n\t                                            // Момент, когда мы сядем в транспорт:\n\t                                            var momentWhenSitInTransport = momentWhenAskingForGoing + waitingTime;\n\t\n\t                                            /*// Следующая остановка у данного транспорта:\r\n\t                                            Station nextStation = Database.GetStationByHashcode(nextCode, databaseMysqlConnection, canReadDataFromLocalCopy: true);*/\n\t\n\t                                            // И соответствующее расписание на этой остановке:\n\t                                            var tbl = selectedRoute.getTimetable(nextStation); //Database.getTimetable(nextStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\t\n\t                                            // (сколько будем ехать до следующей остановки):\n\t                                            var goingOnTransportTime = tbl.findTimeAfter(momentWhenSitInTransport);\n\t\n\t                                            // Метка времени:\n\t                                            var onNextPointtotalTimeSeconds = momentWhenSitInTransport - momentWhenComingToStation + goingOnTransportTime + selectedPointTotalTimeSeconds;\n\t\n\t                                            if (this.findElement(nextStation).tryUpdate(onNextPointtotalTimeSeconds, selectedPoint, selectedPointStation, selectedRoute)) {\n\t                                                //console.log(\"upd...\");\n\t                                            }\n\t                                        } else if (table.type === TableType.periodic) {\n\t                                        throw new Error();\n\t                                    }\n\t                                }\n\t                        }\n\t                    }\n\t                }\n\t                selectedPointCoords = selectedPoint.coords;\n\t                // Нет смысла идти пешком \"транзитом\" через остановку:\n\t                if (selectedPointFromWhichRoute == null) continue;\n\t\n\t                // Попробуем пройти пешком до других \"вершин\":\n\t                for (var j = 0, m = this.collection.length, p = this.collection[0], distanceToSelectedPoint, goingTime, newTime; j < m; p = this.collection[++j]) {\n\t                    if (!p.isVisited && p !== selectedPoint) {\n\t                        // Блокируем попытку дойти пешком до указанной остановки:\n\t                        if (myIgnoringFragments != null && myIgnoringFragments.contains(p.stationCode, null, selectedPointStationHashcode)) continue;\n\t\n\t                        distanceToSelectedPoint = distance(selectedPointCoords, p.coords);\n\t\n\t                        goingTime = getTimeForGoingTo(distanceToSelectedPoint, speed /*, true, sp*/);\n\t\n\t                        newTime = selectedPointTotalTimeSeconds + goingTime + reservedTime;\n\t                        /*if (p != myFinishPoint)*/ // newTime += reservedTime;\n\t\n\t                        if (p.tryUpdate(newTime, selectedPoint, selectedPointStation, null)) {\n\t                            //console.log(\"upd...\");\n\t                        }\n\t                    }\n\t                }if (myIgnoringFragments != null && myIgnoringFragments.contains(null, null, selectedPointStationHashcode)) continue;\n\t\n\t                var tryingNewTime = selectedPointTotalTimeSeconds + getTimeForGoingTo(distance(selectedPointCoords, this.finalPoint.coords), speed);\n\t                if (this.finalPoint.tryUpdate(tryingNewTime, selectedPoint, selectedPointStation, null)) {\n\t                    //console.log(\"upd: \" + selectedPointStation.hashcode);\n\t                }\n\t            }\n\t\n\t            // Сокращаем время ходьбы пешком до минимума и избавляемся от \"бессмысленных\" пересадок, сохраняя общее время неизменным:\n\t            var currentPoint = this.finalPoint.previousPoint;\n\t            while (currentPoint !== this.startPoint) {\n\t                var r = currentPoint.fromWhichRoute;\n\t                if (r != null) {\n\t                    var previousPoint = currentPoint.previousPoint;\n\t                    if (previousPoint !== this.startPoint && previousPoint.fromWhichRoute !== r) // Если на предыдущую остановку мы добрались другим транспортом, то:\n\t                        {\n\t                            var previousRouteStation = r.getPreviousStation(previousPoint.station);\n\t                            if (previousRouteStation != null) {\n\t                                var point = previousRouteStation.point;\n\t                                if (point != null && point.isVisited) {\n\t                                    var ttt = r.getTimetable(previousRouteStation);\n\t                                    if (ttt != null) {\n\t                                        //var ddd = time + previousPoint.totalTimeSeconds;\n\t                                        //var moment = r.getTimetable(currentPoint.station).findTimeAfter(ddd);\n\t                                        //var tmp_time = ttt.findTimeBefore(ddd + moment);\n\t\n\t                                        //var momentArriveOnCurrent = previousPoint.totalTimeSeconds + moment;\n\t                                        //var momentSittingOnPrevious = momentArriveOnCurrent + tmp_time;\n\t                                        /*bool bbb = point.fromWhichRoute != null && point.fromWhichRoute.getTimetable(point.station) != null && point.fromWhichRoute.getTimetable(point.station).findTimeAfter(time + point.totalTimeSeconds) <= previousPoint.totalTimeSeconds + moment + tmp_time;\r\n\t                                        if (bbb)\r\n\t                                        {\r\n\t                                            previousPoint.fromWhichRoute = r;\r\n\t                                            previousPoint.previousPoint = point;////!bbb && point.totalTimeSeconds <= momentSittingOnPrevious &&\r\n\t                                        }\r\n\t                                        else */\n\t                                        if ( /*point.totalGoingTime>=previousPoint.totalGoingTime || */point.totalTimeSeconds <= previousPoint.totalTimeSeconds /* && point.totalGoingTime <= previousPoint.totalGoingTime*/) {\n\t                                                previousPoint.fromWhichRoute = r;\n\t                                                previousPoint.previousPoint = point;\n\t                                            }\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                }\n\t                currentPoint = currentPoint.previousPoint;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return Points;\n\t}();\n\t\n\texports.default = Points;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar WayPoint = function WayPoint(time, station, route, coords) {\n\t    _classCallCheck(this, WayPoint);\n\t\n\t    this.time = time;\n\t    this.station = station == null ? null : { hashcode: station.hashcode, name: station.name, routes: null, Coords: { lat: station.coords.lat, lng: station.coords.lng } };\n\t    this.route = route == null ? null : { vehicles: [], gpsTrack: null, hashcode: route.hashcode, number: route.number, type: route.type, from: route.from, to: route.to, owner: \"\", stations: null, timetables: null, stationsJSON: null };\n\t    this.coords = coords;\n\t};\n\t\n\texports.default = WayPoint;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Initailize.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tfunction getNextStation(currentStation) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n\t            if (this.stations[j][t] === currentStation) {\n\t                if (t + 1 !== nn) return this.stations[j][t + 1];else return null;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction getPreviousStation(currentStation) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n\t            if (this.stations[j][t] === currentStation) {\n\t                if (t !== nn) return this.stations[j][t - 1];else return null;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction getTimetable(station) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var i = 0, n = this.stations[j].length; i < n; i++) {\n\t            if (this.stations[j][i] === station) {\n\t                return this.timetables[j][i];\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction findTimeAfter(time) {\n\t    var dateTmp = new Date();\n\t    dateTmp.setMinutes(0);\n\t    dateTmp.setHours(0);\n\t    dateTmp.setSeconds(time);\n\t    var day = dateTmp.getDay();\n\t    //foreach (Table t in table)\n\t    for (var kkk = 0, mnkk = this.table.length, t = this.table[0]; kkk < mnkk; t = this.table[++kkk]) {\n\t        if (t.days.includes(day)) {\n\t\n\t            //foreach (SimpleTime st in t.times)\n\t            for (var iik = 0, mnii = t.times.length, st = t.times[0], stTime; iik < mnii; st = t.times[++iik]) {\n\t                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n\t                //\n\t                stTime = st.hour * 3600 + st.minute * 60;\n\t                if (stTime >= time /*.Second + time.Minute * 60 + time.Hour * 3600*/ /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n\t                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n\t                        return stTime - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/;\n\t                    }\n\t            }\n\t            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/ + 86400;\n\t            break;\n\t        }\n\t    }\n\t    return 2160000000;\n\t    //throw new Exception();\n\t}\n\tfunction findTimeBefore(time) {\n\t    var dateTmp = new Date();\n\t    dateTmp.setMinutes(0);\n\t    dateTmp.setHours(0);\n\t    dateTmp.setSeconds(time);\n\t    var day = dateTmp.getDay();\n\t    for (var kkk = 0, mnkk = this.table.length, t = this.table[0], ok = false, st; kkk < mnkk; t = this.table[++kkk]) {\n\t        if (t.days.includes(day)) {\n\t            ok = false;\n\t            st = null;\n\t            for (var iik = 0, mnii = t.times.length, stt = t.times[0]; iik < mnii; stt = t.times[++iik]) {\n\t                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n\t                //\n\t                if (stt.hour * 3600 + stt.minute * 60 <= time /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n\t                        ok = true;\n\t                        st = stt;\n\t                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n\t                    } else break;\n\t            }\n\t            if (ok) return st.hour * 3600 + st.minute * 60 - time;\n\t            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time - 86400;\n\t            break;\n\t        }\n\t    }\n\t    return 0; //TimeSpan.FromDays(0/*-25000*/);\n\t    //throw new Exception();\n\t}\n\t\n\tfunction initialize(allStations, allRoutes, allTimetables) {\n\t    //alert(allStations.length);\n\t    //alert(allRoutes.length);\n\t    //alert(allTimetables.length);\n\t\n\t    console.log(\"Start initializing...\");\n\t    var startInitializingMoment = Date.now();\n\t\n\t    var tmpUsedStations = [];\n\t\n\t    function bindRoutesStationsTimetables(station, tmpArr, tabArr, rr) {\n\t        if (station.routes == null) station.routes = [];\n\t        //console.log(station.routes);//!!!\n\t        if (!station.routes.includes(rr)) station.routes.push(rr);\n\t        tmpArr.push(station);\n\t\n\t        var tmp = allTimetables.find(function (element, index, array) {\n\t            return element.stationCode === station.hashcode && element.routeCode === rr.hashcode;\n\t        });\n\t        var tmpTab = tmp == null ? null : tmp;\n\t\n\t        tabArr.push(tmpTab);\n\t    }\n\t\n\t    for (var i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\n\t        if (currentStation.routesCodes == null || currentStation.routesCodes.length === 0) {\n\t            allStations.splice(i, 1);\n\t            n = allStations.length;\n\t        } else i++;\n\t    }\n\t\n\t    for (var _i = 0, _n = allRoutes.length, rr = allRoutes[0]; _i < _n; rr = allRoutes[++_i]) {\n\t\n\t        rr.getNextStation = getNextStation;\n\t        rr.getPreviousStation = getPreviousStation;\n\t        rr.getTimetable = getTimetable;\n\t\n\t        if (rr.stationsCodes == null || rr.stationsCodes.length === 0) continue;\n\t\n\t        try {\n\t            //if (rr.stationsCodes[rr.stationsCodes.Length - 1] != ']') continue;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\t            rr.stations = [[], []];\n\t            rr.timetables = [[], []];\n\t\n\t            for (var index = 0, tmpArr = [], tabArr = []; index <= 1; index++) {\n\t                var rr_stationsCodes = rr.stationsCodes;\n\t                if (rr_stationsCodes[index] == null || rr_stationsCodes[index].length === 0) continue;\n\t                for (var j = 0, m = rr_stationsCodes[index].length, stationCode = rr_stationsCodes[index][0]; j < m; stationCode = rr_stationsCodes[index][++j]) {\n\t                    var tmpUsed = false;\n\t                    for (var k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\n\t                        if (station != null && station.hashcode === stationCode) {\n\t                            bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\n\t                            tmpUsed = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (!tmpUsed) {\n\t                        for (var _k = 0, _mn = allStations.length, _station = allStations[0]; _k < _mn; _station = allStations[++_k]) {\n\t                            if (_station != null && _station.hashcode === stationCode) {\n\t                                bindRoutesStationsTimetables(_station, tmpArr, tabArr, rr);\n\t                                if (!tmpUsedStations.includes(_station)) tmpUsedStations.push(_station);\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                rr.stations[index] = tmpArr;\n\t                rr.timetables[index] = tabArr;\n\t            }\n\t        } catch (ex) {\n\t            console.log(ex /*.message*/);\n\t            continue;\n\t        }\n\t    }\n\t\n\t    for (var _i2 = 0, _n2 = allTimetables.length, timetable = allTimetables[0]; _i2 < _n2; timetable = allTimetables[++_i2]) {\n\t        timetable.findTimeAfter = findTimeAfter;\n\t        timetable.findTimeBefore = findTimeBefore;\n\t    }\n\t\n\t    //...\n\t    /*\r\n\t    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n\t        if (currentStation.routes == undefined || currentStation.routes == null || currentStation.routes.length == 0) {\r\n\t            allStations.splice(i, 1);\r\n\t            n = allStations.length;\r\n\t        }\r\n\t        else i++;\r\n\t    }\r\n\t    */\n\t\n\t    console.log(\"Initialized. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t    //console.log(\"\\n\\n\" + JSON.stringify(allTimetables[0]) + \"\\n\\n\");\n\t    //alert(distance({ lat: allStations[0].xCoord, lng: allStations[0].yCoord }, { lat: allStations[5].xCoord, lng: allStations[5].yCoord }));\n\t\n\t\n\t    //for (let t = 0; t < 1000; t++) var ttt = GetStationsAround(allStations[0].coords, 30000).length;\n\t    //console.log(\"test. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t\n\t\n\t    //global.initialized = true;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End initailize.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\texports.default = initialize;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be\n\t// kept identical to the way it is obtained in runtime.js\n\tvar g =\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this;\n\t\n\t// Use `getOwnPropertyNames` because not all browsers support calling\n\t// `hasOwnProperty` on the global `self` object in a worker. See #183.\n\tvar hadRuntime = g.regeneratorRuntime &&\n\t  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\t\n\t// Save the old regeneratorRuntime in case it needs to be restored later.\n\tvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\t\n\t// Force reevalutation of runtime.js.\n\tg.regeneratorRuntime = undefined;\n\t\n\tmodule.exports = __webpack_require__(15);\n\t\n\tif (hadRuntime) {\n\t  // Restore the original runtime.\n\t  g.regeneratorRuntime = oldRuntime;\n\t} else {\n\t  // Remove the global property added by runtime.js.\n\t  try {\n\t    delete g.regeneratorRuntime;\n\t  } catch(e) {\n\t    g.regeneratorRuntime = undefined;\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {/**\n\t * Copyright (c) 2014, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n\t * additional grant of patent rights can be found in the PATENTS file in\n\t * the same directory.\n\t */\n\t\n\t!(function(global) {\n\t  \"use strict\";\n\t\n\t  var Op = Object.prototype;\n\t  var hasOwn = Op.hasOwnProperty;\n\t  var undefined; // More compressible than void 0.\n\t  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n\t  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n\t  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n\t  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\t\n\t  var inModule = typeof module === \"object\";\n\t  var runtime = global.regeneratorRuntime;\n\t  if (runtime) {\n\t    if (inModule) {\n\t      // If regeneratorRuntime is defined globally and we're in a module,\n\t      // make the exports object identical to regeneratorRuntime.\n\t      module.exports = runtime;\n\t    }\n\t    // Don't bother evaluating the rest of this file if the runtime was\n\t    // already defined globally.\n\t    return;\n\t  }\n\t\n\t  // Define the runtime globally (as expected by generated code) as either\n\t  // module.exports (if we're in a module) or a new, empty object.\n\t  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\t\n\t  function wrap(innerFn, outerFn, self, tryLocsList) {\n\t    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n\t    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n\t    var generator = Object.create(protoGenerator.prototype);\n\t    var context = new Context(tryLocsList || []);\n\t\n\t    // The ._invoke method unifies the implementations of the .next,\n\t    // .throw, and .return methods.\n\t    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\t\n\t    return generator;\n\t  }\n\t  runtime.wrap = wrap;\n\t\n\t  // Try/catch helper to minimize deoptimizations. Returns a completion\n\t  // record like context.tryEntries[i].completion. This interface could\n\t  // have been (and was previously) designed to take a closure to be\n\t  // invoked without arguments, but in all the cases we care about we\n\t  // already have an existing method we want to call, so there's no need\n\t  // to create a new function object. We can even get away with assuming\n\t  // the method takes exactly one argument, since that happens to be true\n\t  // in every case, so we don't have to touch the arguments object. The\n\t  // only additional allocation required is the completion record, which\n\t  // has a stable shape and so hopefully should be cheap to allocate.\n\t  function tryCatch(fn, obj, arg) {\n\t    try {\n\t      return { type: \"normal\", arg: fn.call(obj, arg) };\n\t    } catch (err) {\n\t      return { type: \"throw\", arg: err };\n\t    }\n\t  }\n\t\n\t  var GenStateSuspendedStart = \"suspendedStart\";\n\t  var GenStateSuspendedYield = \"suspendedYield\";\n\t  var GenStateExecuting = \"executing\";\n\t  var GenStateCompleted = \"completed\";\n\t\n\t  // Returning this object from the innerFn has the same effect as\n\t  // breaking out of the dispatch switch statement.\n\t  var ContinueSentinel = {};\n\t\n\t  // Dummy constructor functions that we use as the .constructor and\n\t  // .constructor.prototype properties for functions that return Generator\n\t  // objects. For full spec compliance, you may wish to configure your\n\t  // minifier not to mangle the names of these two functions.\n\t  function Generator() {}\n\t  function GeneratorFunction() {}\n\t  function GeneratorFunctionPrototype() {}\n\t\n\t  // This is a polyfill for %IteratorPrototype% for environments that\n\t  // don't natively support it.\n\t  var IteratorPrototype = {};\n\t  IteratorPrototype[iteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t\n\t  var getProto = Object.getPrototypeOf;\n\t  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\t  if (NativeIteratorPrototype &&\n\t      NativeIteratorPrototype !== Op &&\n\t      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n\t    // This environment has a native %IteratorPrototype%; use it instead\n\t    // of the polyfill.\n\t    IteratorPrototype = NativeIteratorPrototype;\n\t  }\n\t\n\t  var Gp = GeneratorFunctionPrototype.prototype =\n\t    Generator.prototype = Object.create(IteratorPrototype);\n\t  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\t  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n\t  GeneratorFunctionPrototype[toStringTagSymbol] =\n\t    GeneratorFunction.displayName = \"GeneratorFunction\";\n\t\n\t  // Helper for defining the .next, .throw, and .return methods of the\n\t  // Iterator interface in terms of a single ._invoke method.\n\t  function defineIteratorMethods(prototype) {\n\t    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n\t      prototype[method] = function(arg) {\n\t        return this._invoke(method, arg);\n\t      };\n\t    });\n\t  }\n\t\n\t  runtime.isGeneratorFunction = function(genFun) {\n\t    var ctor = typeof genFun === \"function\" && genFun.constructor;\n\t    return ctor\n\t      ? ctor === GeneratorFunction ||\n\t        // For the native GeneratorFunction constructor, the best we can\n\t        // do is to check its .name property.\n\t        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n\t      : false;\n\t  };\n\t\n\t  runtime.mark = function(genFun) {\n\t    if (Object.setPrototypeOf) {\n\t      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n\t    } else {\n\t      genFun.__proto__ = GeneratorFunctionPrototype;\n\t      if (!(toStringTagSymbol in genFun)) {\n\t        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n\t      }\n\t    }\n\t    genFun.prototype = Object.create(Gp);\n\t    return genFun;\n\t  };\n\t\n\t  // Within the body of any async function, `await x` is transformed to\n\t  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n\t  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n\t  // meant to be awaited.\n\t  runtime.awrap = function(arg) {\n\t    return { __await: arg };\n\t  };\n\t\n\t  function AsyncIterator(generator) {\n\t    function invoke(method, arg, resolve, reject) {\n\t      var record = tryCatch(generator[method], generator, arg);\n\t      if (record.type === \"throw\") {\n\t        reject(record.arg);\n\t      } else {\n\t        var result = record.arg;\n\t        var value = result.value;\n\t        if (value &&\n\t            typeof value === \"object\" &&\n\t            hasOwn.call(value, \"__await\")) {\n\t          return Promise.resolve(value.__await).then(function(value) {\n\t            invoke(\"next\", value, resolve, reject);\n\t          }, function(err) {\n\t            invoke(\"throw\", err, resolve, reject);\n\t          });\n\t        }\n\t\n\t        return Promise.resolve(value).then(function(unwrapped) {\n\t          // When a yielded Promise is resolved, its final value becomes\n\t          // the .value of the Promise<{value,done}> result for the\n\t          // current iteration. If the Promise is rejected, however, the\n\t          // result for this iteration will be rejected with the same\n\t          // reason. Note that rejections of yielded Promises are not\n\t          // thrown back into the generator function, as is the case\n\t          // when an awaited Promise is rejected. This difference in\n\t          // behavior between yield and await is important, because it\n\t          // allows the consumer to decide what to do with the yielded\n\t          // rejection (swallow it and continue, manually .throw it back\n\t          // into the generator, abandon iteration, whatever). With\n\t          // await, by contrast, there is no opportunity to examine the\n\t          // rejection reason outside the generator function, so the\n\t          // only option is to throw it from the await expression, and\n\t          // let the generator function handle the exception.\n\t          result.value = unwrapped;\n\t          resolve(result);\n\t        }, reject);\n\t      }\n\t    }\n\t\n\t    if (typeof process === \"object\" && process.domain) {\n\t      invoke = process.domain.bind(invoke);\n\t    }\n\t\n\t    var previousPromise;\n\t\n\t    function enqueue(method, arg) {\n\t      function callInvokeWithMethodAndArg() {\n\t        return new Promise(function(resolve, reject) {\n\t          invoke(method, arg, resolve, reject);\n\t        });\n\t      }\n\t\n\t      return previousPromise =\n\t        // If enqueue has been called before, then we want to wait until\n\t        // all previous Promises have been resolved before calling invoke,\n\t        // so that results are always delivered in the correct order. If\n\t        // enqueue has not been called before, then it is important to\n\t        // call invoke immediately, without waiting on a callback to fire,\n\t        // so that the async generator function has the opportunity to do\n\t        // any necessary setup in a predictable way. This predictability\n\t        // is why the Promise constructor synchronously invokes its\n\t        // executor callback, and why async functions synchronously\n\t        // execute code before the first await. Since we implement simple\n\t        // async functions in terms of async generators, it is especially\n\t        // important to get this right, even though it requires care.\n\t        previousPromise ? previousPromise.then(\n\t          callInvokeWithMethodAndArg,\n\t          // Avoid propagating failures to Promises returned by later\n\t          // invocations of the iterator.\n\t          callInvokeWithMethodAndArg\n\t        ) : callInvokeWithMethodAndArg();\n\t    }\n\t\n\t    // Define the unified helper method that is used to implement .next,\n\t    // .throw, and .return (see defineIteratorMethods).\n\t    this._invoke = enqueue;\n\t  }\n\t\n\t  defineIteratorMethods(AsyncIterator.prototype);\n\t  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t  runtime.AsyncIterator = AsyncIterator;\n\t\n\t  // Note that simple async functions are implemented on top of\n\t  // AsyncIterator objects; they just return a Promise for the value of\n\t  // the final result produced by the iterator.\n\t  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n\t    var iter = new AsyncIterator(\n\t      wrap(innerFn, outerFn, self, tryLocsList)\n\t    );\n\t\n\t    return runtime.isGeneratorFunction(outerFn)\n\t      ? iter // If outerFn is a generator, return the full iterator.\n\t      : iter.next().then(function(result) {\n\t          return result.done ? result.value : iter.next();\n\t        });\n\t  };\n\t\n\t  function makeInvokeMethod(innerFn, self, context) {\n\t    var state = GenStateSuspendedStart;\n\t\n\t    return function invoke(method, arg) {\n\t      if (state === GenStateExecuting) {\n\t        throw new Error(\"Generator is already running\");\n\t      }\n\t\n\t      if (state === GenStateCompleted) {\n\t        if (method === \"throw\") {\n\t          throw arg;\n\t        }\n\t\n\t        // Be forgiving, per 25.3.3.3.3 of the spec:\n\t        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t        return doneResult();\n\t      }\n\t\n\t      context.method = method;\n\t      context.arg = arg;\n\t\n\t      while (true) {\n\t        var delegate = context.delegate;\n\t        if (delegate) {\n\t          var delegateResult = maybeInvokeDelegate(delegate, context);\n\t          if (delegateResult) {\n\t            if (delegateResult === ContinueSentinel) continue;\n\t            return delegateResult;\n\t          }\n\t        }\n\t\n\t        if (context.method === \"next\") {\n\t          // Setting context._sent for legacy support of Babel's\n\t          // function.sent implementation.\n\t          context.sent = context._sent = context.arg;\n\t\n\t        } else if (context.method === \"throw\") {\n\t          if (state === GenStateSuspendedStart) {\n\t            state = GenStateCompleted;\n\t            throw context.arg;\n\t          }\n\t\n\t          context.dispatchException(context.arg);\n\t\n\t        } else if (context.method === \"return\") {\n\t          context.abrupt(\"return\", context.arg);\n\t        }\n\t\n\t        state = GenStateExecuting;\n\t\n\t        var record = tryCatch(innerFn, self, context);\n\t        if (record.type === \"normal\") {\n\t          // If an exception is thrown from innerFn, we leave state ===\n\t          // GenStateExecuting and loop back for another invocation.\n\t          state = context.done\n\t            ? GenStateCompleted\n\t            : GenStateSuspendedYield;\n\t\n\t          if (record.arg === ContinueSentinel) {\n\t            continue;\n\t          }\n\t\n\t          return {\n\t            value: record.arg,\n\t            done: context.done\n\t          };\n\t\n\t        } else if (record.type === \"throw\") {\n\t          state = GenStateCompleted;\n\t          // Dispatch the exception by looping back around to the\n\t          // context.dispatchException(context.arg) call above.\n\t          context.method = \"throw\";\n\t          context.arg = record.arg;\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  // Call delegate.iterator[context.method](context.arg) and handle the\n\t  // result, either by returning a { value, done } result from the\n\t  // delegate iterator, or by modifying context.method and context.arg,\n\t  // setting context.delegate to null, and returning the ContinueSentinel.\n\t  function maybeInvokeDelegate(delegate, context) {\n\t    var method = delegate.iterator[context.method];\n\t    if (method === undefined) {\n\t      // A .throw or .return when the delegate iterator has no .throw\n\t      // method always terminates the yield* loop.\n\t      context.delegate = null;\n\t\n\t      if (context.method === \"throw\") {\n\t        if (delegate.iterator.return) {\n\t          // If the delegate iterator has a return method, give it a\n\t          // chance to clean up.\n\t          context.method = \"return\";\n\t          context.arg = undefined;\n\t          maybeInvokeDelegate(delegate, context);\n\t\n\t          if (context.method === \"throw\") {\n\t            // If maybeInvokeDelegate(context) changed context.method from\n\t            // \"return\" to \"throw\", let that override the TypeError below.\n\t            return ContinueSentinel;\n\t          }\n\t        }\n\t\n\t        context.method = \"throw\";\n\t        context.arg = new TypeError(\n\t          \"The iterator does not provide a 'throw' method\");\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var record = tryCatch(method, delegate.iterator, context.arg);\n\t\n\t    if (record.type === \"throw\") {\n\t      context.method = \"throw\";\n\t      context.arg = record.arg;\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var info = record.arg;\n\t\n\t    if (! info) {\n\t      context.method = \"throw\";\n\t      context.arg = new TypeError(\"iterator result is not an object\");\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    if (info.done) {\n\t      // Assign the result of the finished delegate to the temporary\n\t      // variable specified by delegate.resultName (see delegateYield).\n\t      context[delegate.resultName] = info.value;\n\t\n\t      // Resume execution at the desired location (see delegateYield).\n\t      context.next = delegate.nextLoc;\n\t\n\t      // If context.method was \"throw\" but the delegate handled the\n\t      // exception, let the outer generator proceed normally. If\n\t      // context.method was \"next\", forget context.arg since it has been\n\t      // \"consumed\" by the delegate iterator. If context.method was\n\t      // \"return\", allow the original .return call to continue in the\n\t      // outer generator.\n\t      if (context.method !== \"return\") {\n\t        context.method = \"next\";\n\t        context.arg = undefined;\n\t      }\n\t\n\t    } else {\n\t      // Re-yield the result returned by the delegate method.\n\t      return info;\n\t    }\n\t\n\t    // The delegate iterator is finished, so forget it and continue with\n\t    // the outer generator.\n\t    context.delegate = null;\n\t    return ContinueSentinel;\n\t  }\n\t\n\t  // Define Generator.prototype.{next,throw,return} in terms of the\n\t  // unified ._invoke helper method.\n\t  defineIteratorMethods(Gp);\n\t\n\t  Gp[toStringTagSymbol] = \"Generator\";\n\t\n\t  Gp.toString = function() {\n\t    return \"[object Generator]\";\n\t  };\n\t\n\t  function pushTryEntry(locs) {\n\t    var entry = { tryLoc: locs[0] };\n\t\n\t    if (1 in locs) {\n\t      entry.catchLoc = locs[1];\n\t    }\n\t\n\t    if (2 in locs) {\n\t      entry.finallyLoc = locs[2];\n\t      entry.afterLoc = locs[3];\n\t    }\n\t\n\t    this.tryEntries.push(entry);\n\t  }\n\t\n\t  function resetTryEntry(entry) {\n\t    var record = entry.completion || {};\n\t    record.type = \"normal\";\n\t    delete record.arg;\n\t    entry.completion = record;\n\t  }\n\t\n\t  function Context(tryLocsList) {\n\t    // The root entry object (effectively a try statement without a catch\n\t    // or a finally block) gives us a place to store values thrown from\n\t    // locations where there is no enclosing try statement.\n\t    this.tryEntries = [{ tryLoc: \"root\" }];\n\t    tryLocsList.forEach(pushTryEntry, this);\n\t    this.reset(true);\n\t  }\n\t\n\t  runtime.keys = function(object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t      keys.push(key);\n\t    }\n\t    keys.reverse();\n\t\n\t    // Rather than returning an object with a next method, we keep\n\t    // things simple and return the next function itself.\n\t    return function next() {\n\t      while (keys.length) {\n\t        var key = keys.pop();\n\t        if (key in object) {\n\t          next.value = key;\n\t          next.done = false;\n\t          return next;\n\t        }\n\t      }\n\t\n\t      // To avoid creating an additional object, we just hang the .value\n\t      // and .done properties off the next function object itself. This\n\t      // also ensures that the minifier will not anonymize the function.\n\t      next.done = true;\n\t      return next;\n\t    };\n\t  };\n\t\n\t  function values(iterable) {\n\t    if (iterable) {\n\t      var iteratorMethod = iterable[iteratorSymbol];\n\t      if (iteratorMethod) {\n\t        return iteratorMethod.call(iterable);\n\t      }\n\t\n\t      if (typeof iterable.next === \"function\") {\n\t        return iterable;\n\t      }\n\t\n\t      if (!isNaN(iterable.length)) {\n\t        var i = -1, next = function next() {\n\t          while (++i < iterable.length) {\n\t            if (hasOwn.call(iterable, i)) {\n\t              next.value = iterable[i];\n\t              next.done = false;\n\t              return next;\n\t            }\n\t          }\n\t\n\t          next.value = undefined;\n\t          next.done = true;\n\t\n\t          return next;\n\t        };\n\t\n\t        return next.next = next;\n\t      }\n\t    }\n\t\n\t    // Return an iterator with no values.\n\t    return { next: doneResult };\n\t  }\n\t  runtime.values = values;\n\t\n\t  function doneResult() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  Context.prototype = {\n\t    constructor: Context,\n\t\n\t    reset: function(skipTempReset) {\n\t      this.prev = 0;\n\t      this.next = 0;\n\t      // Resetting context._sent for legacy support of Babel's\n\t      // function.sent implementation.\n\t      this.sent = this._sent = undefined;\n\t      this.done = false;\n\t      this.delegate = null;\n\t\n\t      this.method = \"next\";\n\t      this.arg = undefined;\n\t\n\t      this.tryEntries.forEach(resetTryEntry);\n\t\n\t      if (!skipTempReset) {\n\t        for (var name in this) {\n\t          // Not sure about the optimal order of these conditions:\n\t          if (name.charAt(0) === \"t\" &&\n\t              hasOwn.call(this, name) &&\n\t              !isNaN(+name.slice(1))) {\n\t            this[name] = undefined;\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    stop: function() {\n\t      this.done = true;\n\t\n\t      var rootEntry = this.tryEntries[0];\n\t      var rootRecord = rootEntry.completion;\n\t      if (rootRecord.type === \"throw\") {\n\t        throw rootRecord.arg;\n\t      }\n\t\n\t      return this.rval;\n\t    },\n\t\n\t    dispatchException: function(exception) {\n\t      if (this.done) {\n\t        throw exception;\n\t      }\n\t\n\t      var context = this;\n\t      function handle(loc, caught) {\n\t        record.type = \"throw\";\n\t        record.arg = exception;\n\t        context.next = loc;\n\t\n\t        if (caught) {\n\t          // If the dispatched exception was caught by a catch block,\n\t          // then let that catch block handle the exception normally.\n\t          context.method = \"next\";\n\t          context.arg = undefined;\n\t        }\n\t\n\t        return !! caught;\n\t      }\n\t\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        var record = entry.completion;\n\t\n\t        if (entry.tryLoc === \"root\") {\n\t          // Exception thrown outside of any try block that could handle\n\t          // it, so set the completion value of the entire function to\n\t          // throw the exception.\n\t          return handle(\"end\");\n\t        }\n\t\n\t        if (entry.tryLoc <= this.prev) {\n\t          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n\t          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\t\n\t          if (hasCatch && hasFinally) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            } else if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else if (hasCatch) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            }\n\t\n\t          } else if (hasFinally) {\n\t            if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else {\n\t            throw new Error(\"try statement without catch or finally\");\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    abrupt: function(type, arg) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc <= this.prev &&\n\t            hasOwn.call(entry, \"finallyLoc\") &&\n\t            this.prev < entry.finallyLoc) {\n\t          var finallyEntry = entry;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (finallyEntry &&\n\t          (type === \"break\" ||\n\t           type === \"continue\") &&\n\t          finallyEntry.tryLoc <= arg &&\n\t          arg <= finallyEntry.finallyLoc) {\n\t        // Ignore the finally entry if control is not jumping to a\n\t        // location outside the try/catch block.\n\t        finallyEntry = null;\n\t      }\n\t\n\t      var record = finallyEntry ? finallyEntry.completion : {};\n\t      record.type = type;\n\t      record.arg = arg;\n\t\n\t      if (finallyEntry) {\n\t        this.method = \"next\";\n\t        this.next = finallyEntry.finallyLoc;\n\t        return ContinueSentinel;\n\t      }\n\t\n\t      return this.complete(record);\n\t    },\n\t\n\t    complete: function(record, afterLoc) {\n\t      if (record.type === \"throw\") {\n\t        throw record.arg;\n\t      }\n\t\n\t      if (record.type === \"break\" ||\n\t          record.type === \"continue\") {\n\t        this.next = record.arg;\n\t      } else if (record.type === \"return\") {\n\t        this.rval = this.arg = record.arg;\n\t        this.method = \"return\";\n\t        this.next = \"end\";\n\t      } else if (record.type === \"normal\" && afterLoc) {\n\t        this.next = afterLoc;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    finish: function(finallyLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.finallyLoc === finallyLoc) {\n\t          this.complete(entry.completion, entry.afterLoc);\n\t          resetTryEntry(entry);\n\t          return ContinueSentinel;\n\t        }\n\t      }\n\t    },\n\t\n\t    \"catch\": function(tryLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc === tryLoc) {\n\t          var record = entry.completion;\n\t          if (record.type === \"throw\") {\n\t            var thrown = record.arg;\n\t            resetTryEntry(entry);\n\t          }\n\t          return thrown;\n\t        }\n\t      }\n\t\n\t      // The context.catch method must only be called with a location\n\t      // argument that corresponds to a known catch block.\n\t      throw new Error(\"illegal catch attempt\");\n\t    },\n\t\n\t    delegateYield: function(iterable, resultName, nextLoc) {\n\t      this.delegate = {\n\t        iterator: values(iterable),\n\t        resultName: resultName,\n\t        nextLoc: nextLoc\n\t      };\n\t\n\t      if (this.method === \"next\") {\n\t        // Deliberately forget the last sent value so that we don't\n\t        // accidentally pass it on to the delegate.\n\t        this.arg = undefined;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t  };\n\t})(\n\t  // Among the various tricks for obtaining a reference to the global\n\t  // object, this seems to be the most reliable technique that does not\n\t  // use indirect eval (which violates Content Security Policy).\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this\n\t);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(4)))\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// sw.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f2d06cd4aab4c3e78d05","import DataProvider from './dataProvider';\r\nimport ApiConfig from './config';\r\nimport OptimalRoutesCollection from './../public-transport-find-optimal-ways/optimalRoutesCollection';\r\n//import AppClient from './client';\r\n//let s = '123hello123';\r\nconsole.log('Hello from SW...');\r\n\r\n\r\nconst APP_CACHE_NAME = 'mosm-app-v1';\r\nconst TILE_CACHE_NAME = 'mosm-tiles-v1';\r\n\r\nconst urlsToCache = [\r\n  '/',\r\n  '/favicon.ico',\r\n  '/static/js/bundle.js',\r\n  '/static/css/style.css',\r\n  //ApiConfig.apiGetStationsUrl,\r\n  //ApiConfig.apiGetRoutesUrl,\r\n  //ApiConfig.apiGetTimetablesUrl\r\n];\r\n\r\nself.addEventListener('install', function(event) {\r\n  // Perform install steps\r\n  const cachePromise = caches.open(APP_CACHE_NAME)\r\n    .then(function(cache) {\r\n      console.log('install: opened cache');\r\n      return cache.addAll(urlsToCache);\r\n    })\r\n    .then(() => {\r\n      console.log('install: added all urls to cache');\r\n    });\r\n\r\n  event.waitUntil(cachePromise);\r\n  //event.waitUntil(self.skipWaiting()); // Activate worker immediately\r\n});\r\n\r\nself.addEventListener('activate', function(event) {\r\n  DataProvider.loadDataAndInitialize();\r\n\r\n  //event.waitUntil(self.clients.claim()); // Become available to all pages\r\n  //console.log('!!!!!!!!!activate');\r\n\r\n  /**/\r\n\r\n  \r\n\r\n});\r\n/*\r\nvar test = 0;\r\nsetInterval(function() {\r\n  test++\r\n}, 1000)\r\n*/\r\n//var ok = true;\r\n\r\nvar clients = [];\r\n\r\nself.addEventListener('message', function(event) {\r\n  var sender = event.source;\r\n  //console.log(event.data);\r\n  if(event.data === 'no-kill-sw') {\r\n    //console.log('SW: client call no-kill-sw.')\r\n    if(clients.includes(sender.id)){\r\n      return;\r\n    }\r\n    else {\r\n      clients.push(sender.id);\r\n      sender.postMessage('no-kill-sw-accepted');\r\n      setInterval(function(){\r\n        sender.postMessage(\"no-kill-sw-accepted\");\r\n      }, ApiConfig.clientVsSwNoKillingMessageInterval);\r\n    }\r\n  }\r\n  else if(event.data.requestType === 'optimalWay'){\r\n    console.log('SW: request for optimalWay.');\r\n\r\n    DataProvider.loadDataAndInitialize();\r\n\r\n    var params = event.data.params;\r\n    var rejected, resolved;\r\n    try {\r\n      var res = new OptimalRoutesCollection(\r\n        DataProvider.getAllStations(), \r\n        params.startOptimalRoutePoint, \r\n        params.finalOptimalRoutePoint, \r\n        params.startTime,\r\n        params.transportTypes,\r\n        params.goingSpeed,\r\n        params.dopTimeMinutes\r\n      );\r\n      //console.log('res = ' + res);\r\n      resolved = res.getOptimalWays();\r\n      //console.log('resolved = ' + resolved);\r\n    } catch(e) {\r\n      console.log(e);\r\n      rejected = e;\r\n    } finally {\r\n      sender.postMessage({\r\n        requestType: 'optimalWayResult',\r\n        result: resolved\r\n      });\r\n    }\r\n  }\r\n  /*if(ok) {\r\n    //ok = false;\r\n    setInterval(function() {\r\n      sender.postMessage({\r\n        message: test\r\n      });\r\n    }, 1000)\r\n    //if (event.waitUntil) {\r\n    //  event.waitUntil(promise);\r\n    //}\r\n  }*/\r\n});\r\n\r\n\r\n\r\nself.addEventListener('fetch', function(event) {\r\n  const { url } = event.request;\r\n  event.respondWith(\r\n    caches.match(event.request)\r\n      .then(function(response) {\r\n        // Cache hit - return response\r\n        if (response) {\r\n          return response;\r\n        }\r\n        caches.open(TILE_CACHE_NAME).then(cache => cache.add(url));\r\n\r\n        return fetch(event.request);\r\n      }\r\n    )\r\n  );\r\n});\r\n\r\n\r\n\r\n/*self.addEventListener('fetch', function(event) {\r\n  event.respondWith(\r\n    fetch(event.request).catch(function() {\r\n      return caches.match(event.request);\r\n    })\r\n  );\r\n});*/\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-client/sw.js","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-preset-react-app/~/babel-runtime/regenerator/index.js\n// module id = 1\n// module chunks = 0","class GeoCoords {\r\n    static distance(a, b) {\r\n        const earthRadius = 6372795;\r\n        const pi180 = 0.017453;// 29251//Math.Round(Math.PI / 180, 5);\r\n        var zz = 1, yy = 1;\r\n        function taylorSin(x) {\r\n            yy = x * x;\r\n            zz = x;\r\n            return zz - (zz *= yy) / 6 + (zz *= yy) / 120;\r\n        }\r\n        function taylorCos(x) {\r\n            yy = x * x;\r\n            zz = yy;\r\n            return 1 - (yy) / 2 + (zz *= yy) / 24;\r\n        }\r\n        /*function taylorAtan(x) {\r\n            yy = x * x;\r\n            zz = x;\r\n            return zz - (zz *= yy) / 3 + (zz *= yy) / 5 - (zz *= yy) / 7 + (zz *= yy) / 9 - (zz *= yy) / 20;\r\n        }*/\r\n\r\n        // перевести координаты в радианы\r\n        var lat1 = a.lat * pi180;\r\n        var lat2 = b.lat * pi180;\r\n        var long1 = a.lng * pi180;\r\n        var long2 = b.lng * pi180;\r\n\r\n        // косинусы и синусы широт и разницы долгот\r\n        var cl1 = taylorCos(lat1);\r\n        var cl2 = taylorCos(lat2);\r\n        var sl1 = taylorSin(lat1);\r\n        var sl2 = taylorSin(lat2);\r\n        var delta = long2 - long1;\r\n        var cdelta = taylorCos(delta);\r\n        var sdelta = taylorSin(delta);\r\n\r\n        // вычисления длины большого круга\r\n        var tmp = cl2 * cdelta;\r\n        var y = Math.sqrt(cl2 * cl2 * sdelta * sdelta + (cl1 * sl2 - sl1 * tmp) * (cl1 * sl2 - sl1 * tmp));\r\n        var x = sl1 * sl2 + cl1 * tmp;\r\n\r\n        //\r\n        var ad = Math.atan2(y, x);//taylorAtan(y/x);\r\n        var dist = Math.ceil(ad * earthRadius);//(int)Math.Round(ad * earthRadius, 0);\r\n\r\n        return dist;\r\n    }\r\n}\r\n\r\nexport default GeoCoords;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/geo-coords-functions/geoCoords.js","export default {\r\n    apiPublicTransportServer: \"https://ptp-97126.app.xervo.io/\",\r\n    apiGetStationsUrl: \"https://publictransportproject.000webhostapp.com/new/json/stations.json\", //\"stations\"\r\n    apiGetRoutesUrl: \"https://publictransportproject.000webhostapp.com/new/json/routes.json\", //\"routes\"\r\n    apiGetTimetablesUrl: \"https://publictransportproject.000webhostapp.com/new/json/timetables.json\", //\"timetables\"\r\n\r\n    clientVsSwNoKillingMessageInterval: 30000\r\n};\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-client/config.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 4\n// module chunks = 0","import JsonDataStorage from './jsonDataStorage';\r\nimport initialize from './../public-transport-initialize-data/initialize';\r\nimport ApiConfig from './config';\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Load data.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar allStations = null;\r\nvar allRoutes = null;\r\nvar allTimetables = null;\r\n\r\n//var updatingFromServerInterval = 5000;\r\n\r\nvar loadingStarted = false;\r\n\r\nvar allStationsLoaded = false, allRoutesLoaded = false,  allTimetablesLoaded = false;\r\nvar allStationsJSON = null, allRoutesJSON = null, allTimetablesJSON = null;\r\n\r\nasync function loadDataOnly() {\r\n    allStationsJSON = await JsonDataStorage.getAllStations();\r\n    allRoutesJSON = await JsonDataStorage.getAllRoutes();\r\n    allTimetablesJSON = await JsonDataStorage.getAllTimetables();\r\n\r\n    if(!allStationsLoaded){\r\n        if (allStationsJSON == null) { //localStorage[\"allStationsJSON\"] === undefined || localStorage[\"allStationsJSON\"] == null\r\n            console.log(\"Downloading stations from server...\");\r\n\r\n            let response = await fetch(ApiConfig.apiGetStationsUrl);\r\n            allStationsJSON = await response.text();\r\n            allStations = JSON.parse(allStationsJSON);//await response.json();\r\n\r\n            if (allStations !== undefined && allStations != null) JsonDataStorage.pushAllStations(allStationsJSON); //localStorage[\"allStationsJSON\"] = allStationsJSON;\r\n            allStationsLoaded = true;\r\n            console.log(\"Stations loaded from server.\");\r\n        }\r\n        else {\r\n            allStations = JSON.parse(allStationsJSON); //localStorage[\"allStationsJSON\"]\r\n            allStationsLoaded = true;\r\n            console.log(\"Stations loaded from localStorage.\");\r\n        }\r\n    }\r\n\r\n    if(!allRoutesLoaded){\r\n        if (allRoutesJSON == null) { //localStorage[\"allRoutesJSON\"] === undefined || localStorage[\"allRoutesJSON\"] == null\r\n            console.log(\"Downloading routes from server...\");\r\n\r\n            let response = await fetch(ApiConfig.apiGetRoutesUrl);\r\n            allRoutesJSON = await response.text();\r\n            allRoutes = JSON.parse(allRoutesJSON);//await response.json();\r\n\r\n            if (allRoutes !== undefined && allRoutes != null) JsonDataStorage.pushAllRoutes(allRoutesJSON); //localStorage[\"allRoutesJSON\"] = allRoutesJSON;\r\n            allRoutesLoaded = true;\r\n            console.log(\"Routes loaded from server.\");\r\n        }\r\n        else {\r\n            allRoutes = JSON.parse(allRoutesJSON); //localStorage[\"allRoutesJSON\"]\r\n            allRoutesLoaded = true;\r\n            console.log(\"Routes loaded from localStorage.\");\r\n        }\r\n    }\r\n\r\n    if(!allTimetablesLoaded){\r\n        if (allTimetablesJSON == null) { //localStorage[\"allTimetablesJSON\"] === undefined || localStorage[\"allTimetablesJSON\"] == null\r\n            console.log(\"Downloading timetables from server...\");\r\n\r\n            let response = await fetch(ApiConfig.apiGetTimetablesUrl);\r\n            allTimetablesJSON = await response.text();\r\n            allTimetables = JSON.parse(allTimetablesJSON);//await response.json();\r\n\r\n            if (allTimetables !== undefined && allTimetables != null) JsonDataStorage.pushAllTimetables(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"] = allTimetablesJSON;\r\n            allTimetablesLoaded = true;\r\n            console.log(\"Timetables loaded from server.\");\r\n        }\r\n        else {\r\n            allTimetables = JSON.parse(allTimetablesJSON); //localStorage[\"allTimetablesJSON\"]\r\n            allTimetablesLoaded = true;\r\n            console.log(\"Timetables loaded from localStorage.\");\r\n        }\r\n    }\r\n}\r\n\r\nasync function loadData() {\r\n    if(!loadingStarted){\r\n        loadingStarted = true;\r\n\r\n        await loadDataOnly();\r\n\r\n        if (allStationsLoaded && allRoutesLoaded && allTimetablesLoaded) {\r\n            initialize(allStations, allRoutes, allTimetables);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//loadData();\r\n\r\nclass DataProvider {\r\n    static getAllStations() {\r\n        return allStations;\r\n    }\r\n    static getAllRoutes() {\r\n        return allRoutes;\r\n    }\r\n    static getAllTimetables() {\r\n        return allTimetables;\r\n    }\r\n    static getAllStationsJSON() {\r\n        return allStationsJSON;\r\n    }\r\n    static getAllRoutesJSON() {\r\n        return allRoutesJSON;\r\n    }\r\n    static getAllTimetablesJSON() {\r\n        return allTimetablesJSON;\r\n    }\r\n    static async loadDataAndInitialize() {\r\n        await loadData();\r\n    }\r\n    static async loadDataOnly() {\r\n        await loadDataOnly();\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// End load data.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport default DataProvider;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-client/dataProvider.js","//import ApiConfig from './config';\r\n\r\nconst dbName = \"public_transport2\";\r\nconst storeName = \"json_data\";\r\n\r\nasync function getJsonDataStorageConnection() {\r\n    let promise = new Promise(function (resolve, reject) {\r\n        \r\n        let request = indexedDB.open(dbName, 1);\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n        request.onsuccess = function(event) {\r\n            resolve(event.target.result);\r\n        }\r\n        request.onupgradeneeded = async function(event) {\r\n            let db = event.target.result;\r\n            let objectStore = db.createObjectStore(storeName, { keyPath: \"name\"});\r\n            objectStore.createIndex(\"json\", \"json\", { unique: false });\r\n            \r\n            let result = await getJsonDataStorageConnection();\r\n            resolve(result);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\nasync function tryPush(obj) {\r\n    let promise = new Promise(async function (resolve, reject) {\r\n        let db = await getJsonDataStorageConnection();\r\n        //console.log(db);\r\n        let transaction = db.transaction([storeName], \"readwrite\");\r\n        let objectStore = transaction.objectStore(storeName);\r\n        let request = objectStore.add({\r\n            name: obj.name,\r\n            json: obj.json\r\n        });\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n        request.onsuccess = function(event) {\r\n            resolve(event.target.result);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\nasync function getItem(name) {\r\n    let promise = new Promise(async function (resolve, reject) {\r\n        let db = await getJsonDataStorageConnection();\r\n        let transaction = db.transaction([storeName]);\r\n        let objectStore = transaction.objectStore(storeName);\r\n\r\n        var request = objectStore.get(name);\r\n        request.onsuccess = function(event) { \r\n            if(event.target.result !== undefined) {                  \r\n                resolve(event.target.result.json);\r\n            }\r\n            else {\r\n                //resolve(null);\r\n                reject(event.target.error);\r\n            }\r\n        };\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\n\r\nclass JsonDataStorage {\r\n    static async getAllStations() {\r\n        try {\r\n            return await getItem('allStations');\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async getAllRoutes() {\r\n        try {\r\n            return await getItem('allRoutes');\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async getAllTimetables() {\r\n        try {\r\n            return await getItem('allTimetables');\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async pushAllStations(allStationsJson) {\r\n        try {\r\n            return await tryPush({\r\n                name: 'allStations',\r\n                json: allStationsJson\r\n            });\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async pushAllRoutes(allRoutesJson) {\r\n        try {\r\n            return await tryPush({\r\n                name: 'allRoutes',\r\n                json: allRoutesJson\r\n            });\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n    static async pushAllTimetables(allTimetablesJson) {\r\n        try {\r\n            return await tryPush({\r\n                name: 'allTimetables',\r\n                json: allTimetablesJson\r\n            });\r\n        } \r\n        catch(e){\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\nexport default JsonDataStorage;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-client/jsonDataStorage.js","//import Points from './points';\r\n//import IgnoringFragments from './ignoringFragments';\r\n\r\nclass OptimalRoute {\r\n    constructor(myPoints, stationsList, /*nowPos, needPos,*/ time, types, goingSpeed, dopTimeMinutes, ignoringRoutesAdd, ignoringList) {\r\n        if (ignoringRoutesAdd != null) this.ignoringRoutes = ignoringRoutesAdd;\r\n        else this.ignoringRoutes = [];\r\n\r\n        this.points = [];\r\n\r\n        //this.needPos = needPos;\r\n        //this.nowPos = nowPos;\r\n        this.goingSpeed = goingSpeed;\r\n        this.time = time;\r\n        var reservedTimeSeconds = 60 * dopTimeMinutes;\r\n\r\n        this.types = types;\r\n\r\n        this.myIgnoringFragments = null;\r\n        //if (ignoringList != null) this.myIgnoringFragments = new IgnoringFragments(ignoringList);\r\n        //else this.myIgnoringFragments = new IgnoringFragments();\r\n\r\n        //var myPoints = new Points(nowPos, needPos);\r\n        \r\n        myPoints.fillStartData(stationsList, goingSpeed, reservedTimeSeconds, this.myIgnoringFragments);\r\n\r\n        // Находим кратчайшие пути до всех вершин:\r\n        myPoints.countShortWay(this.ignoringRoutes, this.myIgnoringFragments, time, types, goingSpeed, reservedTimeSeconds);\r\n\r\n        var tmpP = myPoints.finalPoint;\r\n        this.points.push(tmpP.toString());////\r\n        while (tmpP.previousPoint != null) {\r\n            tmpP = tmpP.previousPoint;//\r\n            this.points.push(tmpP.toString());\r\n            if (tmpP.previousPoint == null && tmpP.coords !== myPoints.startPoint.coords)\r\n                throw new Error(\"Где-то удалилась часть маршрута...\");\r\n        }\r\n\r\n        this.totalTimeSeconds = myPoints.finalPoint.totalTimeSeconds;\r\n        this.totalGoingTime = myPoints.finalPoint.getTotalGoingTime();\r\n        this.totalTransportChangingCount = myPoints.finalPoint.getTotalTransportChangingCount();\r\n\r\n        this.myPoints = myPoints;\r\n\r\n\r\n        this.isVisited = false;\r\n    }\r\n\r\n    setVisited() {\r\n        this.isVisited = true;\r\n    }\r\n\r\n}\r\n\r\nexport default OptimalRoute;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/optimalRoute.js","//import IgnoringFragments from './ignoringFragments';\r\nimport OptimalRoute from './optimalRoute';\r\nimport OptimalWay from './optimalWay';\r\nimport Points from './points';\r\n\r\nimport GeoCoords from './../geo-coords-functions/geoCoords';\r\nvar distance = GeoCoords.distance;\r\nfunction getStationsAround(allStations, coords, radius) {\r\n    var result = [];\r\n    for (var i = 0, n = allStations.length, s = allStations[0]; i < n; s = allStations[++i]) {\r\n        if (s != null && distance(s.coords, coords) < radius) result.push(s);\r\n    }\r\n    return result;\r\n}\r\n\r\nclass OptimalRoutesCollection extends Array {\r\n    /*getOptimalWays() {\r\n        var result = [];\r\n        for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n            result.push(new OptimalWay(r));\r\n        }\r\n        return result;\r\n    }*/\r\n    /*selectOptimalRouteWithMinimalMark() {\r\n        var p = null;\r\n        for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n            if (!(t.isVisited)) {\r\n                p = t;\r\n                for (t = this[++i]; i < n; t = this[++i]) {\r\n                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                        p = t;\r\n                    }\r\n                }\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }*/\r\n    constructor(allStations, nowPos, needPos, time, types, speed, dopTimeMinutes) {\r\n        super();\r\n        this.getOptimalWays = function() {\r\n            var result = [];\r\n            for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n                result.push(new OptimalWay(r));\r\n            }\r\n            return result;\r\n        }\r\n        this.selectOptimalRouteWithMinimalMark = function() {\r\n            var p = null;\r\n            for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n                if (!(t.isVisited)) {\r\n                    p = t;\r\n                    for (t = this[++i]; i < n; t = this[++i]) {\r\n                        if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                            p = t;\r\n                        }\r\n                    }\r\n                    return p;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        var myPoints = new Points(nowPos, needPos);\r\n        // Получим \"начальный\" список станций:\r\n        var stationsList = getStationsAround(allStations, nowPos, distance(nowPos, needPos));\r\n\r\n        this.push(new OptimalRoute(myPoints, stationsList, /*nowPos, needPos,*/ time, types, speed, dopTimeMinutes));\r\n\r\n        var ignoringRoutes = [];\r\n\r\n        //var ignoringFragments = new IgnoringFragments();\r\n        \r\n        for (var selectedOptimalRoute = this[0]; selectedOptimalRoute != null; selectedOptimalRoute.setVisited(), selectedOptimalRoute = this.selectOptimalRouteWithMinimalMark()) {\r\n            var ddd = 0.25;\r\n\r\n            ignoringRoutes = [];\r\n            // Проходим по всем ребрам выбранного пути и строим новые маршруты при удалении ребер:\r\n            for (var tmpP = selectedOptimalRoute.myPoints.finalPoint; tmpP.previousPoint != null; tmpP = tmpP.previousPoint) {\r\n                if (tmpP.fromWhichRoute != null && !ignoringRoutes.includes(tmpP.fromWhichRoute)) ignoringRoutes.push(tmpP.fromWhichRoute);\r\n            }\r\n            for (var i = 0, n = ignoringRoutes.length, r = ignoringRoutes[0]; i < n; r = ignoringRoutes[++i]) {\r\n                if (selectedOptimalRoute.ignoringRoutes.includes(r)) continue;\r\n                var ignoringRoutesAdd = [];\r\n                ignoringRoutesAdd = ignoringRoutesAdd.concat(selectedOptimalRoute.ignoringRoutes);\r\n                ignoringRoutesAdd.push(r);\r\n                myPoints = new Points(nowPos, needPos);\r\n                var tmpOptimalRoute = new OptimalRoute(myPoints, stationsList, /*nowPos, needPos,*/ time, types, speed, dopTimeMinutes, ignoringRoutesAdd);\r\n\r\n                if (tmpOptimalRoute.totalTimeSeconds <= this[0].totalTimeSeconds / ddd) {\r\n                    var tmpJSON = JSON.stringify(tmpOptimalRoute.points);\r\n                    var ok = false;\r\n                    for (var j = 0, m = this.length, opt = this[0]; j < m; opt = this[++j]) {\r\n                        if (JSON.stringify(opt.points) === tmpJSON) {\r\n                            ok = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (ok) continue;\r\n                    this.push(tmpOptimalRoute);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default OptimalRoutesCollection;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/optimalRoutesCollection.js","import WayPoint from './wayPoint';\r\n\r\nclass OptimalWay {\r\n    constructor(optimalRoute) {\r\n        this.totalTimeSeconds = optimalRoute.totalTimeSeconds;\r\n        this.totalGoingTimeSeconds = optimalRoute.totalGoingTime;\r\n        this.totalTransportChangingCount = optimalRoute.totalTransportChangingCount;\r\n        this.points = [];\r\n\r\n        for (var tmpP = optimalRoute.myPoints.finalPoint; tmpP != null; tmpP = tmpP.previousPoint) {\r\n            this.points.push(new WayPoint(tmpP.totalTimeSeconds, tmpP.station, tmpP.fromWhichRoute, tmpP.coords));\r\n        }\r\n        this.points.reverse();\r\n    }\r\n\r\n}\r\n\r\nexport default OptimalWay;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/optimalWay.js","class Point {\r\n    constructor(totalTimeSeconds, station_or_crds, fromWhichStation, fromWhichRoute) {\r\n        if (station_or_crds.hashcode !== undefined) {\r\n            this.station = station_or_crds;\r\n            this.stationCode = station_or_crds.hashcode;\r\n            station_or_crds.point = this;\r\n            this.coords = station_or_crds.coords;\r\n        }\r\n        else {\r\n            this.coords = station_or_crds;\r\n            this.station = null;\r\n            this.stationCode = null;\r\n        }\r\n        this.totalTimeSeconds = totalTimeSeconds;\r\n        this.fromWhichStation = fromWhichStation;\r\n        this.fromWhichRoute = fromWhichRoute;\r\n\r\n        this.isVisited = false;\r\n\r\n        this.previousPoint = null;\r\n    }\r\n    tryUpdate(totalTimeSeconds, previousPoint, fromWhichStation, fromWhichRoute) {\r\n        if (totalTimeSeconds < this.totalTimeSeconds) {\r\n            this.fromWhichRoute = fromWhichRoute;\r\n            this.previousPoint = previousPoint;\r\n            this.totalTimeSeconds = totalTimeSeconds;\r\n            this.fromWhichStation = fromWhichStation;\r\n\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    setVisited() {\r\n        this.isVisited = true;\r\n    }\r\n    toString() {\r\n        var to, tr; //, from, p;\r\n        //if (this.fromWhichStation != null) from = this.fromWhichStation.name;\r\n        //else from = \"null\";\r\n        if (this.station != null) to = this.station.name;\r\n        else to = \"null\";\r\n        if (this.fromWhichRoute != null) tr = this.fromWhichRoute.type + \" \" + this.fromWhichRoute.number + \" \" + this.fromWhichRoute.from + \" - \" + this.fromWhichRoute.to;\r\n        else tr = \"пешком\";\r\n        //if (this.previousPoint != null) p = this.previousPoint.toString();\r\n        //else p = \"null\";\r\n        return /*p+\" -->> */\"(\" + this.totalTimeSeconds + \") \" + to + \" (\" + tr + \")\"; // from \" + from + \" to\r\n    }\r\n    getTotalGoingTime() {\r\n        var goingTime = 0;\r\n        var tmpP = this;\r\n        //this.points.Add(tmpP.ToString());\r\n        while (tmpP.previousPoint != null) {\r\n            if (tmpP.fromWhichRoute == null /*&& tmpP.fromWhichRoute.hashcode == null*/) goingTime += tmpP.totalTimeSeconds - tmpP.previousPoint.totalTimeSeconds;\r\n            tmpP = tmpP.previousPoint;\r\n        }\r\n        return goingTime;\r\n    }\r\n    getTotalTransportChangingCount() {\r\n        var result = 0;\r\n        var tmpP = this;\r\n        //this.points.Add(tmpP.ToString());\r\n        while (tmpP.previousPoint != null) {\r\n            if (tmpP.fromWhichRoute != null && tmpP.fromWhichRoute.hashcode != null && tmpP.fromWhichRoute !== tmpP.previousPoint.fromWhichRoute) result++;\r\n            tmpP = tmpP.previousPoint;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport default Point;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/point.js","import Point from './point';\r\nimport GeoCoords from './../geo-coords-functions/geoCoords';\r\nvar distance = GeoCoords.distance;\r\n\r\n\r\nfunction getTimeForGoingTo(distance, goingSpeed) {\r\n    return Math.floor(distance / (goingSpeed / 3.6));\r\n}\r\n\r\nconst TableType = { table: 1, periodic: 2 };\r\n\r\nclass Points {\r\n    constructor(nowPos, needPos) {\r\n        this.collection = [];\r\n        this.startPoint = new Point(0, nowPos, null, null);\r\n        this.finalPoint = new Point(2160000000, needPos, null, null);\r\n        this.currentSelectedPoint = null;\r\n    }\r\n    findElement(station_or_point) {\r\n        if (station_or_point.hashcode != null) {\r\n            if (station_or_point.point != null) return station_or_point.point;\r\n            var newCreatdPoint = new Point(2160000000, station_or_point, null, null);\r\n            this.collection.push(newCreatdPoint);\r\n            return newCreatdPoint;\r\n        }\r\n        else {\r\n            for (var i = 0, n = this.collection.length, p = this.collection[0]; i < n; p = this.collection[++i]) {\r\n                if (p.coords === station_or_point.coords && p.stationCode === station_or_point.stationCode) return p;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    fillStartData(stationsList, goingSpeed, reservedTime, myIgnoringFragments) {\r\n        this.finalPoint.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, this.finalPoint.coords), goingSpeed) + 1800/*+ TimeSpan.FromMinutes(20)*/, this.startPoint, null, null);\r\n        for (var i = 0, n = stationsList.length, st = stationsList[0]; i < n; st = stationsList[++i]) {\r\n            if (myIgnoringFragments != null && myIgnoringFragments.contains(st.hashcode, null, null)) continue;\r\n\r\n            var add = new Point(2160000000, st, null, null);\r\n            add.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, st.coords), goingSpeed) + reservedTime, this.startPoint, null, null);\r\n            this.collection.push(add);\r\n        }\r\n    }\r\n    getNextUnvisitedPoint() {\r\n        if (this.currentSelectedPoint != null) this.currentSelectedPoint.setVisited();\r\n\r\n        this.currentSelectedPoint = this.selectPointWithMinimalMark();\r\n\r\n        return this.currentSelectedPoint;\r\n    }\r\n    selectPointWithMinimalMark() {\r\n        var p = null;\r\n        for (var i = 0, n = this.collection.length, t = this.collection[0]; i < n; t = this.collection[++i]) {\r\n            if (!(t.isVisited)) {\r\n                p = t;\r\n                for (t = this.collection[++i]; i < n; t = this.collection[++i]) {\r\n                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                        p = t;\r\n                    }\r\n                }\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    countShortWay(ignoringRoutes, myIgnoringFragments, time, types, speed, reservedTime) {\r\n        //TimeSpan overLimitResedvedTime = TimeSpan.FromMinutes(20);\r\n\r\n        for (var selectedPoint = this.getNextUnvisitedPoint(), selectedPointStation, selectedPointTotalTimeSeconds, selectedPointStationHashcode, selectedPointFromWhichRoute, momentWhenComingToStation, routesOnStation, selectedPointCoords; selectedPoint != null; selectedPoint = this.getNextUnvisitedPoint()) {\r\n            //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n            selectedPointTotalTimeSeconds = selectedPoint.totalTimeSeconds;\r\n            if (selectedPointTotalTimeSeconds > this.finalPoint.totalTimeSeconds/* + overLimitResedvedTime*/) //... Пропускаем и удаляем, если значение метки превышает минимальное время до пункта назначения.\r\n            {\r\n                break;\r\n            }\r\n            selectedPointStation = selectedPoint.station;\r\n            selectedPointStationHashcode = selectedPointStation.hashcode;\r\n            selectedPointFromWhichRoute = selectedPoint.fromWhichRoute;\r\n            if (selectedPointStation != null) {\r\n                // Момент, когда мы прибудем на остановку:\r\n                momentWhenComingToStation = time + selectedPointTotalTimeSeconds;\r\n                // Загружаем маршруты, проходящие через остановку:\r\n                routesOnStation = null;// = routesOnStation = Database.GetRoutesOnStation(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);\r\n                if (selectedPointStation.routes != null) routesOnStation = selectedPointStation.routes;\r\n                else continue;\r\n\r\n                for (var i = 0, n = routesOnStation.length, selectedRoute = routesOnStation[0], nextStation; i < n; selectedRoute = routesOnStation[++i]) {\r\n                    if (ignoringRoutes != null && ignoringRoutes.includes(selectedRoute)) continue;\r\n                    if (types.includes(selectedRoute.type)) {\r\n                        // Следующая остановка у данного тран спорта:\r\n                        nextStation = selectedRoute.getNextStation(selectedPointStation);\r\n\r\n                        /*// Код остановки, на которую попадем на данном транспорте:\r\n                        string nextCode = selectedRoute.getNextStationCodeAfter(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);*/\r\n                        if (nextStation/*nextCode*/ != null) // Если остановка не является конечной, то:\r\n                        {\r\n                            // Загружаем расписание:\r\n                            var table = selectedRoute.getTimetable(selectedPointStation);//Database.getTimetable(selectedPointStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\r\n                            // Блокируем попытку попасть указанным транспортом на указанную остановку:\r\n                            if (myIgnoringFragments!= null && myIgnoringFragments.contains(nextStation.hashcode/*nextCode*/, selectedRoute.hashcode, selectedPointStationHashcode)) continue;\r\n\r\n                            if (table.type === TableType.table) // Если это точное расписание, то:\r\n                            {\r\n                                // Минимальный начальный момент, с который можно начинать ожидать посадку:\r\n                                var momentWhenAskingForGoing = momentWhenComingToStation;\r\n\r\n                                // Резервируем дополнительное время, если будем пересаживаться на другой маршрут:\r\n                                //if (selectedPoint.RouteCode == null || selectedPoint.RouteCode != selectedRoute.hashcode) momentWhenAskingForGoing += reservedTime;\r\n                                if (selectedPointFromWhichRoute != null && selectedPointFromWhichRoute !== selectedRoute) momentWhenAskingForGoing += reservedTime;\r\n\r\n                                // Подсчитываем, сколько будем ожидать этот транспорт на остановке:\r\n                                var waitingTime = table.findTimeAfter(momentWhenAskingForGoing);\r\n\r\n                                // Момент, когда мы сядем в транспорт:\r\n                                var momentWhenSitInTransport = momentWhenAskingForGoing + waitingTime;\r\n\r\n                                /*// Следующая остановка у данного транспорта:\r\n                                Station nextStation = Database.GetStationByHashcode(nextCode, databaseMysqlConnection, canReadDataFromLocalCopy: true);*/\r\n\r\n                                // И соответствующее расписание на этой остановке:\r\n                                var tbl = selectedRoute.getTimetable(nextStation);//Database.getTimetable(nextStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\r\n                                \r\n                                // (сколько будем ехать до следующей остановки):\r\n                                var goingOnTransportTime = tbl.findTimeAfter(momentWhenSitInTransport);\r\n                                \r\n                                // Метка времени:\r\n                                var onNextPointtotalTimeSeconds = momentWhenSitInTransport - momentWhenComingToStation + goingOnTransportTime + selectedPointTotalTimeSeconds;\r\n                                \r\n                                if (this.findElement(nextStation).tryUpdate(onNextPointtotalTimeSeconds, selectedPoint, selectedPointStation, selectedRoute)) {\r\n                                    //console.log(\"upd...\");\r\n                                }\r\n                            }\r\n                            else if (table.type === TableType.periodic) {\r\n                                throw new Error();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            selectedPointCoords = selectedPoint.coords;\r\n            // Нет смысла идти пешком \"транзитом\" через остановку:\r\n            if (selectedPointFromWhichRoute == null) continue;\r\n\r\n            // Попробуем пройти пешком до других \"вершин\":\r\n            for (var j = 0, m = this.collection.length, p = this.collection[0], distanceToSelectedPoint, goingTime, newTime; j < m; p = this.collection[++j])\r\n                if (!p.isVisited && p !== selectedPoint) {\r\n                    // Блокируем попытку дойти пешком до указанной остановки:\r\n                    if (myIgnoringFragments != null && myIgnoringFragments.contains(p.stationCode, null, selectedPointStationHashcode)) continue;\r\n\r\n                    distanceToSelectedPoint = distance(selectedPointCoords, p.coords);\r\n                    \r\n                    goingTime = getTimeForGoingTo(distanceToSelectedPoint, speed/*, true, sp*/);\r\n\r\n                    newTime = selectedPointTotalTimeSeconds + goingTime + reservedTime;\r\n                    /*if (p != myFinishPoint)*/ // newTime += reservedTime;\r\n                    \r\n                    if (p.tryUpdate(newTime, selectedPoint, selectedPointStation, null)) {\r\n                        //console.log(\"upd...\");\r\n                    }\r\n                }\r\n\r\n            if (myIgnoringFragments != null && myIgnoringFragments.contains(null, null, selectedPointStationHashcode)) continue;\r\n            \r\n            var tryingNewTime = selectedPointTotalTimeSeconds + getTimeForGoingTo(distance(selectedPointCoords, this.finalPoint.coords), speed);\r\n            if (this.finalPoint.tryUpdate(tryingNewTime, selectedPoint, selectedPointStation, null)) {\r\n                //console.log(\"upd: \" + selectedPointStation.hashcode);\r\n            }\r\n        }\r\n\r\n        // Сокращаем время ходьбы пешком до минимума и избавляемся от \"бессмысленных\" пересадок, сохраняя общее время неизменным:\r\n        var currentPoint = this.finalPoint.previousPoint;\r\n        while (currentPoint !== this.startPoint) {\r\n            var r = currentPoint.fromWhichRoute;\r\n            if (r != null) {\r\n                var previousPoint = currentPoint.previousPoint;\r\n                if (previousPoint !== this.startPoint && previousPoint.fromWhichRoute !== r) // Если на предыдущую остановку мы добрались другим транспортом, то:\r\n                {\r\n                    var previousRouteStation = r.getPreviousStation(previousPoint.station);\r\n                    if (previousRouteStation != null) {\r\n                        var point = previousRouteStation.point;\r\n                        if (point != null && point.isVisited) {\r\n                            var ttt = r.getTimetable(previousRouteStation);\r\n                            if (ttt != null) {\r\n                                //var ddd = time + previousPoint.totalTimeSeconds;\r\n                                //var moment = r.getTimetable(currentPoint.station).findTimeAfter(ddd);\r\n                                //var tmp_time = ttt.findTimeBefore(ddd + moment);\r\n\r\n                                //var momentArriveOnCurrent = previousPoint.totalTimeSeconds + moment;\r\n                                //var momentSittingOnPrevious = momentArriveOnCurrent + tmp_time;\r\n                                /*bool bbb = point.fromWhichRoute != null && point.fromWhichRoute.getTimetable(point.station) != null && point.fromWhichRoute.getTimetable(point.station).findTimeAfter(time + point.totalTimeSeconds) <= previousPoint.totalTimeSeconds + moment + tmp_time;\r\n                                if (bbb)\r\n                                {\r\n                                    previousPoint.fromWhichRoute = r;\r\n                                    previousPoint.previousPoint = point;////!bbb && point.totalTimeSeconds <= momentSittingOnPrevious &&\r\n                                }\r\n                                else */\r\n                                if (/*point.totalGoingTime>=previousPoint.totalGoingTime || */point.totalTimeSeconds <= previousPoint.totalTimeSeconds/* && point.totalGoingTime <= previousPoint.totalGoingTime*/) {\r\n                                    previousPoint.fromWhichRoute = r;\r\n                                    previousPoint.previousPoint = point;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            currentPoint = currentPoint.previousPoint;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Points;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/points.js","class WayPoint {\r\n    constructor(time, station, route, coords) {\r\n        this.time = time;\r\n        this.station = station == null ? null : { hashcode: station.hashcode, name: station.name, routes: null, Coords: { lat: station.coords.lat, lng: station.coords.lng } };\r\n        this.route = route == null ? null : { vehicles: [], gpsTrack: null, hashcode: route.hashcode, number: route.number, type: route.type, from: route.from, to: route.to, owner: \"\", stations: null, timetables: null, stationsJSON: null }\r\n        this.coords = coords;\r\n    }\r\n}\r\n\r\nexport default WayPoint;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-find-optimal-ways/wayPoint.js","///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Initailize.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction getNextStation(currentStation) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let t = 0, nn = this.stations[j].length; t < nn; t++) {\r\n            if (this.stations[j][t] === currentStation) {\r\n                if (t + 1 !== nn) return this.stations[j][t + 1];\r\n                else return null;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getPreviousStation(currentStation) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let t = 0, nn = this.stations[j].length; t < nn; t++) {\r\n            if (this.stations[j][t] === currentStation) {\r\n                if (t !== nn) return this.stations[j][t - 1];\r\n                else return null;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getTimetable(station) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let i = 0, n = this.stations[j].length; i < n; i++) {\r\n            if (this.stations[j][i] === station) {\r\n                return this.timetables[j][i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction findTimeAfter(time) {\r\n    var dateTmp = new Date();\r\n    dateTmp.setMinutes(0);\r\n    dateTmp.setHours(0);\r\n    dateTmp.setSeconds(time);\r\n    var day = dateTmp.getDay();\r\n    //foreach (Table t in table)\r\n    for (let kkk = 0, mnkk = this.table.length, t = this.table[0]; kkk < mnkk; t = this.table[++kkk]) {\r\n        if (t.days.includes(day)) {\r\n\r\n            //foreach (SimpleTime st in t.times)\r\n            for (let iik = 0, mnii = t.times.length, st = t.times[0], stTime; iik < mnii; st = t.times[++iik]) {\r\n                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\r\n                //\r\n                stTime = st.hour * 3600 + st.minute * 60;\r\n                if (stTime >= time/*.Second + time.Minute * 60 + time.Hour * 3600*/ /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\r\n                    //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\r\n                    return stTime - time/*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/;\r\n                }\r\n            }\r\n            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time/*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/ + 86400;\r\n            break;\r\n        }\r\n    }\r\n    return 2160000000;\r\n    //throw new Exception();\r\n}\r\nfunction findTimeBefore(time) {\r\n    var dateTmp = new Date();\r\n    dateTmp.setMinutes(0);\r\n    dateTmp.setHours(0);\r\n    dateTmp.setSeconds(time);\r\n    var day = dateTmp.getDay();\r\n    for (let kkk = 0, mnkk = this.table.length, t = this.table[0], ok = false, st; kkk < mnkk; t = this.table[++kkk]) {\r\n        if (t.days.includes(day)) {\r\n            ok = false;\r\n            st = null;\r\n            for (let iik = 0, mnii = t.times.length, stt = t.times[0]; iik < mnii; stt = t.times[++iik]) {\r\n                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\r\n                //\r\n                if (stt.hour * 3600 + stt.minute * 60 <= time/*time.Hour >= st.hour && time.Minute >= st.minute*/) {\r\n                    ok = true;\r\n                    st = stt;\r\n                    //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\r\n                }\r\n                else break;\r\n            }\r\n            if (ok) return st.hour * 3600 + st.minute * 60 - time;\r\n            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time - 86400;\r\n            break;\r\n        }\r\n    }\r\n    return 0;//TimeSpan.FromDays(0/*-25000*/);\r\n    //throw new Exception();\r\n}\r\n\r\n\r\nfunction initialize(allStations, allRoutes, allTimetables) {\r\n    //alert(allStations.length);\r\n    //alert(allRoutes.length);\r\n    //alert(allTimetables.length);\r\n\r\n    console.log(\"Start initializing...\");\r\n    var startInitializingMoment = Date.now();\r\n\r\n    var tmpUsedStations = [];\r\n\r\n    function bindRoutesStationsTimetables(station, tmpArr, tabArr, rr) {\r\n        if (station.routes == null) station.routes = [];\r\n        //console.log(station.routes);//!!!\r\n        if (!(station.routes.includes(rr))) station.routes.push(rr);\r\n        tmpArr.push(station);\r\n\r\n        var tmp = allTimetables.find(function (element, index, array) {\r\n            return element.stationCode === station.hashcode && element.routeCode === rr.hashcode;\r\n        });\r\n        var tmpTab = (tmp == null) ? null : tmp;\r\n\r\n        tabArr.push(tmpTab);\r\n    }\r\n\r\n    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n        if (currentStation.routesCodes == null || currentStation.routesCodes.length === 0) {\r\n            allStations.splice(i, 1);\r\n            n = allStations.length;\r\n        }\r\n        else i++;\r\n    }\r\n\r\n    for (let i = 0, n = allRoutes.length, rr = allRoutes[0]; i < n; rr = allRoutes[++i]) {\r\n\r\n        rr.getNextStation = getNextStation; \r\n        rr.getPreviousStation = getPreviousStation;\r\n        rr.getTimetable = getTimetable;\r\n\r\n        if (rr.stationsCodes == null || rr.stationsCodes.length === 0) continue;\r\n\r\n        try {\r\n            //if (rr.stationsCodes[rr.stationsCodes.Length - 1] != ']') continue;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n\r\n            rr.stations = [[],[]];\r\n            rr.timetables = [[],[]];\r\n\r\n\r\n\r\n            for (let index = 0, tmpArr = [], tabArr = [] ; index <= 1; index++) {\r\n                var rr_stationsCodes = rr.stationsCodes;\r\n                if (rr_stationsCodes[index] == null || rr_stationsCodes[index].length === 0) continue;\r\n                for (let j = 0, m = rr_stationsCodes[index].length, stationCode = rr_stationsCodes[index][0]; j < m; stationCode = rr_stationsCodes[index][++j]) {\r\n                    var tmpUsed = false;\r\n                    for (let k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\r\n                        if (station != null && station.hashcode === stationCode) {\r\n                            bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\r\n                            tmpUsed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!tmpUsed) {\r\n                        for (let k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\r\n                            if (station != null && station.hashcode === stationCode) {\r\n                                bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\r\n                                if (!tmpUsedStations.includes(station)) tmpUsedStations.push(station);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                rr.stations[index] = tmpArr;\r\n                rr.timetables[index] = tabArr;\r\n\r\n            }\r\n        }\r\n        catch (ex) {\r\n            console.log(ex/*.message*/);\r\n            continue;\r\n        }\r\n    }\r\n\r\n    for (let i = 0, n = allTimetables.length, timetable = allTimetables[0]; i < n; timetable = allTimetables[++i]) {\r\n        timetable.findTimeAfter = findTimeAfter;\r\n        timetable.findTimeBefore = findTimeBefore;\r\n    }\r\n\r\n    //...\r\n    /*\r\n    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n        if (currentStation.routes == undefined || currentStation.routes == null || currentStation.routes.length == 0) {\r\n            allStations.splice(i, 1);\r\n            n = allStations.length;\r\n        }\r\n        else i++;\r\n    }\r\n    */\r\n\r\n    console.log(\"Initialized. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\r\n    //console.log(\"\\n\\n\" + JSON.stringify(allTimetables[0]) + \"\\n\\n\");\r\n    //alert(distance({ lat: allStations[0].xCoord, lng: allStations[0].yCoord }, { lat: allStations[5].xCoord, lng: allStations[5].yCoord }));\r\n\r\n\r\n    //for (let t = 0; t < 1000; t++) var ttt = GetStationsAround(allStations[0].coords, 30000).length;\r\n    //console.log(\"test. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\r\n\r\n\r\n    //global.initialized = true;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// End initailize.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport default initialize;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/public-transport-initialize-data/initialize.js","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime-module.js\n// module id = 14\n// module chunks = 0","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime.js\n// module id = 15\n// module chunks = 0"],"sourceRoot":""}