{"version":3,"sources":["webpack:///sw.js","webpack:///webpack/bootstrap fea557d3a8a0031b52c7","webpack:///./src/modules/client/sw.js","webpack:///./~/babel-preset-react-app/~/babel-runtime/regenerator/index.js","webpack:///./src/modules/geoCoords.js","webpack:///./src/modules/apiConfig.js","webpack:///./src/modules/loadData.js","webpack:///./~/process/browser.js","webpack:///./src/modules/client/client.js","webpack:///./src/modules/client/pointsHistoryStorage.js","webpack:///./src/modules/initialize.js","webpack:///./src/modules/optimalRoute.js","webpack:///./src/modules/optimalRoutesCollection.js","webpack:///./src/modules/optimalWay.js","webpack:///./src/modules/point.js","webpack:///./src/modules/points.js","webpack:///./src/modules/wayPoint.js","webpack:///./~/regenerator-runtime/runtime-module.js","webpack:///./~/regenerator-runtime/runtime.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_client","console","log","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","GeoCoords","this","a","b","taylorSin","x","yy","zz","taylorCos","earthRadius","pi180","lat1","lat","lat2","long1","lng","long2","cl1","cl2","sl1","sl2","delta","cdelta","sdelta","tmp","y","Math","sqrt","ad","atan2","dist","ceil","ApiConfig","apiPublicTransportServer","_asyncToGenerator","fn","gen","apply","arguments","Promise","resolve","reject","step","arg","info","error","done","then","err","_regenerator","_regenerator2","_loadDataOnly","_ref","mark","_callee","strGetStations","response","strGetRoutes","_response","strGetTimetables","_response2","wrap","_context","prev","next","allStationsLoaded","undefined","localStorage","fetch","sent","text","allStationsJSON","allStations","JSON","parse","allRoutesLoaded","allRoutesJSON","allRoutes","allTimetablesLoaded","allTimetablesJSON","allTimetables","stop","loadData","_ref2","_callee2","_context2","loadingStarted","loadDataOnly","_initialize2","_initialize","_apiConfig","_apiConfig2","MyDatabase","loadDataAndInitialize","_ref3","_callee3","_context3","_ref4","_callee4","_context4","defaultSetTimout","Error","defaultClearTimeout","runTimeout","fun","cachedSetTimeout","setTimeout","e","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","len","run","Item","array","noop","process","nextTick","args","Array","push","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","strToCoords","str","split","myLat","parseFloat","myLng","strToSeconds","hours","parseInt","minutes","getJsonFromUrl","_ref6","_callee6","strReq","_context6","json","abrupt","_x9","getCountedOnServerWays","_ref7","_callee7","fromPositionStr","toPositionStr","myStartTimeStr","my_dopTimeMinutes","my_speed","typesStr","paramsStr","data","_context7","AppClient","findedOptimalWays","_x10","_x11","_x12","_x13","_x14","_x15","getCountedOnClientWays","_ref8","_callee8","startOptimalRoutePoint","finalOptimalRoutePoint","myStartTime","types","startInitializingMoment","res","_context8","_loadData2","Date","now","_optimalRoutesCollection2","getOptimalWays","_x16","_x17","_x18","_x19","_x20","_x21","_optimalRoutesCollection","_loadData","_pointsHistoryStorage","_pointsHistoryStorage2","navigator","onLine","findWays","_x","_x2","_x3","_x4","_x5","_x6","t0","minimalTimeSeconds","totalTimeSeconds","minimalGoingTimeSeconds","totalGoingTimeSeconds","minimalTransportChangingCount","totalTransportChangingCount","totalTimePercentValue","totalGoingTimePercentValue","totalTransportChangingCountPercentValue","sortedArr","newSortedFindedWays","tmpTransportChangingCountEffictivity","max_rank","index","j","indexOf","tmp_rank","n","sortedIndex","findCurrentDestinationCoords","getCurrentPosition","position","findedLat","findedLng","coords","lastCnownPositionCoordsDescription","searchingPoint","resultCoords","geolocation","promise","latitude","toFixed","longitude","getDesinationDescription","tryFindByCoords","description","findPointsByOsmGeocodingApi","_x7","resultPoints","currentPoint","lon","display_name","tryPush","_x8","_ref5","_callee5","findedPoints","_context5","myCurrentFindedPosition","fromPosition","toPosition","getPointsHistoryStorageConnection","request","indexedDB","open","dbName","onerror","event","onsuccess","result","onupgradeneeded","db","objectStore","createObjectStore","storeName","keyPath","autoIncrement","createIndex","unique","_getAllPoints","items","transaction","openCursor","evt","cursor","continue","_tryFindByCoords","pointsHistory","candidate","findedDistance","currentDistance","getAllPoints","_geoCoords2","distance","_tryPush","point","add","_geoCoords","PointsHistoryStorage","_ref9","_callee9","_context9","_ref10","_callee10","_context10","getNextStation","currentStation","t","nn","stations","getPreviousStation","getTimetable","station","timetables","findTimeAfter","time","dateTmp","setMinutes","setHours","setSeconds","day","getDay","kkk","mnkk","table","days","includes","stTime","iik","mnii","times","st","hour","minute","findTimeBefore","ok","stt","initialize","bindRoutesStationsTimetables","tmpArr","tabArr","rr","routes","find","element","stationCode","hashcode","routeCode","tmpTab","tmpUsedStations","routesCodes","splice","stationsCodes","rr_stationsCodes","tmpUsed","k","mn","ex","timetable","getStationsAround","radius","getAllStations","s","_points","_points2","OptimalRoute","nowPos","needPos","goingSpeed","dopTimeMinutes","ignoringRoutesAdd","ignoringList","ignoringRoutes","points","reservedTimeSeconds","myIgnoringFragments","myPoints","stationsList","startPoint","finalPoint","fillStartData","countShortWay","tmpP","toString","previousPoint","totalGoingTime","getTotalGoingTime","getTotalTransportChangingCount","isVisited","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","_optimalRoute","_optimalRoute2","_optimalWay","_optimalWay2","OptimalRoutesCollection","_Array","speed","_this","getPrototypeOf","r","selectOptimalRouteWithMinimalMark","selectedOptimalRoute","setVisited","ddd","fromWhichRoute","tmpOptimalRoute","tmpJSON","stringify","opt","_wayPoint","_wayPoint2","OptimalWay","optimalRoute","reverse","Point","station_or_crds","fromWhichStation","to","tr","type","number","from","goingTime","getTimeForGoingTo","floor","_point","_point2","TableType","periodic","Points","collection","currentSelectedPoint","station_or_point","newCreatdPoint","reservedTime","tryUpdate","contains","selectPointWithMinimalMark","selectedPointStation","selectedPointTotalTimeSeconds","selectedPointStationHashcode","selectedPointFromWhichRoute","momentWhenComingToStation","routesOnStation","selectedPointCoords","selectedPoint","getNextUnvisitedPoint","nextStation","selectedRoute","momentWhenAskingForGoing","waitingTime","momentWhenSitInTransport","tbl","goingOnTransportTime","onNextPointtotalTimeSeconds","findElement","distanceToSelectedPoint","newTime","tryingNewTime","previousRouteStation","ttt","WayPoint","route","Coords","vehicles","gpsTrack","owner","stationsJSON","global","g","window","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","context","Context","_invoke","makeInvokeMethod","tryCatch","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","forEach","method","AsyncIterator","invoke","record","hasOwn","__await","unwrapped","enqueue","callInvokeWithMethodAndArg","previousPromise","domain","bind","state","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","_sent","dispatchException","GenStateSuspendedYield","iterator","return","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","values","iterable","iteratorMethod","iteratorSymbol","isNaN","Op","hasOwnProperty","$Symbol","Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","ctor","awrap","async","iter","keys","object","pop","skipTempReset","charAt","slice","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","catch","thrown","delegateYield"],"mappings":"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","file":"sw.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _client = __webpack_require__(6);\n\t\n\tvar _client2 = _interopRequireDefault(_client);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar s = '123hello123';\n\tconsole.log('111111111111111111111111111111111111111111');\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(15);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar GeoCoords = function () {\n\t    function GeoCoords() {\n\t        _classCallCheck(this, GeoCoords);\n\t    }\n\t\n\t    _createClass(GeoCoords, null, [{\n\t        key: \"distance\",\n\t        value: function distance(a, b) {\n\t            var earthRadius = 6372795;\n\t            var pi180 = 0.017453; // 29251//Math.Round(Math.PI / 180, 5);\n\t            var zz = 1,\n\t                yy = 1;\n\t            function taylorSin(x) {\n\t                yy = x * x;\n\t                zz = x;\n\t                return zz - (zz *= yy) / 6 + (zz *= yy) / 120;\n\t            }\n\t            function taylorCos(x) {\n\t                yy = x * x;\n\t                zz = yy;\n\t                return 1 - yy / 2 + (zz *= yy) / 24;\n\t            }\n\t            /*function taylorAtan(x) {\r\n\t                yy = x * x;\r\n\t                zz = x;\r\n\t                return zz - (zz *= yy) / 3 + (zz *= yy) / 5 - (zz *= yy) / 7 + (zz *= yy) / 9 - (zz *= yy) / 20;\r\n\t            }*/\n\t\n\t            // перевести координаты в радианы\n\t            var lat1 = a.lat * pi180;\n\t            var lat2 = b.lat * pi180;\n\t            var long1 = a.lng * pi180;\n\t            var long2 = b.lng * pi180;\n\t\n\t            // косинусы и синусы широт и разницы долгот\n\t            var cl1 = taylorCos(lat1);\n\t            var cl2 = taylorCos(lat2);\n\t            var sl1 = taylorSin(lat1);\n\t            var sl2 = taylorSin(lat2);\n\t            var delta = long2 - long1;\n\t            var cdelta = taylorCos(delta);\n\t            var sdelta = taylorSin(delta);\n\t\n\t            // вычисления длины большого круга\n\t            var tmp = cl2 * cdelta;\n\t            var y = Math.sqrt(cl2 * cl2 * sdelta * sdelta + (cl1 * sl2 - sl1 * tmp) * (cl1 * sl2 - sl1 * tmp));\n\t            var x = sl1 * sl2 + cl1 * tmp;\n\t\n\t            //\n\t            var ad = Math.atan2(y, x); //taylorAtan(y/x);\n\t            var dist = Math.ceil(ad * earthRadius); //(int)Math.Round(ad * earthRadius, 0);\n\t\n\t            return dist;\n\t        }\n\t    }]);\n\t\n\t    return GeoCoords;\n\t}();\n\t\n\texports.default = GeoCoords;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar ApiConfig = function ApiConfig() {\n\t    _classCallCheck(this, ApiConfig);\n\t};\n\t\n\tApiConfig.apiPublicTransportServer = \"https://ptp-97126.app.xervo.io/\";\n\texports.default = ApiConfig;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _regenerator = __webpack_require__(1);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _loadDataOnly = function () {\n\t    var _ref = _asyncToGenerator(_regenerator2.default.mark(function _callee() {\n\t        var strGetStations, response, strGetRoutes, _response, strGetTimetables, _response2;\n\t\n\t        return _regenerator2.default.wrap(function _callee$(_context) {\n\t            while (1) {\n\t                switch (_context.prev = _context.next) {\n\t                    case 0:\n\t                        if (allStationsLoaded) {\n\t                            _context.next = 19;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(localStorage[\"allStationsJSON\"] === undefined || localStorage[\"allStationsJSON\"] == null)) {\n\t                            _context.next = 16;\n\t                            break;\n\t                        }\n\t\n\t                        console.log(\"Downloading stations from server...\");\n\t                        strGetStations = apiPublicTransportServer + \"stations/\";\n\t                        _context.next = 6;\n\t                        return fetch(strGetStations);\n\t\n\t                    case 6:\n\t                        response = _context.sent;\n\t                        _context.next = 9;\n\t                        return response.text();\n\t\n\t                    case 9:\n\t                        allStationsJSON = _context.sent;\n\t\n\t                        allStations = JSON.parse(allStationsJSON); //await response.json();\n\t\n\t                        if (allStations !== undefined && allStations != null) localStorage[\"allStationsJSON\"] = allStationsJSON;\n\t                        allStationsLoaded = true;\n\t                        console.log(\"Stations loaded from server.\");\n\t                        _context.next = 19;\n\t                        break;\n\t\n\t                    case 16:\n\t                        allStations = JSON.parse(localStorage[\"allStationsJSON\"]);\n\t                        allStationsLoaded = true;\n\t                        console.log(\"Stations loaded from localStorage.\");\n\t\n\t                    case 19:\n\t                        if (allRoutesLoaded) {\n\t                            _context.next = 38;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(localStorage[\"allRoutesJSON\"] === undefined || localStorage[\"allRoutesJSON\"] == null)) {\n\t                            _context.next = 35;\n\t                            break;\n\t                        }\n\t\n\t                        console.log(\"Downloading routes from server...\");\n\t                        strGetRoutes = apiPublicTransportServer + \"routes/\";\n\t                        _context.next = 25;\n\t                        return fetch(strGetRoutes);\n\t\n\t                    case 25:\n\t                        _response = _context.sent;\n\t                        _context.next = 28;\n\t                        return _response.text();\n\t\n\t                    case 28:\n\t                        allRoutesJSON = _context.sent;\n\t\n\t                        allRoutes = JSON.parse(allRoutesJSON); //await response.json();\n\t\n\t                        if (allRoutes !== undefined && allRoutes != null) localStorage[\"allRoutesJSON\"] = allRoutesJSON;\n\t                        allRoutesLoaded = true;\n\t                        console.log(\"Routes loaded from server.\");\n\t                        _context.next = 38;\n\t                        break;\n\t\n\t                    case 35:\n\t                        allRoutes = JSON.parse(localStorage[\"allRoutesJSON\"]);\n\t                        allRoutesLoaded = true;\n\t                        console.log(\"Routes loaded from localStorage.\");\n\t\n\t                    case 38:\n\t                        if (allTimetablesLoaded) {\n\t                            _context.next = 57;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(localStorage[\"allTimetablesJSON\"] === undefined || localStorage[\"allTimetablesJSON\"] == null)) {\n\t                            _context.next = 54;\n\t                            break;\n\t                        }\n\t\n\t                        console.log(\"Downloading timetables from server...\");\n\t                        strGetTimetables = apiPublicTransportServer + \"timetables/\";\n\t                        _context.next = 44;\n\t                        return fetch(strGetTimetables);\n\t\n\t                    case 44:\n\t                        _response2 = _context.sent;\n\t                        _context.next = 47;\n\t                        return _response2.text();\n\t\n\t                    case 47:\n\t                        allTimetablesJSON = _context.sent;\n\t\n\t                        allTimetables = JSON.parse(allTimetablesJSON); //await response.json();\n\t\n\t                        if (allTimetables !== undefined && allTimetables != null) localStorage[\"allTimetablesJSON\"] = allTimetablesJSON;\n\t                        allTimetablesLoaded = true;\n\t                        console.log(\"Timetables loaded from server.\");\n\t                        _context.next = 57;\n\t                        break;\n\t\n\t                    case 54:\n\t                        allTimetables = JSON.parse(localStorage[\"allTimetablesJSON\"]);\n\t                        allTimetablesLoaded = true;\n\t                        console.log(\"Timetables loaded from localStorage.\");\n\t\n\t                    case 57:\n\t                    case 'end':\n\t                        return _context.stop();\n\t                }\n\t            }\n\t        }, _callee, this);\n\t    }));\n\t\n\t    return function _loadDataOnly() {\n\t        return _ref.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar loadData = function () {\n\t    var _ref2 = _asyncToGenerator(_regenerator2.default.mark(function _callee2() {\n\t        return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t            while (1) {\n\t                switch (_context2.prev = _context2.next) {\n\t                    case 0:\n\t                        if (loadingStarted) {\n\t                            _context2.next = 5;\n\t                            break;\n\t                        }\n\t\n\t                        loadingStarted = true;\n\t\n\t                        _context2.next = 4;\n\t                        return _loadDataOnly();\n\t\n\t                    case 4:\n\t\n\t                        if (allStationsLoaded && allRoutesLoaded && allTimetablesLoaded) {\n\t                            (0, _initialize2.default)(allStations, allRoutes, allTimetables);\n\t                        }\n\t\n\t                    case 5:\n\t                    case 'end':\n\t                        return _context2.stop();\n\t                }\n\t            }\n\t        }, _callee2, this);\n\t    }));\n\t\n\t    return function loadData() {\n\t        return _ref2.apply(this, arguments);\n\t    };\n\t}();\n\t\n\t//loadData();\n\t\n\tvar _initialize = __webpack_require__(8);\n\t\n\tvar _initialize2 = _interopRequireDefault(_initialize);\n\t\n\tvar _apiConfig = __webpack_require__(3);\n\t\n\tvar _apiConfig2 = _interopRequireDefault(_apiConfig);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; } //var fetch = require('node-fetch');\n\t\n\t\n\tvar apiPublicTransportServer = _apiConfig2.default.apiPublicTransportServer;\n\t\n\t/*var strGetStations = apiPublicTransportServer + \"stations/\";\r\n\tstrGetStations = \"json/stations.json\";\r\n\tstrGetStations = \"https://publictransportproject.000webhostapp.com/new/json/stations.json\"; \r\n\t\r\n\tvar strGetRoutes = apiPublicTransportServer + \"routes/\";\r\n\tstrGetRoutes = \"json/routes.json\";\r\n\tstrGetRoutes = \"https://publictransportproject.000webhostapp.com/new/json/routes.json\";\r\n\t\r\n\tvar strGetTimetables = apiPublicTransportServer + \"timetables/\";\r\n\tstrGetTimetables = \"json/timetables.json\";\r\n\tstrGetTimetables = \"https://publictransportproject.000webhostapp.com/new/json/timetables.json\";*/\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Load data.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar allStations = null;\n\tvar allRoutes = null;\n\tvar allTimetables = null;\n\t\n\t//var updatingFromServerInterval = 5000;\n\t\n\tvar loadingStarted = false;\n\t\n\tvar allStationsLoaded = false,\n\t    allRoutesLoaded = false,\n\t    allTimetablesLoaded = false;\n\tvar allStationsJSON = null,\n\t    allRoutesJSON = null,\n\t    allTimetablesJSON = null;\n\t\n\tvar MyDatabase = function () {\n\t    function MyDatabase() {\n\t        _classCallCheck(this, MyDatabase);\n\t    }\n\t\n\t    _createClass(MyDatabase, null, [{\n\t        key: 'getAllStations',\n\t        value: function getAllStations() {\n\t            return allStations;\n\t        }\n\t    }, {\n\t        key: 'getAllRoutes',\n\t        value: function getAllRoutes() {\n\t            return allRoutes;\n\t        }\n\t    }, {\n\t        key: 'getAllTimetables',\n\t        value: function getAllTimetables() {\n\t            return allTimetables;\n\t        }\n\t    }, {\n\t        key: 'getAllStationsJSON',\n\t        value: function getAllStationsJSON() {\n\t            return allStationsJSON;\n\t        }\n\t    }, {\n\t        key: 'getAllRoutesJSON',\n\t        value: function getAllRoutesJSON() {\n\t            return allRoutesJSON;\n\t        }\n\t    }, {\n\t        key: 'getAllTimetablesJSON',\n\t        value: function getAllTimetablesJSON() {\n\t            return allTimetablesJSON;\n\t        }\n\t    }, {\n\t        key: 'loadDataAndInitialize',\n\t        value: function () {\n\t            var _ref3 = _asyncToGenerator(_regenerator2.default.mark(function _callee3() {\n\t                return _regenerator2.default.wrap(function _callee3$(_context3) {\n\t                    while (1) {\n\t                        switch (_context3.prev = _context3.next) {\n\t                            case 0:\n\t                                _context3.next = 2;\n\t                                return loadData();\n\t\n\t                            case 2:\n\t                            case 'end':\n\t                                return _context3.stop();\n\t                        }\n\t                    }\n\t                }, _callee3, this);\n\t            }));\n\t\n\t            function loadDataAndInitialize() {\n\t                return _ref3.apply(this, arguments);\n\t            }\n\t\n\t            return loadDataAndInitialize;\n\t        }()\n\t    }, {\n\t        key: 'loadDataOnly',\n\t        value: function () {\n\t            var _ref4 = _asyncToGenerator(_regenerator2.default.mark(function _callee4() {\n\t                return _regenerator2.default.wrap(function _callee4$(_context4) {\n\t                    while (1) {\n\t                        switch (_context4.prev = _context4.next) {\n\t                            case 0:\n\t                                _context4.next = 2;\n\t                                return _loadDataOnly();\n\t\n\t                            case 2:\n\t                            case 'end':\n\t                                return _context4.stop();\n\t                        }\n\t                    }\n\t                }, _callee4, this);\n\t            }));\n\t\n\t            function loadDataOnly() {\n\t                return _ref4.apply(this, arguments);\n\t            }\n\t\n\t            return loadDataOnly;\n\t        }()\n\t    }]);\n\t\n\t    return MyDatabase;\n\t}();\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End load data.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\t//export default {getAllStations, getAllRoutes, getAllTimetables, getAllStationsJSON, getAllRoutesJSON, getAllTimetablesJSON, loadData};\n\t\n\t\n\texports.default = MyDatabase;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _regenerator = __webpack_require__(1);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar getJsonFromUrl = function () {\n\t    var _ref6 = _asyncToGenerator(_regenerator2.default.mark(function _callee6(strReq) {\n\t        var response;\n\t        return _regenerator2.default.wrap(function _callee6$(_context6) {\n\t            while (1) {\n\t                switch (_context6.prev = _context6.next) {\n\t                    case 0:\n\t                        _context6.next = 2;\n\t                        return fetch(strReq);\n\t\n\t                    case 2:\n\t                        response = _context6.sent;\n\t                        _context6.next = 5;\n\t                        return response.json();\n\t\n\t                    case 5:\n\t                        return _context6.abrupt('return', _context6.sent);\n\t\n\t                    case 6:\n\t                    case 'end':\n\t                        return _context6.stop();\n\t                }\n\t            }\n\t        }, _callee6, this);\n\t    }));\n\t\n\t    return function getJsonFromUrl(_x9) {\n\t        return _ref6.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar getCountedOnServerWays = function () {\n\t    var _ref7 = _asyncToGenerator(_regenerator2.default.mark(function _callee7(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr) {\n\t        var paramsStr, data;\n\t        return _regenerator2.default.wrap(function _callee7$(_context7) {\n\t            while (1) {\n\t                switch (_context7.prev = _context7.next) {\n\t                    case 0:\n\t                        paramsStr = \"?from=\" + fromPositionStr + \"&to=\" + toPositionStr + \"&startTime=\" + myStartTimeStr + \"&dopTimeMinutes=\" + my_dopTimeMinutes + \"&goingSpeed=\" + my_speed + \"&transportTypes=\" + typesStr;\n\t                        _context7.next = 3;\n\t                        return getJsonFromUrl(apiPublicTransportServer + \"optimalRoute\" + paramsStr);\n\t\n\t                    case 3:\n\t                        data = _context7.sent;\n\t\n\t\n\t                        AppClient.findedOptimalWays = data;\n\t\n\t                        console.log(\"Finded \" + AppClient.findedOptimalWays.length + \" optimal routes.\");\n\t                        return _context7.abrupt('return', data);\n\t\n\t                    case 7:\n\t                    case 'end':\n\t                        return _context7.stop();\n\t                }\n\t            }\n\t        }, _callee7, this);\n\t    }));\n\t\n\t    return function getCountedOnServerWays(_x10, _x11, _x12, _x13, _x14, _x15) {\n\t        return _ref7.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar getCountedOnClientWays = function () {\n\t    var _ref8 = _asyncToGenerator(_regenerator2.default.mark(function _callee8(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr) {\n\t        var startOptimalRoutePoint, finalOptimalRoutePoint, myStartTime, types, startInitializingMoment, res;\n\t        return _regenerator2.default.wrap(function _callee8$(_context8) {\n\t            while (1) {\n\t                switch (_context8.prev = _context8.next) {\n\t                    case 0:\n\t                        console.log(\"Start local counting...\");\n\t\n\t                        _context8.next = 3;\n\t                        return _loadData2.default.loadDataAndInitialize();\n\t\n\t                    case 3:\n\t                        startOptimalRoutePoint = strToCoords(fromPositionStr);\n\t                        finalOptimalRoutePoint = strToCoords(toPositionStr);\n\t                        myStartTime = strToSeconds(myStartTimeStr);\n\t\n\t                        if (!(startOptimalRoutePoint === undefined || finalOptimalRoutePoint === undefined || myStartTime === undefined)) {\n\t                            _context8.next = 8;\n\t                            break;\n\t                        }\n\t\n\t                        return _context8.abrupt('return', null);\n\t\n\t                    case 8:\n\t                        types = null;\n\t\n\t                        if (typesStr !== undefined) types = typesStr.split(',');\n\t                        if (types === undefined || types == null) types = [\"bus\", \"trolleybus\"];\n\t\n\t                        startInitializingMoment = Date.now();\n\t                        res = new _optimalRoutesCollection2.default(startOptimalRoutePoint, finalOptimalRoutePoint, myStartTime, types, parseFloat(my_speed), parseFloat(my_dopTimeMinutes));\n\t\n\t                        AppClient.findedOptimalWays = res.getOptimalWays();\n\t\n\t                        console.log(\"Finded \" + AppClient.findedOptimalWays.length + \" optimal routes. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t\n\t                        return _context8.abrupt('return', AppClient.findedOptimalWays);\n\t\n\t                    case 16:\n\t                    case 'end':\n\t                        return _context8.stop();\n\t                }\n\t            }\n\t        }, _callee8, this);\n\t    }));\n\t\n\t    return function getCountedOnClientWays(_x16, _x17, _x18, _x19, _x20, _x21) {\n\t        return _ref8.apply(this, arguments);\n\t    };\n\t}();\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End client.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar _optimalRoutesCollection = __webpack_require__(10);\n\t\n\tvar _optimalRoutesCollection2 = _interopRequireDefault(_optimalRoutesCollection);\n\t\n\tvar _loadData = __webpack_require__(4);\n\t\n\tvar _loadData2 = _interopRequireDefault(_loadData);\n\t\n\tvar _apiConfig = __webpack_require__(3);\n\t\n\tvar _apiConfig2 = _interopRequireDefault(_apiConfig);\n\t\n\tvar _pointsHistoryStorage = __webpack_require__(7);\n\t\n\tvar _pointsHistoryStorage2 = _interopRequireDefault(_pointsHistoryStorage);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar apiPublicTransportServer = _apiConfig2.default.apiPublicTransportServer;\n\t\n\t\n\t//import './install-service-worker.js';\n\t\n\tif (navigator.onLine === undefined || navigator.onLine === false) {\n\t    _loadData2.default.loadDataAndInitialize();\n\t} else {\n\t    _loadData2.default.loadDataOnly();\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Client.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\tvar AppClient = function () {\n\t    function AppClient() {\n\t        _classCallCheck(this, AppClient);\n\t    }\n\t\n\t    _createClass(AppClient, null, [{\n\t        key: 'findWays',\n\t\n\t\n\t        // Find optimal ways between two points. The start time, reserved time, going speed and transport types are known.\n\t        value: function () {\n\t            var _ref = _asyncToGenerator(_regenerator2.default.mark(function _callee(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr) {\n\t                var findedOptimalWays, i;\n\t                return _regenerator2.default.wrap(function _callee$(_context) {\n\t                    while (1) {\n\t                        switch (_context.prev = _context.next) {\n\t                            case 0:\n\t                                findedOptimalWays = null;\n\t                                _context.prev = 1;\n\t                                _context.next = 4;\n\t                                return getCountedOnServerWays(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr);\n\t\n\t                            case 4:\n\t                                findedOptimalWays = _context.sent;\n\t                                _context.next = 12;\n\t                                break;\n\t\n\t                            case 7:\n\t                                _context.prev = 7;\n\t                                _context.t0 = _context['catch'](1);\n\t                                _context.next = 11;\n\t                                return getCountedOnClientWays(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr);\n\t\n\t                            case 11:\n\t                                findedOptimalWays = _context.sent;\n\t\n\t                            case 12:\n\t                                _context.prev = 12;\n\t\n\t                                if (findedOptimalWays != null && findedOptimalWays.length !== 0) {\n\t                                    AppClient.findedOptimalWays = findedOptimalWays;\n\t\n\t                                    AppClient.minimalTimeSeconds = parseFloat(AppClient.findedOptimalWays[0].totalTimeSeconds);\n\t                                    AppClient.minimalGoingTimeSeconds = parseFloat(AppClient.findedOptimalWays[0].totalGoingTimeSeconds);\n\t                                    AppClient.minimalTransportChangingCount = parseFloat(AppClient.findedOptimalWays[0].totalTransportChangingCount);\n\t                                    for (i = 1; i < AppClient.findedOptimalWays.length; i++) {\n\t                                        if (parseFloat(AppClient.findedOptimalWays[i].totalTimeSeconds) < AppClient.minimalTimeSeconds) AppClient.minimalTimeSeconds = parseFloat(AppClient.findedOptimalWays[i].totalTimeSeconds);\n\t                                        if (parseFloat(AppClient.findedOptimalWays[i].totalGoingTimeSeconds) < AppClient.minimalGoingTimeSeconds) AppClient.minimalGoingTimeSeconds = parseFloat(AppClient.findedOptimalWays[i].totalGoingTimeSeconds);\n\t                                        if (parseFloat(AppClient.findedOptimalWays[i].totalTransportChangingCount) < AppClient.minimalTransportChangingCount) AppClient.minimalTransportChangingCount = parseFloat(AppClient.findedOptimalWays[i].totalTransportChangingCount);\n\t                                    }\n\t                                    if (AppClient.minimalTransportChangingCount < 1) AppClient.minimalTransportChangingCount = 1;\n\t                                }\n\t                                return _context.abrupt('return', findedOptimalWays);\n\t\n\t                            case 16:\n\t                            case 'end':\n\t                                return _context.stop();\n\t                        }\n\t                    }\n\t                }, _callee, this, [[1, 7, 12, 16]]);\n\t            }));\n\t\n\t            function findWays(_x, _x2, _x3, _x4, _x5, _x6) {\n\t                return _ref.apply(this, arguments);\n\t            }\n\t\n\t            return findWays;\n\t        }()\n\t\n\t        // Sort the finded ways with the importance of each criterion.\n\t\n\t        /*static totalTimePercent = 1;\r\n\t        static totalGoingTimePercent = 1;\r\n\t        static totalTransportChangingCountPercent = 1;*/\n\t\n\t        /*static isStartFinalPointsSelected() {\r\n\t            return AppClient.startOptimalRoutePoint != null && AppClient.finalOptimalRoutePoint != null;\r\n\t        }\r\n\t        static countWayButtonClicked = false;\r\n\t        static isCountWayButtonClicked() {\r\n\t            return AppClient.countWayButtonClicked;\r\n\t        }*/\n\t\n\t    }, {\n\t        key: 'customizeFindedOptimalWaysStart',\n\t        value: function customizeFindedOptimalWaysStart(totalTimePercentValue, totalGoingTimePercentValue, totalTransportChangingCountPercentValue) {\n\t            if (AppClient.findedOptimalWays != null) {\n\t                /*AppClient.totalTimePercent = totalTimePercentValue;\r\n\t                AppClient.totalGoingTimePercent = totalGoingTimePercentValue;\r\n\t                AppClient.totalTransportChangingCountPercent = totalTransportChangingCountPercentValue;*/\n\t\n\t                var sortedArr = [];\n\t                var newSortedFindedWays = [];\n\t\n\t                var tmpTransportChangingCountEffictivity = 0;\n\t                var max_rank = 0;\n\t                var index = -1;\n\t                for (var j = 0; j < AppClient.findedOptimalWays.length /* && j < 3*/; j++) {\n\t                    max_rank = 0; //!!!\n\t                    index = -1;\n\t                    for (var i = 0; i < AppClient.findedOptimalWays.length; i++) {\n\t                        if (sortedArr.indexOf(i) === -1) {\n\t                            tmpTransportChangingCountEffictivity = parseFloat(AppClient.findedOptimalWays[i].totalTransportChangingCount) === 0 ? 1 : AppClient.minimalTransportChangingCount / parseFloat(AppClient.findedOptimalWays[i].totalTransportChangingCount);\n\t                            var tmp_rank = AppClient.minimalTimeSeconds / parseFloat(AppClient.findedOptimalWays[i].totalTimeSeconds) * totalTimePercentValue + AppClient.minimalGoingTimeSeconds / parseFloat(AppClient.findedOptimalWays[i].totalGoingTimeSeconds) * totalGoingTimePercentValue + tmpTransportChangingCountEffictivity * totalTransportChangingCountPercentValue;\n\t                            if (tmp_rank >= max_rank) {\n\t                                max_rank = tmp_rank;\n\t                                index = i;\n\t                            }\n\t                        }\n\t                    }\n\t                    if (index !== -1) {\n\t                        sortedArr.push(index);\n\t                    }\n\t                }\n\t                for (var _i = 0, n = sortedArr.length, sortedIndex = sortedArr[0]; _i < n; sortedIndex = sortedArr[++_i]) {\n\t                    newSortedFindedWays.push(AppClient.findedOptimalWays[sortedIndex]);\n\t                }\n\t                AppClient.findedOptimalWays = newSortedFindedWays;\n\t\n\t                return AppClient.findedOptimalWays;\n\t            } else {\n\t                throw new Error('Can`t customize optimal ways, because it`s not finded yet.');\n\t            }\n\t        }\n\t    }, {\n\t        key: 'findCurrentDestinationCoords',\n\t        value: function () {\n\t            var _ref2 = _asyncToGenerator(_regenerator2.default.mark(function _callee3() {\n\t                var getCurrentPosition, position, findedLat, findedLng, coords, lastCnownPositionCoordsDescription, searchingPoint, resultCoords;\n\t                return _regenerator2.default.wrap(function _callee3$(_context3) {\n\t                    while (1) {\n\t                        switch (_context3.prev = _context3.next) {\n\t                            case 0:\n\t                                if (!navigator.geolocation) {\n\t                                    _context3.next = 22;\n\t                                    break;\n\t                                }\n\t\n\t                                getCurrentPosition = function () {\n\t                                    var _ref3 = _asyncToGenerator(_regenerator2.default.mark(function _callee2() {\n\t                                        var promise;\n\t                                        return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t                                            while (1) {\n\t                                                switch (_context2.prev = _context2.next) {\n\t                                                    case 0:\n\t                                                        promise = new Promise(function (resolve, reject) {\n\t                                                            navigator.geolocation.getCurrentPosition(resolve, reject);\n\t                                                        });\n\t                                                        _context2.next = 3;\n\t                                                        return promise;\n\t\n\t                                                    case 3:\n\t                                                        return _context2.abrupt('return', _context2.sent);\n\t\n\t                                                    case 4:\n\t                                                    case 'end':\n\t                                                        return _context2.stop();\n\t                                                }\n\t                                            }\n\t                                        }, _callee2, this);\n\t                                    }));\n\t\n\t                                    return function getCurrentPosition() {\n\t                                        return _ref3.apply(this, arguments);\n\t                                    };\n\t                                }();\n\t\n\t                                _context3.next = 4;\n\t                                return getCurrentPosition();\n\t\n\t                            case 4:\n\t                                position = _context3.sent;\n\t\n\t                                if (!(position === undefined || position == null)) {\n\t                                    _context3.next = 7;\n\t                                    break;\n\t                                }\n\t\n\t                                return _context3.abrupt('return', null);\n\t\n\t                            case 7:\n\t                                findedLat = parseFloat(position.coords.latitude.toFixed(4));\n\t                                findedLng = parseFloat(position.coords.longitude.toFixed(4));\n\t\n\t\n\t                                localStorage[\"lastCnownPositionCoords\"] = findedLat + \",\" + findedLng;\n\t\n\t                                coords = { lat: findedLat, lng: findedLng };\n\t                                _context3.next = 13;\n\t                                return AppClient.getDesinationDescription(coords);\n\t\n\t                            case 13:\n\t                                lastCnownPositionCoordsDescription = _context3.sent;\n\t\n\t                                if (!(lastCnownPositionCoordsDescription == null)) {\n\t                                    _context3.next = 19;\n\t                                    break;\n\t                                }\n\t\n\t                                _context3.next = 17;\n\t                                return _pointsHistoryStorage2.default.tryFindByCoords(coords);\n\t\n\t                            case 17:\n\t                                searchingPoint = _context3.sent;\n\t\n\t                                if (searchingPoint != null) {\n\t                                    lastCnownPositionCoordsDescription = searchingPoint.description;\n\t                                } else {\n\t                                    lastCnownPositionCoordsDescription = \"[\" + findedLat + \", \" + findedLng + \"]\";\n\t                                }\n\t\n\t                            case 19:\n\t                                localStorage[\"lastCnownPositionCoordsDescription\"] = lastCnownPositionCoordsDescription;\n\t\n\t                                resultCoords = { lat: findedLat, lng: findedLng };\n\t                                return _context3.abrupt('return', resultCoords);\n\t\n\t                            case 22:\n\t                                return _context3.abrupt('return', null);\n\t\n\t                            case 23:\n\t                            case 'end':\n\t                                return _context3.stop();\n\t                        }\n\t                    }\n\t                }, _callee3, this);\n\t            }));\n\t\n\t            function findCurrentDestinationCoords() {\n\t                return _ref2.apply(this, arguments);\n\t            }\n\t\n\t            return findCurrentDestinationCoords;\n\t        }()\n\t    }, {\n\t        key: 'findPointsByOsmGeocodingApi',\n\t        value: function () {\n\t            var _ref4 = _asyncToGenerator(_regenerator2.default.mark(function _callee4(strReq) {\n\t                var data, resultPoints, i, n, currentPoint;\n\t                return _regenerator2.default.wrap(function _callee4$(_context4) {\n\t                    while (1) {\n\t                        switch (_context4.prev = _context4.next) {\n\t                            case 0:\n\t                                _context4.prev = 0;\n\t                                _context4.next = 3;\n\t                                return getJsonFromUrl(\"https://nominatim.openstreetmap.org/search?q=\" + strReq + \"&format=json\");\n\t\n\t                            case 3:\n\t                                data = _context4.sent;\n\t\n\t                                if (!(data != null && data.length !== 0)) {\n\t                                    _context4.next = 9;\n\t                                    break;\n\t                                }\n\t\n\t                                resultPoints = [];\n\t\n\t                                for (i = 0, n = data.length, currentPoint = data[0]; i < n; currentPoint = data[++i]) {\n\t                                    resultPoints.push({\n\t                                        coords: { lat: parseFloat(currentPoint.lat), lng: parseFloat(currentPoint.lon) },\n\t                                        description: currentPoint.display_name\n\t                                    });\n\t                                }\n\t                                _pointsHistoryStorage2.default.tryPush(resultPoints[0]);\n\t                                return _context4.abrupt('return', resultPoints);\n\t\n\t                            case 9:\n\t                                return _context4.abrupt('return', null);\n\t\n\t                            case 12:\n\t                                _context4.prev = 12;\n\t                                _context4.t0 = _context4['catch'](0);\n\t                                return _context4.abrupt('return', null);\n\t\n\t                            case 15:\n\t                            case 'end':\n\t                                return _context4.stop();\n\t                        }\n\t                    }\n\t                }, _callee4, this, [[0, 12]]);\n\t            }));\n\t\n\t            function findPointsByOsmGeocodingApi(_x7) {\n\t                return _ref4.apply(this, arguments);\n\t            }\n\t\n\t            return findPointsByOsmGeocodingApi;\n\t        }()\n\t    }, {\n\t        key: 'getDesinationDescription',\n\t        value: function () {\n\t            var _ref5 = _asyncToGenerator(_regenerator2.default.mark(function _callee5(coords) {\n\t                var findedPoints;\n\t                return _regenerator2.default.wrap(function _callee5$(_context5) {\n\t                    while (1) {\n\t                        switch (_context5.prev = _context5.next) {\n\t                            case 0:\n\t                                _context5.prev = 0;\n\t                                _context5.next = 3;\n\t                                return AppClient.findPointsByOsmGeocodingApi(coords.lat + \",\" + coords.lng);\n\t\n\t                            case 3:\n\t                                findedPoints = _context5.sent;\n\t\n\t                                if (!(findedPoints != null)) {\n\t                                    _context5.next = 6;\n\t                                    break;\n\t                                }\n\t\n\t                                return _context5.abrupt('return', findedPoints[0].description);\n\t\n\t                            case 6:\n\t                                return _context5.abrupt('return', null);\n\t\n\t                            case 9:\n\t                                _context5.prev = 9;\n\t                                _context5.t0 = _context5['catch'](0);\n\t                                return _context5.abrupt('return', null);\n\t\n\t                            case 12:\n\t                            case 'end':\n\t                                return _context5.stop();\n\t                        }\n\t                    }\n\t                }, _callee5, this, [[0, 9]]);\n\t            }));\n\t\n\t            function getDesinationDescription(_x8) {\n\t                return _ref5.apply(this, arguments);\n\t            }\n\t\n\t            return getDesinationDescription;\n\t        }()\n\t    }]);\n\t\n\t    return AppClient;\n\t}();\n\t\n\tAppClient.startOptimalRoutePoint = null;\n\tAppClient.finalOptimalRoutePoint = null;\n\tAppClient.myCurrentFindedPosition = null;\n\tAppClient.findedOptimalWays = null;\n\tAppClient.minimalTimeSeconds = 0;\n\tAppClient.minimalGoingTimeSeconds = 0;\n\tAppClient.minimalTransportChangingCount = 0;\n\tAppClient.fromPosition = null;\n\tAppClient.toPosition = null;\n\tAppClient.myStartTime = 0;\n\tAppClient.types = [\"bus\", \"trolleybus\"];\n\tAppClient.my_speed = 5;\n\tAppClient.my_dopTimeMinutes = 2;\n\t\n\t\n\tfunction strToCoords(str) {\n\t    if (str === undefined || str == null) return undefined;\n\t    var tmp = str.split(',');\n\t    var myLat = parseFloat(tmp[0]);\n\t    var myLng = parseFloat(tmp[1]);\n\t    if (myLat >= -90 && myLat <= 90 && myLng >= -180 && myLng <= 180) return { lat: myLat, lng: myLng };else return undefined;\n\t}\n\tfunction strToSeconds(str) {\n\t    if (str === undefined || str == null) return undefined;\n\t    var tmp = str.split(':');\n\t    var hours = parseInt(tmp[0], 10);\n\t    var minutes = parseInt(tmp[1], 10);\n\t    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) return 3600 * hours + 60 * minutes;else return undefined;\n\t}\n\t\n\texports.default = AppClient;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _regenerator = __webpack_require__(1);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar getPointsHistoryStorageConnection = function () {\n\t    var _ref = _asyncToGenerator(_regenerator2.default.mark(function _callee2() {\n\t        var promise;\n\t        return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t            while (1) {\n\t                switch (_context2.prev = _context2.next) {\n\t                    case 0:\n\t                        promise = new Promise(function (resolve, reject) {\n\t                            var request = indexedDB.open(dbName, 1);\n\t                            request.onerror = function (event) {\n\t                                reject(event.target.error);\n\t                            };\n\t                            request.onsuccess = function (event) {\n\t                                resolve(event.target.result);\n\t                            };\n\t                            request.onupgradeneeded = function () {\n\t                                var _ref2 = _asyncToGenerator(_regenerator2.default.mark(function _callee(event) {\n\t                                    var db, objectStore, result;\n\t                                    return _regenerator2.default.wrap(function _callee$(_context) {\n\t                                        while (1) {\n\t                                            switch (_context.prev = _context.next) {\n\t                                                case 0:\n\t                                                    db = event.target.result;\n\t                                                    objectStore = db.createObjectStore(storeName, { keyPath: \"key\", autoIncrement: true });\n\t\n\t                                                    objectStore.createIndex(\"description\", \"description\", { unique: true });\n\t                                                    objectStore.createIndex(\"lat\", \"lat\", { unique: false });\n\t                                                    objectStore.createIndex(\"lng\", \"lng\", { unique: false });\n\t\n\t                                                    _context.next = 7;\n\t                                                    return getPointsHistoryStorageConnection();\n\t\n\t                                                case 7:\n\t                                                    result = _context.sent;\n\t\n\t                                                    resolve(result);\n\t\n\t                                                case 9:\n\t                                                case \"end\":\n\t                                                    return _context.stop();\n\t                                            }\n\t                                        }\n\t                                    }, _callee, this);\n\t                                }));\n\t\n\t                                return function (_x) {\n\t                                    return _ref2.apply(this, arguments);\n\t                                };\n\t                            }();\n\t                        });\n\t                        _context2.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context2.abrupt(\"return\", _context2.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context2.stop();\n\t                }\n\t            }\n\t        }, _callee2, this);\n\t    }));\n\t\n\t    return function getPointsHistoryStorageConnection() {\n\t        return _ref.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar _getAllPoints = function () {\n\t    var _ref3 = _asyncToGenerator(_regenerator2.default.mark(function _callee4() {\n\t        var promise;\n\t        return _regenerator2.default.wrap(function _callee4$(_context4) {\n\t            while (1) {\n\t                switch (_context4.prev = _context4.next) {\n\t                    case 0:\n\t                        promise = new Promise(function () {\n\t                            var _ref4 = _asyncToGenerator(_regenerator2.default.mark(function _callee3(resolve, reject) {\n\t                                var items, db, transaction, objectStore, request;\n\t                                return _regenerator2.default.wrap(function _callee3$(_context3) {\n\t                                    while (1) {\n\t                                        switch (_context3.prev = _context3.next) {\n\t                                            case 0:\n\t                                                items = [];\n\t                                                _context3.next = 3;\n\t                                                return getPointsHistoryStorageConnection();\n\t\n\t                                            case 3:\n\t                                                db = _context3.sent;\n\t\n\t                                                //console.log(db);\n\t                                                transaction = db.transaction([storeName]);\n\t                                                objectStore = transaction.objectStore(storeName);\n\t\n\t                                                //let request = objectStore.getAll();\n\t\n\t                                                request = objectStore.openCursor();\n\t\n\t                                                request.onsuccess = function (evt) {\n\t                                                    var cursor = evt.target.result;\n\t                                                    if (cursor) {\n\t                                                        items.push(cursor.value);\n\t                                                        cursor.continue();\n\t                                                    } else resolve(items);\n\t                                                };\n\t                                                request.onerror = function (event) {\n\t                                                    reject(event.target.error);\n\t                                                };\n\t\n\t                                            case 9:\n\t                                            case \"end\":\n\t                                                return _context3.stop();\n\t                                        }\n\t                                    }\n\t                                }, _callee3, this);\n\t                            }));\n\t\n\t                            return function (_x2, _x3) {\n\t                                return _ref4.apply(this, arguments);\n\t                            };\n\t                        }());\n\t                        _context4.next = 3;\n\t                        return promise;\n\t\n\t                    case 3:\n\t                        return _context4.abrupt(\"return\", _context4.sent);\n\t\n\t                    case 4:\n\t                    case \"end\":\n\t                        return _context4.stop();\n\t                }\n\t            }\n\t        }, _callee4, this);\n\t    }));\n\t\n\t    return function _getAllPoints() {\n\t        return _ref3.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar _tryFindByCoords = function () {\n\t    var _ref5 = _asyncToGenerator(_regenerator2.default.mark(function _callee5(coords) {\n\t        var pointsHistory, candidate, i, n, currentPoint, findedDistance, currentDistance;\n\t        return _regenerator2.default.wrap(function _callee5$(_context5) {\n\t            while (1) {\n\t                switch (_context5.prev = _context5.next) {\n\t                    case 0:\n\t                        _context5.next = 2;\n\t                        return _getAllPoints();\n\t\n\t                    case 2:\n\t                        pointsHistory = _context5.sent;\n\t                        candidate = null;\n\t\n\t                        for (i = 0, n = pointsHistory.length, currentPoint = pointsHistory[0], findedDistance = 150; i < n; currentPoint = pointsHistory[++i]) {\n\t                            currentDistance = _geoCoords2.default.distance(coords, { lat: currentPoint.lat, lng: currentPoint.lng });\n\t\n\t                            if (currentDistance < findedDistance) {\n\t                                findedDistance = currentDistance;\n\t                                candidate = currentPoint;\n\t                            }\n\t                        }\n\t                        return _context5.abrupt(\"return\", candidate);\n\t\n\t                    case 6:\n\t                    case \"end\":\n\t                        return _context5.stop();\n\t                }\n\t            }\n\t        }, _callee5, this);\n\t    }));\n\t\n\t    return function _tryFindByCoords(_x4) {\n\t        return _ref5.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar _tryPush = function () {\n\t    var _ref6 = _asyncToGenerator(_regenerator2.default.mark(function _callee7(point) {\n\t        var pointsHistory, i, n, currentPoint, promise;\n\t        return _regenerator2.default.wrap(function _callee7$(_context7) {\n\t            while (1) {\n\t                switch (_context7.prev = _context7.next) {\n\t                    case 0:\n\t                        _context7.next = 2;\n\t                        return _getAllPoints();\n\t\n\t                    case 2:\n\t                        pointsHistory = _context7.sent;\n\t                        i = 0, n = pointsHistory.length, currentPoint = pointsHistory[0];\n\t\n\t                    case 4:\n\t                        if (!(i < n)) {\n\t                            _context7.next = 10;\n\t                            break;\n\t                        }\n\t\n\t                        if (!(_geoCoords2.default.distance(point.coords, { lat: currentPoint.lat, lng: currentPoint.lng }) < 50)) {\n\t                            _context7.next = 7;\n\t                            break;\n\t                        }\n\t\n\t                        return _context7.abrupt(\"return\", null);\n\t\n\t                    case 7:\n\t                        currentPoint = pointsHistory[++i];\n\t                        _context7.next = 4;\n\t                        break;\n\t\n\t                    case 10:\n\t                        promise = new Promise(function () {\n\t                            var _ref7 = _asyncToGenerator(_regenerator2.default.mark(function _callee6(resolve, reject) {\n\t                                var db, transaction, objectStore, request;\n\t                                return _regenerator2.default.wrap(function _callee6$(_context6) {\n\t                                    while (1) {\n\t                                        switch (_context6.prev = _context6.next) {\n\t                                            case 0:\n\t                                                _context6.next = 2;\n\t                                                return getPointsHistoryStorageConnection();\n\t\n\t                                            case 2:\n\t                                                db = _context6.sent;\n\t\n\t                                                //console.log(db);\n\t                                                transaction = db.transaction([storeName], \"readwrite\");\n\t                                                objectStore = transaction.objectStore(storeName);\n\t                                                request = objectStore.add({\n\t                                                    lat: point.coords.lat,\n\t                                                    lng: point.coords.lng,\n\t                                                    description: point.description\n\t                                                });\n\t\n\t                                                request.onerror = function (event) {\n\t                                                    reject(event.target.error);\n\t                                                };\n\t                                                request.onsuccess = function (event) {\n\t                                                    resolve(event.target.result);\n\t                                                };\n\t\n\t                                            case 8:\n\t                                            case \"end\":\n\t                                                return _context6.stop();\n\t                                        }\n\t                                    }\n\t                                }, _callee6, this);\n\t                            }));\n\t\n\t                            return function (_x6, _x7) {\n\t                                return _ref7.apply(this, arguments);\n\t                            };\n\t                        }());\n\t                        _context7.next = 13;\n\t                        return promise;\n\t\n\t                    case 13:\n\t                        return _context7.abrupt(\"return\", _context7.sent);\n\t\n\t                    case 14:\n\t                    case \"end\":\n\t                        return _context7.stop();\n\t                }\n\t            }\n\t        }, _callee7, this);\n\t    }));\n\t\n\t    return function _tryPush(_x5) {\n\t        return _ref6.apply(this, arguments);\n\t    };\n\t}();\n\t\n\tvar _geoCoords = __webpack_require__(2);\n\t\n\tvar _geoCoords2 = _interopRequireDefault(_geoCoords);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tvar dbName = \"public_transport\";\n\tvar storeName = \"points_history\";\n\t\n\tvar PointsHistoryStorage = function () {\n\t    function PointsHistoryStorage() {\n\t        _classCallCheck(this, PointsHistoryStorage);\n\t    }\n\t\n\t    _createClass(PointsHistoryStorage, null, [{\n\t        key: \"getAllPoints\",\n\t        value: function () {\n\t            var _ref8 = _asyncToGenerator(_regenerator2.default.mark(function _callee8() {\n\t                return _regenerator2.default.wrap(function _callee8$(_context8) {\n\t                    while (1) {\n\t                        switch (_context8.prev = _context8.next) {\n\t                            case 0:\n\t                                _context8.next = 2;\n\t                                return _getAllPoints();\n\t\n\t                            case 2:\n\t                                return _context8.abrupt(\"return\", _context8.sent);\n\t\n\t                            case 3:\n\t                            case \"end\":\n\t                                return _context8.stop();\n\t                        }\n\t                    }\n\t                }, _callee8, this);\n\t            }));\n\t\n\t            function getAllPoints() {\n\t                return _ref8.apply(this, arguments);\n\t            }\n\t\n\t            return getAllPoints;\n\t        }()\n\t    }, {\n\t        key: \"tryPush\",\n\t        value: function () {\n\t            var _ref9 = _asyncToGenerator(_regenerator2.default.mark(function _callee9(point) {\n\t                return _regenerator2.default.wrap(function _callee9$(_context9) {\n\t                    while (1) {\n\t                        switch (_context9.prev = _context9.next) {\n\t                            case 0:\n\t                                _context9.next = 2;\n\t                                return _tryPush(point);\n\t\n\t                            case 2:\n\t                                return _context9.abrupt(\"return\", _context9.sent);\n\t\n\t                            case 3:\n\t                            case \"end\":\n\t                                return _context9.stop();\n\t                        }\n\t                    }\n\t                }, _callee9, this);\n\t            }));\n\t\n\t            function tryPush(_x8) {\n\t                return _ref9.apply(this, arguments);\n\t            }\n\t\n\t            return tryPush;\n\t        }()\n\t    }, {\n\t        key: \"tryFindByCoords\",\n\t        value: function () {\n\t            var _ref10 = _asyncToGenerator(_regenerator2.default.mark(function _callee10(coords) {\n\t                return _regenerator2.default.wrap(function _callee10$(_context10) {\n\t                    while (1) {\n\t                        switch (_context10.prev = _context10.next) {\n\t                            case 0:\n\t                                _context10.next = 2;\n\t                                return _tryFindByCoords(coords);\n\t\n\t                            case 2:\n\t                                return _context10.abrupt(\"return\", _context10.sent);\n\t\n\t                            case 3:\n\t                            case \"end\":\n\t                                return _context10.stop();\n\t                        }\n\t                    }\n\t                }, _callee10, this);\n\t            }));\n\t\n\t            function tryFindByCoords(_x9) {\n\t                return _ref10.apply(this, arguments);\n\t            }\n\t\n\t            return tryFindByCoords;\n\t        }()\n\t    }]);\n\t\n\t    return PointsHistoryStorage;\n\t}();\n\t\n\texports.default = PointsHistoryStorage;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t//require('./loadData');\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// Initailize.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\t//global.initialized = false;\n\t\n\t\n\tfunction getNextStation(currentStation) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n\t            if (this.stations[j][t] === currentStation) {\n\t                if (t + 1 !== nn) return this.stations[j][t + 1];else return null;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction getPreviousStation(currentStation) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var t = 0, nn = this.stations[j].length; t < nn; t++) {\n\t            if (this.stations[j][t] === currentStation) {\n\t                if (t !== nn) return this.stations[j][t - 1];else return null;\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction getTimetable(station) {\n\t    for (var j = 0; j <= 1; j++) {\n\t        for (var i = 0, n = this.stations[j].length; i < n; i++) {\n\t            if (this.stations[j][i] === station) {\n\t                return this.timetables[j][i];\n\t            }\n\t        }\n\t    }\n\t    return null;\n\t}\n\tfunction findTimeAfter(time) {\n\t    var dateTmp = new Date();\n\t    dateTmp.setMinutes(0);\n\t    dateTmp.setHours(0);\n\t    dateTmp.setSeconds(time);\n\t    var day = dateTmp.getDay();\n\t    //foreach (Table t in table)\n\t    for (var kkk = 0, mnkk = this.table.length, t = this.table[0]; kkk < mnkk; t = this.table[++kkk]) {\n\t        if (t.days.includes(day)) {\n\t\n\t            //foreach (SimpleTime st in t.times)\n\t            for (var iik = 0, mnii = t.times.length, st = t.times[0], stTime; iik < mnii; st = t.times[++iik]) {\n\t                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n\t                //\n\t                stTime = st.hour * 3600 + st.minute * 60;\n\t                if (stTime >= time /*.Second + time.Minute * 60 + time.Hour * 3600*/ /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n\t                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n\t                        return stTime - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/;\n\t                    }\n\t            }\n\t            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time /*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/ + 86400;\n\t            break;\n\t        }\n\t    }\n\t    return 2160000000;\n\t    //throw new Exception();\n\t}\n\tfunction findTimeBefore(time) {\n\t    var dateTmp = new Date();\n\t    dateTmp.setMinutes(0);\n\t    dateTmp.setHours(0);\n\t    dateTmp.setSeconds(time);\n\t    var day = dateTmp.getDay();\n\t    for (var kkk = 0, mnkk = this.table.length, t = this.table[0], ok = false, st; kkk < mnkk; t = this.table[++kkk]) {\n\t        if (t.days.includes(day)) {\n\t            ok = false;\n\t            st = null;\n\t            for (var iik = 0, mnii = t.times.length, stt = t.times[0]; iik < mnii; stt = t.times[++iik]) {\n\t                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\n\t                //\n\t                if (stt.hour * 3600 + stt.minute * 60 <= time /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\n\t                        ok = true;\n\t                        st = stt;\n\t                        //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\n\t                    } else break;\n\t            }\n\t            if (ok) return st.hour * 3600 + st.minute * 60 - time;\n\t            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time - 86400;\n\t            break;\n\t        }\n\t    }\n\t    return 0; //TimeSpan.FromDays(0/*-25000*/);\n\t    //throw new Exception();\n\t}\n\t\n\tfunction initialize(allStations, allRoutes, allTimetables) {\n\t    //alert(allStations.length);\n\t    //alert(allRoutes.length);\n\t    //alert(allTimetables.length);\n\t\n\t    console.log(\"Start initializing...\");\n\t    var startInitializingMoment = Date.now();\n\t\n\t    var tmpUsedStations = [];\n\t\n\t    function bindRoutesStationsTimetables(station, tmpArr, tabArr, rr) {\n\t        if (station.routes == null) station.routes = [];\n\t        //console.log(station.routes);//!!!\n\t        if (!station.routes.includes(rr)) station.routes.push(rr);\n\t        tmpArr.push(station);\n\t\n\t        var tmp = allTimetables.find(function (element, index, array) {\n\t            return element.stationCode === station.hashcode && element.routeCode === rr.hashcode;\n\t        });\n\t        var tmpTab = tmp == null ? null : tmp;\n\t\n\t        tabArr.push(tmpTab);\n\t    }\n\t\n\t    for (var i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\n\t        if (currentStation.routesCodes == null || currentStation.routesCodes.length === 0) {\n\t            allStations.splice(i, 1);\n\t            n = allStations.length;\n\t        } else i++;\n\t    }\n\t\n\t    for (var _i = 0, _n = allRoutes.length, rr = allRoutes[0]; _i < _n; rr = allRoutes[++_i]) {\n\t\n\t        rr.getNextStation = getNextStation;\n\t        rr.getPreviousStation = getPreviousStation;\n\t        rr.getTimetable = getTimetable;\n\t\n\t        if (rr.stationsCodes == null || rr.stationsCodes.length === 0) continue;\n\t\n\t        try {\n\t            //if (rr.stationsCodes[rr.stationsCodes.Length - 1] != ']') continue;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t\n\t            rr.stations = [[], []];\n\t            rr.timetables = [[], []];\n\t\n\t            for (var index = 0, tmpArr = [], tabArr = []; index <= 1; index++) {\n\t                var rr_stationsCodes = rr.stationsCodes;\n\t                if (rr_stationsCodes[index] == null || rr_stationsCodes[index].length === 0) continue;\n\t                for (var j = 0, m = rr_stationsCodes[index].length, stationCode = rr_stationsCodes[index][0]; j < m; stationCode = rr_stationsCodes[index][++j]) {\n\t                    var tmpUsed = false;\n\t                    for (var k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\n\t                        if (station != null && station.hashcode === stationCode) {\n\t                            bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\n\t                            tmpUsed = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (!tmpUsed) {\n\t                        for (var _k = 0, _mn = allStations.length, _station = allStations[0]; _k < _mn; _station = allStations[++_k]) {\n\t                            if (_station != null && _station.hashcode === stationCode) {\n\t                                bindRoutesStationsTimetables(_station, tmpArr, tabArr, rr);\n\t                                if (!tmpUsedStations.includes(_station)) tmpUsedStations.push(_station);\n\t                                break;\n\t                            }\n\t                        }\n\t                    }\n\t                }\n\t                rr.stations[index] = tmpArr;\n\t                rr.timetables[index] = tabArr;\n\t            }\n\t        } catch (ex) {\n\t            console.log(ex /*.message*/);\n\t            continue;\n\t        }\n\t    }\n\t\n\t    for (var _i2 = 0, _n2 = allTimetables.length, timetable = allTimetables[0]; _i2 < _n2; timetable = allTimetables[++_i2]) {\n\t        timetable.findTimeAfter = findTimeAfter;\n\t        timetable.findTimeBefore = findTimeBefore;\n\t    }\n\t\n\t    //...\n\t    /*\r\n\t    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n\t        if (currentStation.routes == undefined || currentStation.routes == null || currentStation.routes.length == 0) {\r\n\t            allStations.splice(i, 1);\r\n\t            n = allStations.length;\r\n\t        }\r\n\t        else i++;\r\n\t    }\r\n\t    */\n\t\n\t    console.log(\"Initialized. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t    //console.log(\"\\n\\n\" + JSON.stringify(allTimetables[0]) + \"\\n\\n\");\n\t    //alert(distance({ lat: allStations[0].xCoord, lng: allStations[0].yCoord }, { lat: allStations[5].xCoord, lng: allStations[5].yCoord }));\n\t\n\t\n\t    //for (let t = 0; t < 1000; t++) var ttt = GetStationsAround(allStations[0].coords, 30000).length;\n\t    //console.log(\"test. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\n\t\n\t\n\t    //global.initialized = true;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t// End initailize.\n\t///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\t\n\texports.default = initialize;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t        value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _points = __webpack_require__(13);\n\t\n\tvar _points2 = _interopRequireDefault(_points);\n\t\n\tvar _geoCoords = __webpack_require__(2);\n\t\n\tvar _geoCoords2 = _interopRequireDefault(_geoCoords);\n\t\n\tvar _loadData = __webpack_require__(4);\n\t\n\tvar _loadData2 = _interopRequireDefault(_loadData);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar distance = _geoCoords2.default.distance;\n\t//import IgnoringFragments from './ignoringFragments';\n\t\n\t//import {getAllStations, getAllRoutes, getAllTimetables, getAllStationsJSON, getAllRoutesJSON, getAllTimetablesJSON, loadData} from './loadData';\n\t\n\t\n\tvar allStations = null;\n\t\n\tfunction getStationsAround(coords, radius) {\n\t        if (allStations == null) allStations = _loadData2.default.getAllStations();\n\t        var result = [];\n\t        for (var i = 0, n = allStations.length, s = allStations[0]; i < n; s = allStations[++i]) {\n\t                if (s != null && distance(s.coords, coords) < radius) result.push(s);\n\t        }\n\t        return result;\n\t}\n\t\n\tvar OptimalRoute = function () {\n\t        function OptimalRoute(nowPos, needPos, time, types, goingSpeed, dopTimeMinutes, ignoringRoutesAdd, ignoringList) {\n\t                _classCallCheck(this, OptimalRoute);\n\t\n\t                if (ignoringRoutesAdd != null) this.ignoringRoutes = ignoringRoutesAdd;else this.ignoringRoutes = [];\n\t\n\t                this.points = [];\n\t\n\t                this.needPos = needPos;\n\t                this.nowPos = nowPos;\n\t                this.goingSpeed = goingSpeed;\n\t                this.time = time;\n\t                var reservedTimeSeconds = 60 * dopTimeMinutes;\n\t\n\t                this.types = types;\n\t\n\t                this.myIgnoringFragments = null;\n\t                //if (ignoringList != null) this.myIgnoringFragments = new IgnoringFragments(ignoringList);\n\t                //else this.myIgnoringFragments = new IgnoringFragments();\n\t\n\t                var myPoints = new _points2.default(nowPos, needPos);\n\t                // Получим \"начальный\" список станций:\n\t                var stationsList = getStationsAround(myPoints.startPoint.coords, distance(myPoints.startPoint.coords, myPoints.finalPoint.coords));\n\t                myPoints.fillStartData(stationsList, goingSpeed, reservedTimeSeconds, this.myIgnoringFragments);\n\t\n\t                // Находим кратчайшие пути до всех вершин:\n\t                myPoints.countShortWay(this.ignoringRoutes, this.myIgnoringFragments, time, types, goingSpeed, reservedTimeSeconds);\n\t\n\t                var tmpP = myPoints.finalPoint;\n\t                this.points.push(tmpP.toString()); ////\n\t                while (tmpP.previousPoint != null) {\n\t                        tmpP = tmpP.previousPoint; //\n\t                        this.points.push(tmpP.toString());\n\t                        if (tmpP.previousPoint == null && tmpP.coords !== myPoints.startPoint.coords) throw new Error(\"Где-то удалилась часть маршрута...\");\n\t                }\n\t\n\t                this.totalTimeSeconds = myPoints.finalPoint.totalTimeSeconds;\n\t                this.totalGoingTime = myPoints.finalPoint.getTotalGoingTime();\n\t                this.totalTransportChangingCount = myPoints.finalPoint.getTotalTransportChangingCount();\n\t\n\t                this.myPoints = myPoints;\n\t\n\t                this.isVisited = false;\n\t        }\n\t\n\t        _createClass(OptimalRoute, [{\n\t                key: 'setVisited',\n\t                value: function setVisited() {\n\t                        this.isVisited = true;\n\t                }\n\t        }]);\n\t\n\t        return OptimalRoute;\n\t}();\n\t\n\texports.default = OptimalRoute;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _optimalRoute = __webpack_require__(9);\n\t\n\tvar _optimalRoute2 = _interopRequireDefault(_optimalRoute);\n\t\n\tvar _optimalWay = __webpack_require__(11);\n\t\n\tvar _optimalWay2 = _interopRequireDefault(_optimalWay);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } //import IgnoringFragments from './ignoringFragments';\n\t\n\t\n\tvar OptimalRoutesCollection = function (_Array) {\n\t    _inherits(OptimalRoutesCollection, _Array);\n\t\n\t    /*getOptimalWays() {\r\n\t        var result = [];\r\n\t        for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n\t            result.push(new OptimalWay(r));\r\n\t        }\r\n\t        return result;\r\n\t    }*/\n\t    /*selectOptimalRouteWithMinimalMark() {\r\n\t        var p = null;\r\n\t        for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n\t            if (!(t.isVisited)) {\r\n\t                p = t;\r\n\t                for (t = this[++i]; i < n; t = this[++i]) {\r\n\t                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n\t                        p = t;\r\n\t                    }\r\n\t                }\r\n\t                return p;\r\n\t            }\r\n\t        }\r\n\t        return null;\r\n\t    }*/\n\t    function OptimalRoutesCollection(nowPos, needPos, time, types, speed, dopTimeMinutes) {\n\t        _classCallCheck(this, OptimalRoutesCollection);\n\t\n\t        var _this = _possibleConstructorReturn(this, (OptimalRoutesCollection.__proto__ || Object.getPrototypeOf(OptimalRoutesCollection)).call(this));\n\t\n\t        _this.getOptimalWays = function () {\n\t            var result = [];\n\t            for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\n\t                result.push(new _optimalWay2.default(r));\n\t            }\n\t            return result;\n\t        };\n\t        _this.selectOptimalRouteWithMinimalMark = function () {\n\t            var p = null;\n\t            for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\n\t                if (!t.isVisited) {\n\t                    p = t;\n\t                    for (t = this[++i]; i < n; t = this[++i]) {\n\t                        if (!t.isVisited && t.totalTimeSeconds < p.totalTimeSeconds) {\n\t                            p = t;\n\t                        }\n\t                    }\n\t                    return p;\n\t                }\n\t            }\n\t            return null;\n\t        };\n\t\n\t        _this.push(new _optimalRoute2.default(nowPos, needPos, time, types, speed, dopTimeMinutes));\n\t\n\t        var ignoringRoutes = [];\n\t\n\t        //var ignoringFragments = new IgnoringFragments();\n\t\n\t        for (var selectedOptimalRoute = _this[0]; selectedOptimalRoute != null; selectedOptimalRoute.setVisited(), selectedOptimalRoute = _this.selectOptimalRouteWithMinimalMark()) {\n\t            var ddd = 0.25;\n\t\n\t            ignoringRoutes = [];\n\t            // Проходим по всем ребрам выбранного пути и строим новые маршруты при удалении ребер:\n\t            for (var tmpP = selectedOptimalRoute.myPoints.finalPoint; tmpP.previousPoint != null; tmpP = tmpP.previousPoint) {\n\t                if (tmpP.fromWhichRoute != null && !ignoringRoutes.includes(tmpP.fromWhichRoute)) ignoringRoutes.push(tmpP.fromWhichRoute);\n\t            }\n\t            for (var i = 0, n = ignoringRoutes.length, r = ignoringRoutes[0]; i < n; r = ignoringRoutes[++i]) {\n\t                if (selectedOptimalRoute.ignoringRoutes.includes(r)) continue;\n\t                var ignoringRoutesAdd = [];\n\t                ignoringRoutesAdd = ignoringRoutesAdd.concat(selectedOptimalRoute.ignoringRoutes);\n\t                ignoringRoutesAdd.push(r);\n\t                var tmpOptimalRoute = new _optimalRoute2.default(nowPos, needPos, time, types, speed, dopTimeMinutes, ignoringRoutesAdd);\n\t\n\t                if (tmpOptimalRoute.totalTimeSeconds <= _this[0].totalTimeSeconds / ddd) {\n\t                    var tmpJSON = JSON.stringify(tmpOptimalRoute.points);\n\t                    var ok = false;\n\t                    for (var j = 0, m = _this.length, opt = _this[0]; j < m; opt = _this[++j]) {\n\t                        if (JSON.stringify(opt.points) === tmpJSON) {\n\t                            ok = true;\n\t                            break;\n\t                        }\n\t                    }\n\t                    if (ok) continue;\n\t                    _this.push(tmpOptimalRoute);\n\t                }\n\t            }\n\t        }\n\t        return _this;\n\t    }\n\t\n\t    return OptimalRoutesCollection;\n\t}(Array);\n\t\n\texports.default = OptimalRoutesCollection;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _wayPoint = __webpack_require__(14);\n\t\n\tvar _wayPoint2 = _interopRequireDefault(_wayPoint);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar OptimalWay = function OptimalWay(optimalRoute) {\n\t    _classCallCheck(this, OptimalWay);\n\t\n\t    this.totalTimeSeconds = optimalRoute.totalTimeSeconds;\n\t    this.totalGoingTimeSeconds = optimalRoute.totalGoingTime;\n\t    this.totalTransportChangingCount = optimalRoute.totalTransportChangingCount;\n\t    this.points = [];\n\t\n\t    for (var tmpP = optimalRoute.myPoints.finalPoint; tmpP != null; tmpP = tmpP.previousPoint) {\n\t        this.points.push(new _wayPoint2.default(tmpP.totalTimeSeconds, tmpP.station, tmpP.fromWhichRoute, tmpP.coords));\n\t    }\n\t    this.points.reverse();\n\t};\n\t\n\texports.default = OptimalWay;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Point = function () {\n\t    function Point(totalTimeSeconds, station_or_crds, fromWhichStation, fromWhichRoute) {\n\t        _classCallCheck(this, Point);\n\t\n\t        if (station_or_crds.hashcode !== undefined) {\n\t            this.station = station_or_crds;\n\t            this.stationCode = station_or_crds.hashcode;\n\t            station_or_crds.point = this;\n\t            this.coords = station_or_crds.coords;\n\t        } else {\n\t            this.coords = station_or_crds;\n\t            this.station = null;\n\t            this.stationCode = null;\n\t        }\n\t        this.totalTimeSeconds = totalTimeSeconds;\n\t        this.fromWhichStation = fromWhichStation;\n\t        this.fromWhichRoute = fromWhichRoute;\n\t\n\t        this.isVisited = false;\n\t\n\t        this.previousPoint = null;\n\t    }\n\t\n\t    _createClass(Point, [{\n\t        key: \"tryUpdate\",\n\t        value: function tryUpdate(totalTimeSeconds, previousPoint, fromWhichStation, fromWhichRoute) {\n\t            if (totalTimeSeconds < this.totalTimeSeconds) {\n\t                this.fromWhichRoute = fromWhichRoute;\n\t                this.previousPoint = previousPoint;\n\t                this.totalTimeSeconds = totalTimeSeconds;\n\t                this.fromWhichStation = fromWhichStation;\n\t\n\t                return true;\n\t            }\n\t            return false;\n\t        }\n\t    }, {\n\t        key: \"setVisited\",\n\t        value: function setVisited() {\n\t            this.isVisited = true;\n\t        }\n\t    }, {\n\t        key: \"toString\",\n\t        value: function toString() {\n\t            var to, tr; //, from, p;\n\t            //if (this.fromWhichStation != null) from = this.fromWhichStation.name;\n\t            //else from = \"null\";\n\t            if (this.station != null) to = this.station.name;else to = \"null\";\n\t            if (this.fromWhichRoute != null) tr = this.fromWhichRoute.type + \" \" + this.fromWhichRoute.number + \" \" + this.fromWhichRoute.from + \" - \" + this.fromWhichRoute.to;else tr = \"пешком\";\n\t            //if (this.previousPoint != null) p = this.previousPoint.toString();\n\t            //else p = \"null\";\n\t            return (/*p+\" -->> */\"(\" + this.totalTimeSeconds + \") \" + to + \" (\" + tr + \")\"\n\t            ); // from \" + from + \" to\n\t        }\n\t    }, {\n\t        key: \"getTotalGoingTime\",\n\t        value: function getTotalGoingTime() {\n\t            var goingTime = 0;\n\t            var tmpP = this;\n\t            //this.points.Add(tmpP.ToString());\n\t            while (tmpP.previousPoint != null) {\n\t                if (tmpP.fromWhichRoute == null /*&& tmpP.fromWhichRoute.hashcode == null*/) goingTime += tmpP.totalTimeSeconds - tmpP.previousPoint.totalTimeSeconds;\n\t                tmpP = tmpP.previousPoint;\n\t            }\n\t            return goingTime;\n\t        }\n\t    }, {\n\t        key: \"getTotalTransportChangingCount\",\n\t        value: function getTotalTransportChangingCount() {\n\t            var result = 0;\n\t            var tmpP = this;\n\t            //this.points.Add(tmpP.ToString());\n\t            while (tmpP.previousPoint != null) {\n\t                if (tmpP.fromWhichRoute != null && tmpP.fromWhichRoute.hashcode != null && tmpP.fromWhichRoute !== tmpP.previousPoint.fromWhichRoute) result++;\n\t                tmpP = tmpP.previousPoint;\n\t            }\n\t            return result;\n\t        }\n\t    }]);\n\t\n\t    return Point;\n\t}();\n\t\n\texports.default = Point;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _point = __webpack_require__(12);\n\t\n\tvar _point2 = _interopRequireDefault(_point);\n\t\n\tvar _geoCoords = __webpack_require__(2);\n\t\n\tvar _geoCoords2 = _interopRequireDefault(_geoCoords);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar distance = _geoCoords2.default.distance;\n\t\n\tfunction getTimeForGoingTo(distance, goingSpeed) {\n\t    return Math.floor(distance / (goingSpeed / 3.6));\n\t}\n\t\n\tvar TableType = { table: 1, periodic: 2 };\n\t\n\tvar Points = function () {\n\t    function Points(nowPos, needPos) {\n\t        _classCallCheck(this, Points);\n\t\n\t        this.collection = [];\n\t        this.startPoint = new _point2.default(0, nowPos, null, null);\n\t        this.finalPoint = new _point2.default(2160000000, needPos, null, null);\n\t        this.currentSelectedPoint = null;\n\t    }\n\t\n\t    _createClass(Points, [{\n\t        key: 'findElement',\n\t        value: function findElement(station_or_point) {\n\t            if (station_or_point.hashcode != null) {\n\t                if (station_or_point.point != null) return station_or_point.point;\n\t                var newCreatdPoint = new _point2.default(2160000000, station_or_point, null, null);\n\t                this.collection.push(newCreatdPoint);\n\t                return newCreatdPoint;\n\t            } else {\n\t                for (var i = 0, n = this.collection.length, p = this.collection[0]; i < n; p = this.collection[++i]) {\n\t                    if (p.coords === station_or_point.coords && p.stationCode === station_or_point.stationCode) return p;\n\t                }\n\t                return null;\n\t            }\n\t        }\n\t    }, {\n\t        key: 'fillStartData',\n\t        value: function fillStartData(stationsList, goingSpeed, reservedTime, myIgnoringFragments) {\n\t            this.finalPoint.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, this.finalPoint.coords), goingSpeed) + 1200 /*+ TimeSpan.FromMinutes(20)*/, this.startPoint, null, null);\n\t            for (var i = 0, n = stationsList.length, st = stationsList[0]; i < n; st = stationsList[++i]) {\n\t                if (myIgnoringFragments != null && myIgnoringFragments.contains(st.hashcode, null, null)) continue;\n\t\n\t                var add = new _point2.default(2160000000, st, null, null);\n\t                add.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, st.coords), goingSpeed) + reservedTime, this.startPoint, null, null);\n\t                this.collection.push(add);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getNextUnvisitedPoint',\n\t        value: function getNextUnvisitedPoint() {\n\t            if (this.currentSelectedPoint != null) this.currentSelectedPoint.setVisited();\n\t\n\t            this.currentSelectedPoint = this.selectPointWithMinimalMark();\n\t\n\t            return this.currentSelectedPoint;\n\t        }\n\t    }, {\n\t        key: 'selectPointWithMinimalMark',\n\t        value: function selectPointWithMinimalMark() {\n\t            var p = null;\n\t            for (var i = 0, n = this.collection.length, t = this.collection[0]; i < n; t = this.collection[++i]) {\n\t                if (!t.isVisited) {\n\t                    p = t;\n\t                    for (t = this.collection[++i]; i < n; t = this.collection[++i]) {\n\t                        if (!t.isVisited && t.totalTimeSeconds < p.totalTimeSeconds) {\n\t                            p = t;\n\t                        }\n\t                    }\n\t                    return p;\n\t                }\n\t            }\n\t            return null;\n\t        }\n\t    }, {\n\t        key: 'countShortWay',\n\t        value: function countShortWay(ignoringRoutes, myIgnoringFragments, time, types, speed, reservedTime) {\n\t            //TimeSpan overLimitResedvedTime = TimeSpan.FromMinutes(20);\n\t\n\t            for (var selectedPoint = this.getNextUnvisitedPoint(), selectedPointStation, selectedPointTotalTimeSeconds, selectedPointStationHashcode, selectedPointFromWhichRoute, momentWhenComingToStation, routesOnStation, selectedPointCoords; selectedPoint != null; selectedPoint = this.getNextUnvisitedPoint()) {\n\t                //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\t                selectedPointTotalTimeSeconds = selectedPoint.totalTimeSeconds;\n\t                if (selectedPointTotalTimeSeconds > this.finalPoint.totalTimeSeconds /* + overLimitResedvedTime*/) //... Пропускаем и удаляем, если значение метки превышает минимальное время до пункта назначения.\n\t                    {\n\t                        break;\n\t                    }\n\t                selectedPointStation = selectedPoint.station;\n\t                selectedPointStationHashcode = selectedPointStation.hashcode;\n\t                selectedPointFromWhichRoute = selectedPoint.fromWhichRoute;\n\t                if (selectedPointStation != null) {\n\t                    // Момент, когда мы прибудем на остановку:\n\t                    momentWhenComingToStation = time + selectedPointTotalTimeSeconds;\n\t                    // Загружаем маршруты, проходящие через остановку:\n\t                    routesOnStation = null; // = routesOnStation = Database.GetRoutesOnStation(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);\n\t                    if (selectedPointStation.routes != null) routesOnStation = selectedPointStation.routes;else continue;\n\t\n\t                    for (var i = 0, n = routesOnStation.length, selectedRoute = routesOnStation[0], nextStation; i < n; selectedRoute = routesOnStation[++i]) {\n\t                        if (ignoringRoutes != null && ignoringRoutes.includes(selectedRoute)) continue;\n\t                        if (types.includes(selectedRoute.type)) {\n\t                            // Следующая остановка у данного тран спорта:\n\t                            nextStation = selectedRoute.getNextStation(selectedPointStation);\n\t\n\t                            /*// Код остановки, на которую попадем на данном транспорте:\r\n\t                            string nextCode = selectedRoute.getNextStationCodeAfter(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);*/\n\t                            if (nextStation /*nextCode*/ != null) // Если остановка не является конечной, то:\n\t                                {\n\t                                    // Загружаем расписание:\n\t                                    var table = selectedRoute.getTimetable(selectedPointStation); //Database.getTimetable(selectedPointStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\t                                    // Блокируем попытку попасть указанным транспортом на указанную остановку:\n\t                                    if (myIgnoringFragments != null && myIgnoringFragments.contains(nextStation.hashcode /*nextCode*/, selectedRoute.hashcode, selectedPointStationHashcode)) continue;\n\t\n\t                                    if (table.type === TableType.table) // Если это точное расписание, то:\n\t                                        {\n\t                                            // Минимальный начальный момент, с который можно начинать ожидать посадку:\n\t                                            var momentWhenAskingForGoing = momentWhenComingToStation;\n\t\n\t                                            // Резервируем дополнительное время, если будем пересаживаться на другой маршрут:\n\t                                            //if (selectedPoint.RouteCode == null || selectedPoint.RouteCode != selectedRoute.hashcode) momentWhenAskingForGoing += reservedTime;\n\t                                            if (selectedPointFromWhichRoute != null && selectedPointFromWhichRoute !== selectedRoute) momentWhenAskingForGoing += reservedTime;\n\t\n\t                                            // Подсчитываем, сколько будем ожидать этот транспорт на остановке:\n\t                                            var waitingTime = table.findTimeAfter(momentWhenAskingForGoing);\n\t\n\t                                            // Момент, когда мы сядем в транспорт:\n\t                                            var momentWhenSitInTransport = momentWhenAskingForGoing + waitingTime;\n\t\n\t                                            /*// Следующая остановка у данного транспорта:\r\n\t                                            Station nextStation = Database.GetStationByHashcode(nextCode, databaseMysqlConnection, canReadDataFromLocalCopy: true);*/\n\t\n\t                                            // И соответствующее расписание на этой остановке:\n\t                                            var tbl = selectedRoute.getTimetable(nextStation); //Database.getTimetable(nextStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\n\t\n\t                                            // (сколько будем ехать до следующей остановки):\n\t                                            var goingOnTransportTime = tbl.findTimeAfter(momentWhenSitInTransport);\n\t\n\t                                            // Метка времени:\n\t                                            var onNextPointtotalTimeSeconds = momentWhenSitInTransport - momentWhenComingToStation + goingOnTransportTime + selectedPointTotalTimeSeconds;\n\t\n\t                                            if (this.findElement(nextStation).tryUpdate(onNextPointtotalTimeSeconds, selectedPoint, selectedPointStation, selectedRoute)) {\n\t                                                //console.log(\"upd...\");\n\t                                            }\n\t                                        } else if (table.type === TableType.periodic) {\n\t                                        throw new Error();\n\t                                    }\n\t                                }\n\t                        }\n\t                    }\n\t                }\n\t                selectedPointCoords = selectedPoint.coords;\n\t                // Нет смысла идти пешком \"транзитом\" через остановку:\n\t                if (selectedPointFromWhichRoute == null) continue;\n\t\n\t                // Попробуем пройти пешком до других \"вершин\":\n\t                for (var j = 0, m = this.collection.length, p = this.collection[0], distanceToSelectedPoint, goingTime, newTime; j < m; p = this.collection[++j]) {\n\t                    if (!p.isVisited && p !== selectedPoint) {\n\t                        // Блокируем попытку дойти пешком до указанной остановки:\n\t                        if (myIgnoringFragments != null && myIgnoringFragments.contains(p.stationCode, null, selectedPointStationHashcode)) continue;\n\t\n\t                        distanceToSelectedPoint = distance(selectedPointCoords, p.coords);\n\t\n\t                        goingTime = getTimeForGoingTo(distanceToSelectedPoint, speed /*, true, sp*/);\n\t\n\t                        newTime = selectedPointTotalTimeSeconds + goingTime + reservedTime;\n\t                        /*if (p != myFinishPoint)*/ // newTime += reservedTime;\n\t\n\t                        if (p.tryUpdate(newTime, selectedPoint, selectedPointStation, null)) {\n\t                            //console.log(\"upd...\");\n\t                        }\n\t                    }\n\t                }if (myIgnoringFragments != null && myIgnoringFragments.contains(null, null, selectedPointStationHashcode)) continue;\n\t\n\t                var tryingNewTime = selectedPointTotalTimeSeconds + getTimeForGoingTo(distance(selectedPointCoords, this.finalPoint.coords), speed);\n\t                if (this.finalPoint.tryUpdate(tryingNewTime, selectedPoint, selectedPointStation, null)) {\n\t                    //console.log(\"upd: \" + selectedPointStation.hashcode);\n\t                }\n\t            }\n\t\n\t            // Сокращаем время ходьбы пешком до минимума и избавляемся от \"бессмысленных\" пересадок, сохраняя общее время неизменным:\n\t            var currentPoint = this.finalPoint.previousPoint;\n\t            while (currentPoint !== this.startPoint) {\n\t                var r = currentPoint.fromWhichRoute;\n\t                if (r != null) {\n\t                    var previousPoint = currentPoint.previousPoint;\n\t                    if (previousPoint !== this.startPoint && previousPoint.fromWhichRoute !== r) // Если на предыдущую остановку мы добрались другим транспортом, то:\n\t                        {\n\t                            var previousRouteStation = r.getPreviousStation(previousPoint.station);\n\t                            if (previousRouteStation != null) {\n\t                                var point = previousRouteStation.point;\n\t                                if (point != null && point.isVisited) {\n\t                                    var ttt = r.getTimetable(previousRouteStation);\n\t                                    if (ttt != null) {\n\t                                        //var ddd = time + previousPoint.totalTimeSeconds;\n\t                                        //var moment = r.getTimetable(currentPoint.station).findTimeAfter(ddd);\n\t                                        //var tmp_time = ttt.findTimeBefore(ddd + moment);\n\t\n\t                                        //var momentArriveOnCurrent = previousPoint.totalTimeSeconds + moment;\n\t                                        //var momentSittingOnPrevious = momentArriveOnCurrent + tmp_time;\n\t                                        /*bool bbb = point.fromWhichRoute != null && point.fromWhichRoute.getTimetable(point.station) != null && point.fromWhichRoute.getTimetable(point.station).findTimeAfter(time + point.totalTimeSeconds) <= previousPoint.totalTimeSeconds + moment + tmp_time;\r\n\t                                        if (bbb)\r\n\t                                        {\r\n\t                                            previousPoint.fromWhichRoute = r;\r\n\t                                            previousPoint.previousPoint = point;////!bbb && point.totalTimeSeconds <= momentSittingOnPrevious &&\r\n\t                                        }\r\n\t                                        else */\n\t                                        if ( /*point.totalGoingTime>=previousPoint.totalGoingTime || */point.totalTimeSeconds <= previousPoint.totalTimeSeconds /* && point.totalGoingTime <= previousPoint.totalGoingTime*/) {\n\t                                                previousPoint.fromWhichRoute = r;\n\t                                                previousPoint.previousPoint = point;\n\t                                            }\n\t                                    }\n\t                                }\n\t                            }\n\t                        }\n\t                }\n\t                currentPoint = currentPoint.previousPoint;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return Points;\n\t}();\n\t\n\texports.default = Points;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar WayPoint = function WayPoint(time, station, route, coords) {\n\t    _classCallCheck(this, WayPoint);\n\t\n\t    this.time = time;\n\t    this.station = station == null ? null : { hashcode: station.hashcode, name: station.name, routes: null, Coords: { lat: station.coords.lat, lng: station.coords.lng } };\n\t    this.route = route == null ? null : { vehicles: [], gpsTrack: null, hashcode: route.hashcode, number: route.number, type: route.type, from: route.from, to: route.to, owner: \"\", stations: null, timetables: null, stationsJSON: null };\n\t    this.coords = coords;\n\t};\n\t\n\texports.default = WayPoint;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// This method of obtaining a reference to the global object needs to be\n\t// kept identical to the way it is obtained in runtime.js\n\tvar g =\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this;\n\t\n\t// Use `getOwnPropertyNames` because not all browsers support calling\n\t// `hasOwnProperty` on the global `self` object in a worker. See #183.\n\tvar hadRuntime = g.regeneratorRuntime &&\n\t  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\t\n\t// Save the old regeneratorRuntime in case it needs to be restored later.\n\tvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\t\n\t// Force reevalutation of runtime.js.\n\tg.regeneratorRuntime = undefined;\n\t\n\tmodule.exports = __webpack_require__(16);\n\t\n\tif (hadRuntime) {\n\t  // Restore the original runtime.\n\t  g.regeneratorRuntime = oldRuntime;\n\t} else {\n\t  // Remove the global property added by runtime.js.\n\t  try {\n\t    delete g.regeneratorRuntime;\n\t  } catch(e) {\n\t    g.regeneratorRuntime = undefined;\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {/**\n\t * Copyright (c) 2014, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n\t * additional grant of patent rights can be found in the PATENTS file in\n\t * the same directory.\n\t */\n\t\n\t!(function(global) {\n\t  \"use strict\";\n\t\n\t  var Op = Object.prototype;\n\t  var hasOwn = Op.hasOwnProperty;\n\t  var undefined; // More compressible than void 0.\n\t  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n\t  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n\t  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n\t  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\t\n\t  var inModule = typeof module === \"object\";\n\t  var runtime = global.regeneratorRuntime;\n\t  if (runtime) {\n\t    if (inModule) {\n\t      // If regeneratorRuntime is defined globally and we're in a module,\n\t      // make the exports object identical to regeneratorRuntime.\n\t      module.exports = runtime;\n\t    }\n\t    // Don't bother evaluating the rest of this file if the runtime was\n\t    // already defined globally.\n\t    return;\n\t  }\n\t\n\t  // Define the runtime globally (as expected by generated code) as either\n\t  // module.exports (if we're in a module) or a new, empty object.\n\t  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\t\n\t  function wrap(innerFn, outerFn, self, tryLocsList) {\n\t    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n\t    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n\t    var generator = Object.create(protoGenerator.prototype);\n\t    var context = new Context(tryLocsList || []);\n\t\n\t    // The ._invoke method unifies the implementations of the .next,\n\t    // .throw, and .return methods.\n\t    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\t\n\t    return generator;\n\t  }\n\t  runtime.wrap = wrap;\n\t\n\t  // Try/catch helper to minimize deoptimizations. Returns a completion\n\t  // record like context.tryEntries[i].completion. This interface could\n\t  // have been (and was previously) designed to take a closure to be\n\t  // invoked without arguments, but in all the cases we care about we\n\t  // already have an existing method we want to call, so there's no need\n\t  // to create a new function object. We can even get away with assuming\n\t  // the method takes exactly one argument, since that happens to be true\n\t  // in every case, so we don't have to touch the arguments object. The\n\t  // only additional allocation required is the completion record, which\n\t  // has a stable shape and so hopefully should be cheap to allocate.\n\t  function tryCatch(fn, obj, arg) {\n\t    try {\n\t      return { type: \"normal\", arg: fn.call(obj, arg) };\n\t    } catch (err) {\n\t      return { type: \"throw\", arg: err };\n\t    }\n\t  }\n\t\n\t  var GenStateSuspendedStart = \"suspendedStart\";\n\t  var GenStateSuspendedYield = \"suspendedYield\";\n\t  var GenStateExecuting = \"executing\";\n\t  var GenStateCompleted = \"completed\";\n\t\n\t  // Returning this object from the innerFn has the same effect as\n\t  // breaking out of the dispatch switch statement.\n\t  var ContinueSentinel = {};\n\t\n\t  // Dummy constructor functions that we use as the .constructor and\n\t  // .constructor.prototype properties for functions that return Generator\n\t  // objects. For full spec compliance, you may wish to configure your\n\t  // minifier not to mangle the names of these two functions.\n\t  function Generator() {}\n\t  function GeneratorFunction() {}\n\t  function GeneratorFunctionPrototype() {}\n\t\n\t  // This is a polyfill for %IteratorPrototype% for environments that\n\t  // don't natively support it.\n\t  var IteratorPrototype = {};\n\t  IteratorPrototype[iteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t\n\t  var getProto = Object.getPrototypeOf;\n\t  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\t  if (NativeIteratorPrototype &&\n\t      NativeIteratorPrototype !== Op &&\n\t      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n\t    // This environment has a native %IteratorPrototype%; use it instead\n\t    // of the polyfill.\n\t    IteratorPrototype = NativeIteratorPrototype;\n\t  }\n\t\n\t  var Gp = GeneratorFunctionPrototype.prototype =\n\t    Generator.prototype = Object.create(IteratorPrototype);\n\t  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\t  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n\t  GeneratorFunctionPrototype[toStringTagSymbol] =\n\t    GeneratorFunction.displayName = \"GeneratorFunction\";\n\t\n\t  // Helper for defining the .next, .throw, and .return methods of the\n\t  // Iterator interface in terms of a single ._invoke method.\n\t  function defineIteratorMethods(prototype) {\n\t    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n\t      prototype[method] = function(arg) {\n\t        return this._invoke(method, arg);\n\t      };\n\t    });\n\t  }\n\t\n\t  runtime.isGeneratorFunction = function(genFun) {\n\t    var ctor = typeof genFun === \"function\" && genFun.constructor;\n\t    return ctor\n\t      ? ctor === GeneratorFunction ||\n\t        // For the native GeneratorFunction constructor, the best we can\n\t        // do is to check its .name property.\n\t        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n\t      : false;\n\t  };\n\t\n\t  runtime.mark = function(genFun) {\n\t    if (Object.setPrototypeOf) {\n\t      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n\t    } else {\n\t      genFun.__proto__ = GeneratorFunctionPrototype;\n\t      if (!(toStringTagSymbol in genFun)) {\n\t        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n\t      }\n\t    }\n\t    genFun.prototype = Object.create(Gp);\n\t    return genFun;\n\t  };\n\t\n\t  // Within the body of any async function, `await x` is transformed to\n\t  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n\t  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n\t  // meant to be awaited.\n\t  runtime.awrap = function(arg) {\n\t    return { __await: arg };\n\t  };\n\t\n\t  function AsyncIterator(generator) {\n\t    function invoke(method, arg, resolve, reject) {\n\t      var record = tryCatch(generator[method], generator, arg);\n\t      if (record.type === \"throw\") {\n\t        reject(record.arg);\n\t      } else {\n\t        var result = record.arg;\n\t        var value = result.value;\n\t        if (value &&\n\t            typeof value === \"object\" &&\n\t            hasOwn.call(value, \"__await\")) {\n\t          return Promise.resolve(value.__await).then(function(value) {\n\t            invoke(\"next\", value, resolve, reject);\n\t          }, function(err) {\n\t            invoke(\"throw\", err, resolve, reject);\n\t          });\n\t        }\n\t\n\t        return Promise.resolve(value).then(function(unwrapped) {\n\t          // When a yielded Promise is resolved, its final value becomes\n\t          // the .value of the Promise<{value,done}> result for the\n\t          // current iteration. If the Promise is rejected, however, the\n\t          // result for this iteration will be rejected with the same\n\t          // reason. Note that rejections of yielded Promises are not\n\t          // thrown back into the generator function, as is the case\n\t          // when an awaited Promise is rejected. This difference in\n\t          // behavior between yield and await is important, because it\n\t          // allows the consumer to decide what to do with the yielded\n\t          // rejection (swallow it and continue, manually .throw it back\n\t          // into the generator, abandon iteration, whatever). With\n\t          // await, by contrast, there is no opportunity to examine the\n\t          // rejection reason outside the generator function, so the\n\t          // only option is to throw it from the await expression, and\n\t          // let the generator function handle the exception.\n\t          result.value = unwrapped;\n\t          resolve(result);\n\t        }, reject);\n\t      }\n\t    }\n\t\n\t    if (typeof process === \"object\" && process.domain) {\n\t      invoke = process.domain.bind(invoke);\n\t    }\n\t\n\t    var previousPromise;\n\t\n\t    function enqueue(method, arg) {\n\t      function callInvokeWithMethodAndArg() {\n\t        return new Promise(function(resolve, reject) {\n\t          invoke(method, arg, resolve, reject);\n\t        });\n\t      }\n\t\n\t      return previousPromise =\n\t        // If enqueue has been called before, then we want to wait until\n\t        // all previous Promises have been resolved before calling invoke,\n\t        // so that results are always delivered in the correct order. If\n\t        // enqueue has not been called before, then it is important to\n\t        // call invoke immediately, without waiting on a callback to fire,\n\t        // so that the async generator function has the opportunity to do\n\t        // any necessary setup in a predictable way. This predictability\n\t        // is why the Promise constructor synchronously invokes its\n\t        // executor callback, and why async functions synchronously\n\t        // execute code before the first await. Since we implement simple\n\t        // async functions in terms of async generators, it is especially\n\t        // important to get this right, even though it requires care.\n\t        previousPromise ? previousPromise.then(\n\t          callInvokeWithMethodAndArg,\n\t          // Avoid propagating failures to Promises returned by later\n\t          // invocations of the iterator.\n\t          callInvokeWithMethodAndArg\n\t        ) : callInvokeWithMethodAndArg();\n\t    }\n\t\n\t    // Define the unified helper method that is used to implement .next,\n\t    // .throw, and .return (see defineIteratorMethods).\n\t    this._invoke = enqueue;\n\t  }\n\t\n\t  defineIteratorMethods(AsyncIterator.prototype);\n\t  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t  runtime.AsyncIterator = AsyncIterator;\n\t\n\t  // Note that simple async functions are implemented on top of\n\t  // AsyncIterator objects; they just return a Promise for the value of\n\t  // the final result produced by the iterator.\n\t  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n\t    var iter = new AsyncIterator(\n\t      wrap(innerFn, outerFn, self, tryLocsList)\n\t    );\n\t\n\t    return runtime.isGeneratorFunction(outerFn)\n\t      ? iter // If outerFn is a generator, return the full iterator.\n\t      : iter.next().then(function(result) {\n\t          return result.done ? result.value : iter.next();\n\t        });\n\t  };\n\t\n\t  function makeInvokeMethod(innerFn, self, context) {\n\t    var state = GenStateSuspendedStart;\n\t\n\t    return function invoke(method, arg) {\n\t      if (state === GenStateExecuting) {\n\t        throw new Error(\"Generator is already running\");\n\t      }\n\t\n\t      if (state === GenStateCompleted) {\n\t        if (method === \"throw\") {\n\t          throw arg;\n\t        }\n\t\n\t        // Be forgiving, per 25.3.3.3.3 of the spec:\n\t        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t        return doneResult();\n\t      }\n\t\n\t      context.method = method;\n\t      context.arg = arg;\n\t\n\t      while (true) {\n\t        var delegate = context.delegate;\n\t        if (delegate) {\n\t          var delegateResult = maybeInvokeDelegate(delegate, context);\n\t          if (delegateResult) {\n\t            if (delegateResult === ContinueSentinel) continue;\n\t            return delegateResult;\n\t          }\n\t        }\n\t\n\t        if (context.method === \"next\") {\n\t          // Setting context._sent for legacy support of Babel's\n\t          // function.sent implementation.\n\t          context.sent = context._sent = context.arg;\n\t\n\t        } else if (context.method === \"throw\") {\n\t          if (state === GenStateSuspendedStart) {\n\t            state = GenStateCompleted;\n\t            throw context.arg;\n\t          }\n\t\n\t          context.dispatchException(context.arg);\n\t\n\t        } else if (context.method === \"return\") {\n\t          context.abrupt(\"return\", context.arg);\n\t        }\n\t\n\t        state = GenStateExecuting;\n\t\n\t        var record = tryCatch(innerFn, self, context);\n\t        if (record.type === \"normal\") {\n\t          // If an exception is thrown from innerFn, we leave state ===\n\t          // GenStateExecuting and loop back for another invocation.\n\t          state = context.done\n\t            ? GenStateCompleted\n\t            : GenStateSuspendedYield;\n\t\n\t          if (record.arg === ContinueSentinel) {\n\t            continue;\n\t          }\n\t\n\t          return {\n\t            value: record.arg,\n\t            done: context.done\n\t          };\n\t\n\t        } else if (record.type === \"throw\") {\n\t          state = GenStateCompleted;\n\t          // Dispatch the exception by looping back around to the\n\t          // context.dispatchException(context.arg) call above.\n\t          context.method = \"throw\";\n\t          context.arg = record.arg;\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  // Call delegate.iterator[context.method](context.arg) and handle the\n\t  // result, either by returning a { value, done } result from the\n\t  // delegate iterator, or by modifying context.method and context.arg,\n\t  // setting context.delegate to null, and returning the ContinueSentinel.\n\t  function maybeInvokeDelegate(delegate, context) {\n\t    var method = delegate.iterator[context.method];\n\t    if (method === undefined) {\n\t      // A .throw or .return when the delegate iterator has no .throw\n\t      // method always terminates the yield* loop.\n\t      context.delegate = null;\n\t\n\t      if (context.method === \"throw\") {\n\t        if (delegate.iterator.return) {\n\t          // If the delegate iterator has a return method, give it a\n\t          // chance to clean up.\n\t          context.method = \"return\";\n\t          context.arg = undefined;\n\t          maybeInvokeDelegate(delegate, context);\n\t\n\t          if (context.method === \"throw\") {\n\t            // If maybeInvokeDelegate(context) changed context.method from\n\t            // \"return\" to \"throw\", let that override the TypeError below.\n\t            return ContinueSentinel;\n\t          }\n\t        }\n\t\n\t        context.method = \"throw\";\n\t        context.arg = new TypeError(\n\t          \"The iterator does not provide a 'throw' method\");\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var record = tryCatch(method, delegate.iterator, context.arg);\n\t\n\t    if (record.type === \"throw\") {\n\t      context.method = \"throw\";\n\t      context.arg = record.arg;\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var info = record.arg;\n\t\n\t    if (! info) {\n\t      context.method = \"throw\";\n\t      context.arg = new TypeError(\"iterator result is not an object\");\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    if (info.done) {\n\t      // Assign the result of the finished delegate to the temporary\n\t      // variable specified by delegate.resultName (see delegateYield).\n\t      context[delegate.resultName] = info.value;\n\t\n\t      // Resume execution at the desired location (see delegateYield).\n\t      context.next = delegate.nextLoc;\n\t\n\t      // If context.method was \"throw\" but the delegate handled the\n\t      // exception, let the outer generator proceed normally. If\n\t      // context.method was \"next\", forget context.arg since it has been\n\t      // \"consumed\" by the delegate iterator. If context.method was\n\t      // \"return\", allow the original .return call to continue in the\n\t      // outer generator.\n\t      if (context.method !== \"return\") {\n\t        context.method = \"next\";\n\t        context.arg = undefined;\n\t      }\n\t\n\t    } else {\n\t      // Re-yield the result returned by the delegate method.\n\t      return info;\n\t    }\n\t\n\t    // The delegate iterator is finished, so forget it and continue with\n\t    // the outer generator.\n\t    context.delegate = null;\n\t    return ContinueSentinel;\n\t  }\n\t\n\t  // Define Generator.prototype.{next,throw,return} in terms of the\n\t  // unified ._invoke helper method.\n\t  defineIteratorMethods(Gp);\n\t\n\t  Gp[toStringTagSymbol] = \"Generator\";\n\t\n\t  Gp.toString = function() {\n\t    return \"[object Generator]\";\n\t  };\n\t\n\t  function pushTryEntry(locs) {\n\t    var entry = { tryLoc: locs[0] };\n\t\n\t    if (1 in locs) {\n\t      entry.catchLoc = locs[1];\n\t    }\n\t\n\t    if (2 in locs) {\n\t      entry.finallyLoc = locs[2];\n\t      entry.afterLoc = locs[3];\n\t    }\n\t\n\t    this.tryEntries.push(entry);\n\t  }\n\t\n\t  function resetTryEntry(entry) {\n\t    var record = entry.completion || {};\n\t    record.type = \"normal\";\n\t    delete record.arg;\n\t    entry.completion = record;\n\t  }\n\t\n\t  function Context(tryLocsList) {\n\t    // The root entry object (effectively a try statement without a catch\n\t    // or a finally block) gives us a place to store values thrown from\n\t    // locations where there is no enclosing try statement.\n\t    this.tryEntries = [{ tryLoc: \"root\" }];\n\t    tryLocsList.forEach(pushTryEntry, this);\n\t    this.reset(true);\n\t  }\n\t\n\t  runtime.keys = function(object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t      keys.push(key);\n\t    }\n\t    keys.reverse();\n\t\n\t    // Rather than returning an object with a next method, we keep\n\t    // things simple and return the next function itself.\n\t    return function next() {\n\t      while (keys.length) {\n\t        var key = keys.pop();\n\t        if (key in object) {\n\t          next.value = key;\n\t          next.done = false;\n\t          return next;\n\t        }\n\t      }\n\t\n\t      // To avoid creating an additional object, we just hang the .value\n\t      // and .done properties off the next function object itself. This\n\t      // also ensures that the minifier will not anonymize the function.\n\t      next.done = true;\n\t      return next;\n\t    };\n\t  };\n\t\n\t  function values(iterable) {\n\t    if (iterable) {\n\t      var iteratorMethod = iterable[iteratorSymbol];\n\t      if (iteratorMethod) {\n\t        return iteratorMethod.call(iterable);\n\t      }\n\t\n\t      if (typeof iterable.next === \"function\") {\n\t        return iterable;\n\t      }\n\t\n\t      if (!isNaN(iterable.length)) {\n\t        var i = -1, next = function next() {\n\t          while (++i < iterable.length) {\n\t            if (hasOwn.call(iterable, i)) {\n\t              next.value = iterable[i];\n\t              next.done = false;\n\t              return next;\n\t            }\n\t          }\n\t\n\t          next.value = undefined;\n\t          next.done = true;\n\t\n\t          return next;\n\t        };\n\t\n\t        return next.next = next;\n\t      }\n\t    }\n\t\n\t    // Return an iterator with no values.\n\t    return { next: doneResult };\n\t  }\n\t  runtime.values = values;\n\t\n\t  function doneResult() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  Context.prototype = {\n\t    constructor: Context,\n\t\n\t    reset: function(skipTempReset) {\n\t      this.prev = 0;\n\t      this.next = 0;\n\t      // Resetting context._sent for legacy support of Babel's\n\t      // function.sent implementation.\n\t      this.sent = this._sent = undefined;\n\t      this.done = false;\n\t      this.delegate = null;\n\t\n\t      this.method = \"next\";\n\t      this.arg = undefined;\n\t\n\t      this.tryEntries.forEach(resetTryEntry);\n\t\n\t      if (!skipTempReset) {\n\t        for (var name in this) {\n\t          // Not sure about the optimal order of these conditions:\n\t          if (name.charAt(0) === \"t\" &&\n\t              hasOwn.call(this, name) &&\n\t              !isNaN(+name.slice(1))) {\n\t            this[name] = undefined;\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    stop: function() {\n\t      this.done = true;\n\t\n\t      var rootEntry = this.tryEntries[0];\n\t      var rootRecord = rootEntry.completion;\n\t      if (rootRecord.type === \"throw\") {\n\t        throw rootRecord.arg;\n\t      }\n\t\n\t      return this.rval;\n\t    },\n\t\n\t    dispatchException: function(exception) {\n\t      if (this.done) {\n\t        throw exception;\n\t      }\n\t\n\t      var context = this;\n\t      function handle(loc, caught) {\n\t        record.type = \"throw\";\n\t        record.arg = exception;\n\t        context.next = loc;\n\t\n\t        if (caught) {\n\t          // If the dispatched exception was caught by a catch block,\n\t          // then let that catch block handle the exception normally.\n\t          context.method = \"next\";\n\t          context.arg = undefined;\n\t        }\n\t\n\t        return !! caught;\n\t      }\n\t\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        var record = entry.completion;\n\t\n\t        if (entry.tryLoc === \"root\") {\n\t          // Exception thrown outside of any try block that could handle\n\t          // it, so set the completion value of the entire function to\n\t          // throw the exception.\n\t          return handle(\"end\");\n\t        }\n\t\n\t        if (entry.tryLoc <= this.prev) {\n\t          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n\t          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\t\n\t          if (hasCatch && hasFinally) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            } else if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else if (hasCatch) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            }\n\t\n\t          } else if (hasFinally) {\n\t            if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else {\n\t            throw new Error(\"try statement without catch or finally\");\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    abrupt: function(type, arg) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc <= this.prev &&\n\t            hasOwn.call(entry, \"finallyLoc\") &&\n\t            this.prev < entry.finallyLoc) {\n\t          var finallyEntry = entry;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (finallyEntry &&\n\t          (type === \"break\" ||\n\t           type === \"continue\") &&\n\t          finallyEntry.tryLoc <= arg &&\n\t          arg <= finallyEntry.finallyLoc) {\n\t        // Ignore the finally entry if control is not jumping to a\n\t        // location outside the try/catch block.\n\t        finallyEntry = null;\n\t      }\n\t\n\t      var record = finallyEntry ? finallyEntry.completion : {};\n\t      record.type = type;\n\t      record.arg = arg;\n\t\n\t      if (finallyEntry) {\n\t        this.method = \"next\";\n\t        this.next = finallyEntry.finallyLoc;\n\t        return ContinueSentinel;\n\t      }\n\t\n\t      return this.complete(record);\n\t    },\n\t\n\t    complete: function(record, afterLoc) {\n\t      if (record.type === \"throw\") {\n\t        throw record.arg;\n\t      }\n\t\n\t      if (record.type === \"break\" ||\n\t          record.type === \"continue\") {\n\t        this.next = record.arg;\n\t      } else if (record.type === \"return\") {\n\t        this.rval = this.arg = record.arg;\n\t        this.method = \"return\";\n\t        this.next = \"end\";\n\t      } else if (record.type === \"normal\" && afterLoc) {\n\t        this.next = afterLoc;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    finish: function(finallyLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.finallyLoc === finallyLoc) {\n\t          this.complete(entry.completion, entry.afterLoc);\n\t          resetTryEntry(entry);\n\t          return ContinueSentinel;\n\t        }\n\t      }\n\t    },\n\t\n\t    \"catch\": function(tryLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc === tryLoc) {\n\t          var record = entry.completion;\n\t          if (record.type === \"throw\") {\n\t            var thrown = record.arg;\n\t            resetTryEntry(entry);\n\t          }\n\t          return thrown;\n\t        }\n\t      }\n\t\n\t      // The context.catch method must only be called with a location\n\t      // argument that corresponds to a known catch block.\n\t      throw new Error(\"illegal catch attempt\");\n\t    },\n\t\n\t    delegateYield: function(iterable, resultName, nextLoc) {\n\t      this.delegate = {\n\t        iterator: values(iterable),\n\t        resultName: resultName,\n\t        nextLoc: nextLoc\n\t      };\n\t\n\t      if (this.method === \"next\") {\n\t        // Deliberately forget the last sent value so that we don't\n\t        // accidentally pass it on to the delegate.\n\t        this.arg = undefined;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t  };\n\t})(\n\t  // Among the various tricks for obtaining a reference to the global\n\t  // object, this seems to be the most reliable technique that does not\n\t  // use indirect eval (which violates Content Security Policy).\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this\n\t);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)))\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// sw.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fea557d3a8a0031b52c7","import AppClient from './client';\r\nlet s = '123hello123';\r\nconsole.log('111111111111111111111111111111111111111111');\n\n\n// WEBPACK FOOTER //\n// ./src/modules/client/sw.js","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-preset-react-app/~/babel-runtime/regenerator/index.js\n// module id = 1\n// module chunks = 0","class GeoCoords {\r\n    static distance(a, b) {\r\n        const earthRadius = 6372795;\r\n        const pi180 = 0.017453;// 29251//Math.Round(Math.PI / 180, 5);\r\n        var zz = 1, yy = 1;\r\n        function taylorSin(x) {\r\n            yy = x * x;\r\n            zz = x;\r\n            return zz - (zz *= yy) / 6 + (zz *= yy) / 120;\r\n        }\r\n        function taylorCos(x) {\r\n            yy = x * x;\r\n            zz = yy;\r\n            return 1 - (yy) / 2 + (zz *= yy) / 24;\r\n        }\r\n        /*function taylorAtan(x) {\r\n            yy = x * x;\r\n            zz = x;\r\n            return zz - (zz *= yy) / 3 + (zz *= yy) / 5 - (zz *= yy) / 7 + (zz *= yy) / 9 - (zz *= yy) / 20;\r\n        }*/\r\n\r\n        // перевести координаты в радианы\r\n        var lat1 = a.lat * pi180;\r\n        var lat2 = b.lat * pi180;\r\n        var long1 = a.lng * pi180;\r\n        var long2 = b.lng * pi180;\r\n\r\n        // косинусы и синусы широт и разницы долгот\r\n        var cl1 = taylorCos(lat1);\r\n        var cl2 = taylorCos(lat2);\r\n        var sl1 = taylorSin(lat1);\r\n        var sl2 = taylorSin(lat2);\r\n        var delta = long2 - long1;\r\n        var cdelta = taylorCos(delta);\r\n        var sdelta = taylorSin(delta);\r\n\r\n        // вычисления длины большого круга\r\n        var tmp = cl2 * cdelta;\r\n        var y = Math.sqrt(cl2 * cl2 * sdelta * sdelta + (cl1 * sl2 - sl1 * tmp) * (cl1 * sl2 - sl1 * tmp));\r\n        var x = sl1 * sl2 + cl1 * tmp;\r\n\r\n        //\r\n        var ad = Math.atan2(y, x);//taylorAtan(y/x);\r\n        var dist = Math.ceil(ad * earthRadius);//(int)Math.Round(ad * earthRadius, 0);\r\n\r\n        return dist;\r\n    }\r\n}\r\n\r\nexport default GeoCoords;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/geoCoords.js","class ApiConfig{\r\n    //var apiPublicTransportServer = \"http://adsghdfsjgdj-001-site1.gtempurl.com/api/\";\r\n    //var apiPublicTransportServer = \"http://localhost:6967/api/\";\r\n    static apiPublicTransportServer = \"https://ptp-97126.app.xervo.io/\";\r\n}\r\n\r\nexport default ApiConfig;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/apiConfig.js","//var fetch = require('node-fetch');\r\nimport initialize from './initialize';\r\n\r\nimport ApiConfig from './apiConfig';\r\nvar apiPublicTransportServer = ApiConfig.apiPublicTransportServer;\r\n\r\n/*var strGetStations = apiPublicTransportServer + \"stations/\";\r\nstrGetStations = \"json/stations.json\";\r\nstrGetStations = \"https://publictransportproject.000webhostapp.com/new/json/stations.json\"; \r\n\r\nvar strGetRoutes = apiPublicTransportServer + \"routes/\";\r\nstrGetRoutes = \"json/routes.json\";\r\nstrGetRoutes = \"https://publictransportproject.000webhostapp.com/new/json/routes.json\";\r\n\r\nvar strGetTimetables = apiPublicTransportServer + \"timetables/\";\r\nstrGetTimetables = \"json/timetables.json\";\r\nstrGetTimetables = \"https://publictransportproject.000webhostapp.com/new/json/timetables.json\";*/\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Load data.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nvar allStations = null;\r\nvar allRoutes = null;\r\nvar allTimetables = null;\r\n\r\n//var updatingFromServerInterval = 5000;\r\n\r\nvar loadingStarted = false;\r\n\r\nvar allStationsLoaded = false, allRoutesLoaded = false,  allTimetablesLoaded = false;\r\nvar allStationsJSON = null, allRoutesJSON = null, allTimetablesJSON = null;\r\n\r\nasync function loadDataOnly() {\r\n    if(!allStationsLoaded){\r\n        if (localStorage[\"allStationsJSON\"] === undefined || localStorage[\"allStationsJSON\"] == null) {\r\n            console.log(\"Downloading stations from server...\");\r\n            var strGetStations = apiPublicTransportServer + \"stations/\";\r\n\r\n            let response = await fetch(strGetStations);\r\n            allStationsJSON = await response.text();\r\n            allStations = JSON.parse(allStationsJSON);//await response.json();\r\n\r\n            if (allStations !== undefined && allStations != null) localStorage[\"allStationsJSON\"] = allStationsJSON;\r\n            allStationsLoaded = true;\r\n            console.log(\"Stations loaded from server.\");\r\n        }\r\n        else {\r\n            allStations = JSON.parse(localStorage[\"allStationsJSON\"]);\r\n            allStationsLoaded = true;\r\n            console.log(\"Stations loaded from localStorage.\");\r\n        }\r\n    }\r\n\r\n    if(!allRoutesLoaded){\r\n        if (localStorage[\"allRoutesJSON\"] === undefined || localStorage[\"allRoutesJSON\"] == null) {\r\n            console.log(\"Downloading routes from server...\");\r\n            var strGetRoutes = apiPublicTransportServer + \"routes/\";\r\n\r\n            let response = await fetch(strGetRoutes);\r\n            allRoutesJSON = await response.text();\r\n            allRoutes = JSON.parse(allRoutesJSON);//await response.json();\r\n\r\n            if (allRoutes !== undefined && allRoutes != null) localStorage[\"allRoutesJSON\"] = allRoutesJSON;\r\n            allRoutesLoaded = true;\r\n            console.log(\"Routes loaded from server.\");\r\n        }\r\n        else {\r\n            allRoutes = JSON.parse(localStorage[\"allRoutesJSON\"]);\r\n            allRoutesLoaded = true;\r\n            console.log(\"Routes loaded from localStorage.\");\r\n        }\r\n    }\r\n\r\n    if(!allTimetablesLoaded){\r\n        if (localStorage[\"allTimetablesJSON\"] === undefined || localStorage[\"allTimetablesJSON\"] == null) {\r\n            console.log(\"Downloading timetables from server...\");\r\n            var strGetTimetables = apiPublicTransportServer + \"timetables/\";\r\n\r\n            let response = await fetch(strGetTimetables);\r\n            allTimetablesJSON = await response.text();\r\n            allTimetables = JSON.parse(allTimetablesJSON);//await response.json();\r\n\r\n            if (allTimetables !== undefined && allTimetables != null) localStorage[\"allTimetablesJSON\"] = allTimetablesJSON;\r\n            allTimetablesLoaded = true;\r\n            console.log(\"Timetables loaded from server.\");\r\n        }\r\n        else {\r\n            allTimetables = JSON.parse(localStorage[\"allTimetablesJSON\"]);\r\n            allTimetablesLoaded = true;\r\n            console.log(\"Timetables loaded from localStorage.\");\r\n        }\r\n    }\r\n}\r\n\r\nasync function loadData() {\r\n    if(!loadingStarted){\r\n        loadingStarted = true;\r\n\r\n        await loadDataOnly();\r\n\r\n        if (allStationsLoaded && allRoutesLoaded && allTimetablesLoaded) {\r\n            initialize(allStations, allRoutes, allTimetables);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//loadData();\r\n\r\nclass MyDatabase {\r\n    static getAllStations() {\r\n        return allStations;\r\n    }\r\n    static getAllRoutes() {\r\n        return allRoutes;\r\n    }\r\n    static getAllTimetables() {\r\n        return allTimetables;\r\n    }\r\n    static getAllStationsJSON() {\r\n        return allStationsJSON;\r\n    }\r\n    static getAllRoutesJSON() {\r\n        return allRoutesJSON;\r\n    }\r\n    static getAllTimetablesJSON() {\r\n        return allTimetablesJSON;\r\n    }\r\n    static async loadDataAndInitialize() {\r\n        await loadData();\r\n    }\r\n    static async loadDataOnly() {\r\n        await loadDataOnly();\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// End load data.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//export default {getAllStations, getAllRoutes, getAllTimetables, getAllStationsJSON, getAllRoutesJSON, getAllTimetablesJSON, loadData};\r\nexport default MyDatabase;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/loadData.js","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 5\n// module chunks = 0","import OptimalRoutesCollection from './../optimalRoutesCollection';\r\nimport MyDatabase from './../loadData';\r\nimport ApiConfig from './../apiConfig';\r\nvar apiPublicTransportServer = ApiConfig.apiPublicTransportServer;\r\nimport PointsHistoryStorage from './pointsHistoryStorage';\r\n\r\n//import './install-service-worker.js';\r\n\r\nif (navigator.onLine === undefined || navigator.onLine === false){\r\n    MyDatabase.loadDataAndInitialize();\r\n}\r\nelse {\r\n    MyDatabase.loadDataOnly();\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Client.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nclass AppClient {\r\n    /*static isStartFinalPointsSelected() {\r\n        return AppClient.startOptimalRoutePoint != null && AppClient.finalOptimalRoutePoint != null;\r\n    }\r\n    static countWayButtonClicked = false;\r\n    static isCountWayButtonClicked() {\r\n        return AppClient.countWayButtonClicked;\r\n    }*/\r\n\r\n    static startOptimalRoutePoint = null;\r\n    static finalOptimalRoutePoint = null;\r\n    static myCurrentFindedPosition = null;\r\n\r\n    static findedOptimalWays = null;\r\n    /*static totalTimePercent = 1;\r\n    static totalGoingTimePercent = 1;\r\n    static totalTransportChangingCountPercent = 1;*/\r\n\r\n    static minimalTimeSeconds = 0;\r\n    static minimalGoingTimeSeconds = 0;\r\n    static minimalTransportChangingCount = 0;\r\n\r\n\r\n    static fromPosition = null;\r\n    static toPosition = null;\r\n    static myStartTime = 0;\r\n    static types = [\"bus\", \"trolleybus\"];\r\n    static my_speed = 5;\r\n    static my_dopTimeMinutes = 2;\r\n\r\n\r\n    // Find optimal ways between two points. The start time, reserved time, going speed and transport types are known.\r\n    static async findWays(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr) {\r\n        var findedOptimalWays = null;\r\n        try { // Пробуем получить оптимальные пути с сервера.\r\n            findedOptimalWays = await getCountedOnServerWays(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr);\r\n        } catch (e) { // Иначе выполняем все расчеты на клиенте.\r\n            findedOptimalWays = await getCountedOnClientWays(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr);\r\n        } finally{\r\n            if (findedOptimalWays != null && findedOptimalWays.length !== 0) {\r\n                AppClient.findedOptimalWays = findedOptimalWays;\r\n\r\n                AppClient.minimalTimeSeconds = parseFloat(AppClient.findedOptimalWays[0].totalTimeSeconds);\r\n                AppClient.minimalGoingTimeSeconds = parseFloat(AppClient.findedOptimalWays[0].totalGoingTimeSeconds);\r\n                AppClient.minimalTransportChangingCount = parseFloat(AppClient.findedOptimalWays[0].totalTransportChangingCount);\r\n                for (let i = 1; i < AppClient.findedOptimalWays.length; i++) {\r\n                    if (parseFloat(AppClient.findedOptimalWays[i].totalTimeSeconds) < AppClient.minimalTimeSeconds) AppClient.minimalTimeSeconds = parseFloat(AppClient.findedOptimalWays[i].totalTimeSeconds);\r\n                    if (parseFloat(AppClient.findedOptimalWays[i].totalGoingTimeSeconds) < AppClient.minimalGoingTimeSeconds) AppClient.minimalGoingTimeSeconds = parseFloat(AppClient.findedOptimalWays[i].totalGoingTimeSeconds);\r\n                    if (parseFloat(AppClient.findedOptimalWays[i].totalTransportChangingCount) < AppClient.minimalTransportChangingCount) AppClient.minimalTransportChangingCount = parseFloat(AppClient.findedOptimalWays[i].totalTransportChangingCount);\r\n                }\r\n                if (AppClient.minimalTransportChangingCount < 1) AppClient.minimalTransportChangingCount = 1;\r\n            }\r\n            return findedOptimalWays;\r\n        }\r\n    }\r\n\r\n    // Sort the finded ways with the importance of each criterion.\r\n    static customizeFindedOptimalWaysStart(totalTimePercentValue, totalGoingTimePercentValue, totalTransportChangingCountPercentValue) {\r\n        if (AppClient.findedOptimalWays != null) {\r\n            /*AppClient.totalTimePercent = totalTimePercentValue;\r\n            AppClient.totalGoingTimePercent = totalGoingTimePercentValue;\r\n            AppClient.totalTransportChangingCountPercent = totalTransportChangingCountPercentValue;*/\r\n\r\n            let sortedArr = [];\r\n            let newSortedFindedWays = [];\r\n\r\n            let tmpTransportChangingCountEffictivity = 0;\r\n            let max_rank = 0;\r\n            let index = -1;\r\n            for (let j = 0; j < AppClient.findedOptimalWays.length/* && j < 3*/; j++) {\r\n                max_rank = 0;//!!!\r\n                index = -1;\r\n                for (let i = 0; i < AppClient.findedOptimalWays.length; i++) {\r\n                    if (sortedArr.indexOf(i) === -1) {\r\n                        tmpTransportChangingCountEffictivity = parseFloat(AppClient.findedOptimalWays[i].totalTransportChangingCount) === 0 ? 1 : (AppClient.minimalTransportChangingCount / parseFloat(AppClient.findedOptimalWays[i].totalTransportChangingCount));\r\n                        var tmp_rank = AppClient.minimalTimeSeconds / parseFloat(AppClient.findedOptimalWays[i].totalTimeSeconds) * totalTimePercentValue + AppClient.minimalGoingTimeSeconds / parseFloat(AppClient.findedOptimalWays[i].totalGoingTimeSeconds) * totalGoingTimePercentValue + tmpTransportChangingCountEffictivity * totalTransportChangingCountPercentValue;\r\n                        if (tmp_rank >= max_rank) {\r\n                            max_rank = tmp_rank;\r\n                            index = i;\r\n                        }\r\n                    }\r\n                }\r\n                if (index !== -1) {\r\n                    sortedArr.push(index);\r\n                }\r\n            }\r\n            for (let i = 0, n = sortedArr.length, sortedIndex = sortedArr[0]; i < n; sortedIndex = sortedArr[++i]) {\r\n                newSortedFindedWays.push(AppClient.findedOptimalWays[sortedIndex]);\r\n            }\r\n            AppClient.findedOptimalWays = newSortedFindedWays;\r\n\r\n            return AppClient.findedOptimalWays;\r\n        }\r\n        else {\r\n            throw new Error('Can`t customize optimal ways, because it`s not finded yet.');\r\n        }\r\n    }\r\n\r\n    static async findCurrentDestinationCoords() {\r\n        if (navigator.geolocation) {\r\n            async function getCurrentPosition() {\r\n                var promise = new Promise(function (resolve, reject) {\r\n                    navigator.geolocation.getCurrentPosition(resolve, reject);\r\n                });\r\n                return await promise;\r\n            }\r\n\r\n            var position = await getCurrentPosition();\r\n            if (position === undefined || position == null) return null;\r\n\r\n            var findedLat = parseFloat(position.coords.latitude.toFixed(4));\r\n            var findedLng = parseFloat(position.coords.longitude.toFixed(4));\r\n\r\n            localStorage[\"lastCnownPositionCoords\"] = findedLat + \",\" + findedLng;\r\n\r\n            let coords = {lat: findedLat, lng: findedLng};\r\n            var lastCnownPositionCoordsDescription = await AppClient.getDesinationDescription(coords);\r\n            if (lastCnownPositionCoordsDescription == null) {\r\n                let searchingPoint = await PointsHistoryStorage.tryFindByCoords(coords);\r\n                if (searchingPoint != null) {\r\n                    lastCnownPositionCoordsDescription = searchingPoint.description;\r\n                }\r\n                else {\r\n                    lastCnownPositionCoordsDescription = \"[\" + findedLat + \", \" + findedLng + \"]\";\r\n                }\r\n            }\r\n            localStorage[\"lastCnownPositionCoordsDescription\"] = lastCnownPositionCoordsDescription;\r\n\r\n            var resultCoords = { lat: findedLat, lng: findedLng };\r\n\r\n            return resultCoords;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    static async findPointsByOsmGeocodingApi(strReq) {\r\n        try {\r\n            const data = await getJsonFromUrl(\"https://nominatim.openstreetmap.org/search?q=\" + strReq + \"&format=json\");\r\n            if (data != null && data.length !== 0) {\r\n                let resultPoints = [];\r\n                for (let i = 0, n = data.length, currentPoint = data[0]; i < n; currentPoint = data[++i]) {\r\n                    resultPoints.push({\r\n                        coords: { lat: parseFloat(currentPoint.lat), lng: parseFloat(currentPoint.lon)},\r\n                        description: currentPoint.display_name\r\n                    });\r\n                }\r\n                PointsHistoryStorage.tryPush(resultPoints[0]);\r\n                return resultPoints;\r\n            }\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n    static async getDesinationDescription(coords) {\r\n        try {\r\n            const findedPoints = await AppClient.findPointsByOsmGeocodingApi(coords.lat + \",\" + coords.lng);\r\n            if (findedPoints != null) {\r\n                return findedPoints[0].description;\r\n            }\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction strToCoords(str) {\r\n    if (str === undefined || str == null) return undefined;\r\n    var tmp = str.split(',');\r\n    var myLat = parseFloat(tmp[0]);\r\n    var myLng = parseFloat(tmp[1]);\r\n    if (myLat >= -90 && myLat <= 90 && myLng >= -180 && myLng <= 180) return { lat: myLat, lng: myLng };\r\n    else return undefined;\r\n}\r\nfunction strToSeconds(str) {\r\n    if (str === undefined || str == null) return undefined;\r\n    var tmp = str.split(':');\r\n    var hours = parseInt(tmp[0], 10);\r\n    var minutes = parseInt(tmp[1], 10);\r\n    if (hours >= 0 && hours < 24 && minutes >= 0 && minutes < 60) return 3600 * hours + 60 * minutes;\r\n    else return undefined;\r\n}\r\n\r\nasync function getJsonFromUrl(strReq) {\r\n    var response = await fetch(strReq);\r\n    return await response.json();\r\n}\r\n\r\nasync function getCountedOnServerWays(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr) {\r\n    var paramsStr = \"?from=\" + fromPositionStr + \"&to=\" + toPositionStr + \"&startTime=\" + myStartTimeStr + \"&dopTimeMinutes=\" + my_dopTimeMinutes + \"&goingSpeed=\" + my_speed + \"&transportTypes=\" + typesStr;\r\n        \r\n    var data = await getJsonFromUrl(apiPublicTransportServer + \"optimalRoute\" + paramsStr);\r\n    \r\n    AppClient.findedOptimalWays = data;\r\n    \r\n    console.log(\"Finded \" + AppClient.findedOptimalWays.length + \" optimal routes.\");\r\n    return data;\r\n}\r\n\r\nasync function getCountedOnClientWays(fromPositionStr, toPositionStr, myStartTimeStr, my_dopTimeMinutes, my_speed, typesStr) {\r\n    console.log(\"Start local counting...\");\r\n\r\n    await MyDatabase.loadDataAndInitialize();\r\n\r\n    var startOptimalRoutePoint = strToCoords(fromPositionStr);\r\n    var finalOptimalRoutePoint = strToCoords(toPositionStr);\r\n    var myStartTime = strToSeconds(myStartTimeStr);\r\n\r\n    if (startOptimalRoutePoint === undefined || finalOptimalRoutePoint === undefined || myStartTime === undefined) return null;\r\n\r\n    var types = null;\r\n    if (typesStr !== undefined) types = typesStr.split(',');\r\n    if (types === undefined || types == null) types = [\"bus\", \"trolleybus\"];\r\n\r\n    var startInitializingMoment = Date.now();\r\n    var res = new OptimalRoutesCollection(startOptimalRoutePoint, finalOptimalRoutePoint, myStartTime, types, parseFloat(my_speed), parseFloat(my_dopTimeMinutes));\r\n    AppClient.findedOptimalWays = res.getOptimalWays();\r\n    \r\n    console.log(\"Finded \" + AppClient.findedOptimalWays.length + \" optimal routes. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\r\n\r\n    return AppClient.findedOptimalWays;\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// End client.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport default AppClient;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/client/client.js","import GeoCoords from './../geoCoords';\r\n\r\nconst dbName = \"public_transport\";\r\nconst storeName = \"points_history\";\r\n\r\nasync function getPointsHistoryStorageConnection() {\r\n    let promise = new Promise(function (resolve, reject) {\r\n        let request = indexedDB.open(dbName, 1);\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n        request.onsuccess = function(event) {\r\n            resolve(event.target.result);\r\n        }\r\n        request.onupgradeneeded = async function(event) {\r\n            let db = event.target.result;\r\n            let objectStore = db.createObjectStore(storeName, { keyPath: \"key\", autoIncrement:true});\r\n            objectStore.createIndex(\"description\", \"description\", { unique: true });\r\n            objectStore.createIndex(\"lat\", \"lat\", { unique: false });\r\n            objectStore.createIndex(\"lng\", \"lng\", { unique: false });\r\n            \r\n            let result = await getPointsHistoryStorageConnection();\r\n            resolve(result);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\n\r\nasync function getAllPoints() {\r\n    let promise = new Promise(async function (resolve, reject) {\r\n        let items = [];\r\n        let db = await getPointsHistoryStorageConnection();\r\n        //console.log(db);\r\n        let transaction = db.transaction([storeName]);\r\n        let objectStore = transaction.objectStore(storeName);\r\n\r\n        //let request = objectStore.getAll();\r\n        \r\n        var request = objectStore.openCursor();\r\n        request.onsuccess = function(evt) {                    \r\n            var cursor = evt.target.result;\r\n            if (cursor) {\r\n                items.push(cursor.value);\r\n                cursor.continue();\r\n            }\r\n            else resolve(items);\r\n        };\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\nasync function tryFindByCoords(coords) {\r\n    const pointsHistory = await getAllPoints();\r\n    let candidate = null;\r\n    for (let i = 0, n = pointsHistory.length, currentPoint = pointsHistory[0], findedDistance = 150; i < n; currentPoint = pointsHistory[++i]) {\r\n        const currentDistance = GeoCoords.distance(coords, {lat: currentPoint.lat, lng: currentPoint.lng});\r\n        if (currentDistance < findedDistance) {\r\n            findedDistance = currentDistance;\r\n            candidate = currentPoint;\r\n        }\r\n    }\r\n    return candidate;\r\n}\r\nasync function tryPush(point) {\r\n    const pointsHistory = await getAllPoints();\r\n    for (let i = 0, n = pointsHistory.length, currentPoint = pointsHistory[0]; i < n; currentPoint = pointsHistory[++i]) {\r\n        if (GeoCoords.distance(point.coords, {lat: currentPoint.lat, lng: currentPoint.lng}) < 50) return null;\r\n    }\r\n\r\n    let promise = new Promise(async function (resolve, reject) {\r\n        let db = await getPointsHistoryStorageConnection();\r\n        //console.log(db);\r\n        let transaction = db.transaction([storeName], \"readwrite\");\r\n        let objectStore = transaction.objectStore(storeName);\r\n        let request = objectStore.add({\r\n            lat: point.coords.lat,\r\n            lng: point.coords.lng,\r\n            description: point.description\r\n        });\r\n        request.onerror = function(event) {\r\n            reject(event.target.error);\r\n        }\r\n        request.onsuccess = function(event) {\r\n            resolve(event.target.result);\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\n\r\n\r\nclass PointsHistoryStorage {\r\n    static async getAllPoints() {\r\n        return await getAllPoints();\r\n    }\r\n    static async tryPush(point) {\r\n        return await tryPush(point);\r\n    }\r\n    static async tryFindByCoords(coords) {\r\n        return await tryFindByCoords(coords);\r\n    }\r\n}\r\n\r\nexport default PointsHistoryStorage;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/client/pointsHistoryStorage.js","//require('./loadData');\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// Initailize.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n//global.initialized = false;\r\n\r\n\r\n\r\nfunction getNextStation(currentStation) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let t = 0, nn = this.stations[j].length; t < nn; t++) {\r\n            if (this.stations[j][t] === currentStation) {\r\n                if (t + 1 !== nn) return this.stations[j][t + 1];\r\n                else return null;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getPreviousStation(currentStation) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let t = 0, nn = this.stations[j].length; t < nn; t++) {\r\n            if (this.stations[j][t] === currentStation) {\r\n                if (t !== nn) return this.stations[j][t - 1];\r\n                else return null;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction getTimetable(station) {\r\n    for (let j = 0; j <= 1; j++) {\r\n        for (let i = 0, n = this.stations[j].length; i < n; i++) {\r\n            if (this.stations[j][i] === station) {\r\n                return this.timetables[j][i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction findTimeAfter(time) {\r\n    var dateTmp = new Date();\r\n    dateTmp.setMinutes(0);\r\n    dateTmp.setHours(0);\r\n    dateTmp.setSeconds(time);\r\n    var day = dateTmp.getDay();\r\n    //foreach (Table t in table)\r\n    for (let kkk = 0, mnkk = this.table.length, t = this.table[0]; kkk < mnkk; t = this.table[++kkk]) {\r\n        if (t.days.includes(day)) {\r\n\r\n            //foreach (SimpleTime st in t.times)\r\n            for (let iik = 0, mnii = t.times.length, st = t.times[0], stTime; iik < mnii; st = t.times[++iik]) {\r\n                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\r\n                //\r\n                stTime = st.hour * 3600 + st.minute * 60;\r\n                if (stTime >= time/*.Second + time.Minute * 60 + time.Hour * 3600*/ /*time.Hour >= st.hour && time.Minute >= st.minute*/) {\r\n                    //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\r\n                    return stTime - time/*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/;\r\n                }\r\n            }\r\n            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time/*TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600)*/ + 86400;\r\n            break;\r\n        }\r\n    }\r\n    return 2160000000;\r\n    //throw new Exception();\r\n}\r\nfunction findTimeBefore(time) {\r\n    var dateTmp = new Date();\r\n    dateTmp.setMinutes(0);\r\n    dateTmp.setHours(0);\r\n    dateTmp.setSeconds(time);\r\n    var day = dateTmp.getDay();\r\n    for (let kkk = 0, mnkk = this.table.length, t = this.table[0], ok = false, st; kkk < mnkk; t = this.table[++kkk]) {\r\n        if (t.days.includes(day)) {\r\n            ok = false;\r\n            st = null;\r\n            for (let iik = 0, mnii = t.times.length, stt = t.times[0]; iik < mnii; stt = t.times[++iik]) {\r\n                //MessageBox.Show(\"Проверяем: прибытие в \" + TimeSpan.FromMinutes(st.hour * 60 + st.minute).ToString()+\", мы в \"+ TimeSpan.FromSeconds(time.Second + time.Minute * 60 + time.Hour * 3600).ToString());\r\n                //\r\n                if (stt.hour * 3600 + stt.minute * 60 <= time/*time.Hour >= st.hour && time.Minute >= st.minute*/) {\r\n                    ok = true;\r\n                    st = stt;\r\n                    //MessageBox.Show(\"Ближайшее время: \" + st.ToString());\r\n                }\r\n                else break;\r\n            }\r\n            if (ok) return st.hour * 3600 + st.minute * 60 - time;\r\n            if (t.times.length !== 0) return t.times[0].hour * 3600 + t.times[0].minute * 60 - time - 86400;\r\n            break;\r\n        }\r\n    }\r\n    return 0;//TimeSpan.FromDays(0/*-25000*/);\r\n    //throw new Exception();\r\n}\r\n\r\n\r\nfunction initialize(allStations, allRoutes, allTimetables) {\r\n    //alert(allStations.length);\r\n    //alert(allRoutes.length);\r\n    //alert(allTimetables.length);\r\n\r\n    console.log(\"Start initializing...\");\r\n    var startInitializingMoment = Date.now();\r\n\r\n    var tmpUsedStations = [];\r\n\r\n    function bindRoutesStationsTimetables(station, tmpArr, tabArr, rr) {\r\n        if (station.routes == null) station.routes = [];\r\n        //console.log(station.routes);//!!!\r\n        if (!(station.routes.includes(rr))) station.routes.push(rr);\r\n        tmpArr.push(station);\r\n\r\n        var tmp = allTimetables.find(function (element, index, array) {\r\n            return element.stationCode === station.hashcode && element.routeCode === rr.hashcode;\r\n        });\r\n        var tmpTab = (tmp == null) ? null : tmp;\r\n\r\n        tabArr.push(tmpTab);\r\n    }\r\n\r\n    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n        if (currentStation.routesCodes == null || currentStation.routesCodes.length === 0) {\r\n            allStations.splice(i, 1);\r\n            n = allStations.length;\r\n        }\r\n        else i++;\r\n    }\r\n\r\n    for (let i = 0, n = allRoutes.length, rr = allRoutes[0]; i < n; rr = allRoutes[++i]) {\r\n\r\n        rr.getNextStation = getNextStation; \r\n        rr.getPreviousStation = getPreviousStation;\r\n        rr.getTimetable = getTimetable;\r\n\r\n        if (rr.stationsCodes == null || rr.stationsCodes.length === 0) continue;\r\n\r\n        try {\r\n            //if (rr.stationsCodes[rr.stationsCodes.Length - 1] != ']') continue;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n\r\n            rr.stations = [[],[]];\r\n            rr.timetables = [[],[]];\r\n\r\n\r\n\r\n            for (let index = 0, tmpArr = [], tabArr = [] ; index <= 1; index++) {\r\n                var rr_stationsCodes = rr.stationsCodes;\r\n                if (rr_stationsCodes[index] == null || rr_stationsCodes[index].length === 0) continue;\r\n                for (let j = 0, m = rr_stationsCodes[index].length, stationCode = rr_stationsCodes[index][0]; j < m; stationCode = rr_stationsCodes[index][++j]) {\r\n                    var tmpUsed = false;\r\n                    for (let k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\r\n                        if (station != null && station.hashcode === stationCode) {\r\n                            bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\r\n                            tmpUsed = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!tmpUsed) {\r\n                        for (let k = 0, mn = allStations.length, station = allStations[0]; k < mn; station = allStations[++k]) {\r\n                            if (station != null && station.hashcode === stationCode) {\r\n                                bindRoutesStationsTimetables(station, tmpArr, tabArr, rr);\r\n                                if (!tmpUsedStations.includes(station)) tmpUsedStations.push(station);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                rr.stations[index] = tmpArr;\r\n                rr.timetables[index] = tabArr;\r\n\r\n            }\r\n        }\r\n        catch (ex) {\r\n            console.log(ex/*.message*/);\r\n            continue;\r\n        }\r\n    }\r\n\r\n    for (let i = 0, n = allTimetables.length, timetable = allTimetables[0]; i < n; timetable = allTimetables[++i]) {\r\n        timetable.findTimeAfter = findTimeAfter;\r\n        timetable.findTimeBefore = findTimeBefore;\r\n    }\r\n\r\n    //...\r\n    /*\r\n    for (let i = 0, n = allStations.length, currentStation = allStations[0]; i < n; currentStation = allStations[i]) {\r\n        if (currentStation.routes == undefined || currentStation.routes == null || currentStation.routes.length == 0) {\r\n            allStations.splice(i, 1);\r\n            n = allStations.length;\r\n        }\r\n        else i++;\r\n    }\r\n    */\r\n\r\n    console.log(\"Initialized. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\r\n    //console.log(\"\\n\\n\" + JSON.stringify(allTimetables[0]) + \"\\n\\n\");\r\n    //alert(distance({ lat: allStations[0].xCoord, lng: allStations[0].yCoord }, { lat: allStations[5].xCoord, lng: allStations[5].yCoord }));\r\n\r\n\r\n    //for (let t = 0; t < 1000; t++) var ttt = GetStationsAround(allStations[0].coords, 30000).length;\r\n    //console.log(\"test. Time = \" + (Date.now() - startInitializingMoment) + \" ms.\");\r\n\r\n\r\n    //global.initialized = true;\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n// End initailize.\r\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\nexport default initialize;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/initialize.js","import Points from './points';\r\nimport GeoCoords from './geoCoords';\r\nvar distance = GeoCoords.distance;\r\n//import IgnoringFragments from './ignoringFragments';\r\n\r\n//import {getAllStations, getAllRoutes, getAllTimetables, getAllStationsJSON, getAllRoutesJSON, getAllTimetablesJSON, loadData} from './loadData';\r\nimport MyDatabase from './loadData';\r\n\r\nvar allStations = null;\r\n\r\nfunction getStationsAround(coords, radius) {\r\n    if(allStations == null) allStations = MyDatabase.getAllStations();\r\n    var result = [];\r\n    for (var i = 0, n = allStations.length, s = allStations[0]; i < n; s = allStations[++i]) {\r\n        if (s != null && distance(s.coords, coords) < radius) result.push(s);\r\n    }\r\n    return result;\r\n}\r\n\r\nclass OptimalRoute {\r\n    constructor(nowPos, needPos, time, types, goingSpeed, dopTimeMinutes, ignoringRoutesAdd, ignoringList) {\r\n        if (ignoringRoutesAdd != null) this.ignoringRoutes = ignoringRoutesAdd;\r\n        else this.ignoringRoutes = [];\r\n\r\n        this.points = [];\r\n\r\n        this.needPos = needPos;\r\n        this.nowPos = nowPos;\r\n        this.goingSpeed = goingSpeed;\r\n        this.time = time;\r\n        var reservedTimeSeconds = 60 * dopTimeMinutes;\r\n\r\n        this.types = types;\r\n\r\n        this.myIgnoringFragments = null;\r\n        //if (ignoringList != null) this.myIgnoringFragments = new IgnoringFragments(ignoringList);\r\n        //else this.myIgnoringFragments = new IgnoringFragments();\r\n\r\n        var myPoints = new Points(nowPos, needPos);\r\n        // Получим \"начальный\" список станций:\r\n        var stationsList = getStationsAround(myPoints.startPoint.coords, distance(myPoints.startPoint.coords, myPoints.finalPoint.coords));\r\n        myPoints.fillStartData(stationsList, goingSpeed, reservedTimeSeconds, this.myIgnoringFragments);\r\n\r\n        // Находим кратчайшие пути до всех вершин:\r\n        myPoints.countShortWay(this.ignoringRoutes, this.myIgnoringFragments, time, types, goingSpeed, reservedTimeSeconds);\r\n\r\n        var tmpP = myPoints.finalPoint;\r\n        this.points.push(tmpP.toString());////\r\n        while (tmpP.previousPoint != null) {\r\n            tmpP = tmpP.previousPoint;//\r\n            this.points.push(tmpP.toString());\r\n            if (tmpP.previousPoint == null && tmpP.coords !== myPoints.startPoint.coords)\r\n                throw new Error(\"Где-то удалилась часть маршрута...\");\r\n        }\r\n\r\n        this.totalTimeSeconds = myPoints.finalPoint.totalTimeSeconds;\r\n        this.totalGoingTime = myPoints.finalPoint.getTotalGoingTime();\r\n        this.totalTransportChangingCount = myPoints.finalPoint.getTotalTransportChangingCount();\r\n\r\n        this.myPoints = myPoints;\r\n\r\n\r\n        this.isVisited = false;\r\n    }\r\n\r\n    setVisited() {\r\n        this.isVisited = true;\r\n    }\r\n\r\n}\r\n\r\nexport default OptimalRoute;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/optimalRoute.js","//import IgnoringFragments from './ignoringFragments';\r\nimport OptimalRoute from './optimalRoute';\r\nimport OptimalWay from './optimalWay';\r\n\r\nclass OptimalRoutesCollection extends Array {\r\n    /*getOptimalWays() {\r\n        var result = [];\r\n        for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n            result.push(new OptimalWay(r));\r\n        }\r\n        return result;\r\n    }*/\r\n    /*selectOptimalRouteWithMinimalMark() {\r\n        var p = null;\r\n        for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n            if (!(t.isVisited)) {\r\n                p = t;\r\n                for (t = this[++i]; i < n; t = this[++i]) {\r\n                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                        p = t;\r\n                    }\r\n                }\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }*/\r\n    constructor(nowPos, needPos, time, types, speed, dopTimeMinutes) {\r\n        super();\r\n        this.getOptimalWays = function() {\r\n            var result = [];\r\n            for (var i = 0, n = this.length, r = this[0]; i < n; r = this[++i]) {\r\n                result.push(new OptimalWay(r));\r\n            }\r\n            return result;\r\n        }\r\n        this.selectOptimalRouteWithMinimalMark = function() {\r\n            var p = null;\r\n            for (var i = 0, n = this.length, t = this[0]; i < n; t = this[++i]) {\r\n                if (!(t.isVisited)) {\r\n                    p = t;\r\n                    for (t = this[++i]; i < n; t = this[++i]) {\r\n                        if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                            p = t;\r\n                        }\r\n                    }\r\n                    return p;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        this.push(new OptimalRoute(nowPos, needPos, time, types, speed, dopTimeMinutes));\r\n\r\n        var ignoringRoutes = [];\r\n\r\n        //var ignoringFragments = new IgnoringFragments();\r\n        \r\n        for (var selectedOptimalRoute = this[0]; selectedOptimalRoute != null; selectedOptimalRoute.setVisited(), selectedOptimalRoute = this.selectOptimalRouteWithMinimalMark()) {\r\n            var ddd = 0.25;\r\n\r\n            ignoringRoutes = [];\r\n            // Проходим по всем ребрам выбранного пути и строим новые маршруты при удалении ребер:\r\n            for (var tmpP = selectedOptimalRoute.myPoints.finalPoint; tmpP.previousPoint != null; tmpP = tmpP.previousPoint) {\r\n                if (tmpP.fromWhichRoute != null && !ignoringRoutes.includes(tmpP.fromWhichRoute)) ignoringRoutes.push(tmpP.fromWhichRoute);\r\n            }\r\n            for (var i = 0, n = ignoringRoutes.length, r = ignoringRoutes[0]; i < n; r = ignoringRoutes[++i]) {\r\n                if (selectedOptimalRoute.ignoringRoutes.includes(r)) continue;\r\n                var ignoringRoutesAdd = [];\r\n                ignoringRoutesAdd = ignoringRoutesAdd.concat(selectedOptimalRoute.ignoringRoutes);\r\n                ignoringRoutesAdd.push(r);\r\n                var tmpOptimalRoute = new OptimalRoute(nowPos, needPos, time, types, speed, dopTimeMinutes, ignoringRoutesAdd);\r\n\r\n                if (tmpOptimalRoute.totalTimeSeconds <= this[0].totalTimeSeconds / ddd) {\r\n                    var tmpJSON = JSON.stringify(tmpOptimalRoute.points);\r\n                    var ok = false;\r\n                    for (var j = 0, m = this.length, opt = this[0]; j < m; opt = this[++j]) {\r\n                        if (JSON.stringify(opt.points) === tmpJSON) {\r\n                            ok = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (ok) continue;\r\n                    this.push(tmpOptimalRoute);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport default OptimalRoutesCollection;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/optimalRoutesCollection.js","import WayPoint from './wayPoint';\r\n\r\nclass OptimalWay {\r\n    constructor(optimalRoute) {\r\n        this.totalTimeSeconds = optimalRoute.totalTimeSeconds;\r\n        this.totalGoingTimeSeconds = optimalRoute.totalGoingTime;\r\n        this.totalTransportChangingCount = optimalRoute.totalTransportChangingCount;\r\n        this.points = [];\r\n\r\n        for (var tmpP = optimalRoute.myPoints.finalPoint; tmpP != null; tmpP = tmpP.previousPoint) {\r\n            this.points.push(new WayPoint(tmpP.totalTimeSeconds, tmpP.station, tmpP.fromWhichRoute, tmpP.coords));\r\n        }\r\n        this.points.reverse();\r\n    }\r\n\r\n}\r\n\r\nexport default OptimalWay;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/optimalWay.js","class Point {\r\n    constructor(totalTimeSeconds, station_or_crds, fromWhichStation, fromWhichRoute) {\r\n        if (station_or_crds.hashcode !== undefined) {\r\n            this.station = station_or_crds;\r\n            this.stationCode = station_or_crds.hashcode;\r\n            station_or_crds.point = this;\r\n            this.coords = station_or_crds.coords;\r\n        }\r\n        else {\r\n            this.coords = station_or_crds;\r\n            this.station = null;\r\n            this.stationCode = null;\r\n        }\r\n        this.totalTimeSeconds = totalTimeSeconds;\r\n        this.fromWhichStation = fromWhichStation;\r\n        this.fromWhichRoute = fromWhichRoute;\r\n\r\n        this.isVisited = false;\r\n\r\n        this.previousPoint = null;\r\n    }\r\n    tryUpdate(totalTimeSeconds, previousPoint, fromWhichStation, fromWhichRoute) {\r\n        if (totalTimeSeconds < this.totalTimeSeconds) {\r\n            this.fromWhichRoute = fromWhichRoute;\r\n            this.previousPoint = previousPoint;\r\n            this.totalTimeSeconds = totalTimeSeconds;\r\n            this.fromWhichStation = fromWhichStation;\r\n\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    setVisited() {\r\n        this.isVisited = true;\r\n    }\r\n    toString() {\r\n        var to, tr; //, from, p;\r\n        //if (this.fromWhichStation != null) from = this.fromWhichStation.name;\r\n        //else from = \"null\";\r\n        if (this.station != null) to = this.station.name;\r\n        else to = \"null\";\r\n        if (this.fromWhichRoute != null) tr = this.fromWhichRoute.type + \" \" + this.fromWhichRoute.number + \" \" + this.fromWhichRoute.from + \" - \" + this.fromWhichRoute.to;\r\n        else tr = \"пешком\";\r\n        //if (this.previousPoint != null) p = this.previousPoint.toString();\r\n        //else p = \"null\";\r\n        return /*p+\" -->> */\"(\" + this.totalTimeSeconds + \") \" + to + \" (\" + tr + \")\"; // from \" + from + \" to\r\n    }\r\n    getTotalGoingTime() {\r\n        var goingTime = 0;\r\n        var tmpP = this;\r\n        //this.points.Add(tmpP.ToString());\r\n        while (tmpP.previousPoint != null) {\r\n            if (tmpP.fromWhichRoute == null /*&& tmpP.fromWhichRoute.hashcode == null*/) goingTime += tmpP.totalTimeSeconds - tmpP.previousPoint.totalTimeSeconds;\r\n            tmpP = tmpP.previousPoint;\r\n        }\r\n        return goingTime;\r\n    }\r\n    getTotalTransportChangingCount() {\r\n        var result = 0;\r\n        var tmpP = this;\r\n        //this.points.Add(tmpP.ToString());\r\n        while (tmpP.previousPoint != null) {\r\n            if (tmpP.fromWhichRoute != null && tmpP.fromWhichRoute.hashcode != null && tmpP.fromWhichRoute !== tmpP.previousPoint.fromWhichRoute) result++;\r\n            tmpP = tmpP.previousPoint;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\nexport default Point;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/point.js","import Point from './point';\r\nimport GeoCoords from './geoCoords';\r\nvar distance = GeoCoords.distance;\r\n\r\n\r\nfunction getTimeForGoingTo(distance, goingSpeed) {\r\n    return Math.floor(distance / (goingSpeed / 3.6));\r\n}\r\n\r\nconst TableType = { table: 1, periodic: 2 };\r\n\r\nclass Points {\r\n    constructor(nowPos, needPos) {\r\n        this.collection = [];\r\n        this.startPoint = new Point(0, nowPos, null, null);\r\n        this.finalPoint = new Point(2160000000, needPos, null, null);\r\n        this.currentSelectedPoint = null;\r\n    }\r\n    findElement(station_or_point) {\r\n        if (station_or_point.hashcode != null) {\r\n            if (station_or_point.point != null) return station_or_point.point;\r\n            var newCreatdPoint = new Point(2160000000, station_or_point, null, null);\r\n            this.collection.push(newCreatdPoint);\r\n            return newCreatdPoint;\r\n        }\r\n        else {\r\n            for (var i = 0, n = this.collection.length, p = this.collection[0]; i < n; p = this.collection[++i]) {\r\n                if (p.coords === station_or_point.coords && p.stationCode === station_or_point.stationCode) return p;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n    fillStartData(stationsList, goingSpeed, reservedTime, myIgnoringFragments) {\r\n        this.finalPoint.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, this.finalPoint.coords), goingSpeed) + 1200/*+ TimeSpan.FromMinutes(20)*/, this.startPoint, null, null);\r\n        for (var i = 0, n = stationsList.length, st = stationsList[0]; i < n; st = stationsList[++i]) {\r\n            if (myIgnoringFragments != null && myIgnoringFragments.contains(st.hashcode, null, null)) continue;\r\n\r\n            var add = new Point(2160000000, st, null, null);\r\n            add.tryUpdate(getTimeForGoingTo(distance(this.startPoint.coords, st.coords), goingSpeed) + reservedTime, this.startPoint, null, null);\r\n            this.collection.push(add);\r\n        }\r\n    }\r\n    getNextUnvisitedPoint() {\r\n        if (this.currentSelectedPoint != null) this.currentSelectedPoint.setVisited();\r\n\r\n        this.currentSelectedPoint = this.selectPointWithMinimalMark();\r\n\r\n        return this.currentSelectedPoint;\r\n    }\r\n    selectPointWithMinimalMark() {\r\n        var p = null;\r\n        for (var i = 0, n = this.collection.length, t = this.collection[0]; i < n; t = this.collection[++i]) {\r\n            if (!(t.isVisited)) {\r\n                p = t;\r\n                for (t = this.collection[++i]; i < n; t = this.collection[++i]) {\r\n                    if (!(t.isVisited) && t.totalTimeSeconds < p.totalTimeSeconds) {\r\n                        p = t;\r\n                    }\r\n                }\r\n                return p;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    countShortWay(ignoringRoutes, myIgnoringFragments, time, types, speed, reservedTime) {\r\n        //TimeSpan overLimitResedvedTime = TimeSpan.FromMinutes(20);\r\n\r\n        for (var selectedPoint = this.getNextUnvisitedPoint(), selectedPointStation, selectedPointTotalTimeSeconds, selectedPointStationHashcode, selectedPointFromWhichRoute, momentWhenComingToStation, routesOnStation, selectedPointCoords; selectedPoint != null; selectedPoint = this.getNextUnvisitedPoint()) {\r\n            //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n            selectedPointTotalTimeSeconds = selectedPoint.totalTimeSeconds;\r\n            if (selectedPointTotalTimeSeconds > this.finalPoint.totalTimeSeconds/* + overLimitResedvedTime*/) //... Пропускаем и удаляем, если значение метки превышает минимальное время до пункта назначения.\r\n            {\r\n                break;\r\n            }\r\n            selectedPointStation = selectedPoint.station;\r\n            selectedPointStationHashcode = selectedPointStation.hashcode;\r\n            selectedPointFromWhichRoute = selectedPoint.fromWhichRoute;\r\n            if (selectedPointStation != null) {\r\n                // Момент, когда мы прибудем на остановку:\r\n                momentWhenComingToStation = time + selectedPointTotalTimeSeconds;\r\n                // Загружаем маршруты, проходящие через остановку:\r\n                routesOnStation = null;// = routesOnStation = Database.GetRoutesOnStation(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);\r\n                if (selectedPointStation.routes != null) routesOnStation = selectedPointStation.routes;\r\n                else continue;\r\n\r\n                for (var i = 0, n = routesOnStation.length, selectedRoute = routesOnStation[0], nextStation; i < n; selectedRoute = routesOnStation[++i]) {\r\n                    if (ignoringRoutes != null && ignoringRoutes.includes(selectedRoute)) continue;\r\n                    if (types.includes(selectedRoute.type)) {\r\n                        // Следующая остановка у данного тран спорта:\r\n                        nextStation = selectedRoute.getNextStation(selectedPointStation);\r\n\r\n                        /*// Код остановки, на которую попадем на данном транспорте:\r\n                        string nextCode = selectedRoute.getNextStationCodeAfter(selectedPointStation.hashcode, canReadDataFromLocalCopy: true);*/\r\n                        if (nextStation/*nextCode*/ != null) // Если остановка не является конечной, то:\r\n                        {\r\n                            // Загружаем расписание:\r\n                            var table = selectedRoute.getTimetable(selectedPointStation);//Database.getTimetable(selectedPointStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\r\n                            // Блокируем попытку попасть указанным транспортом на указанную остановку:\r\n                            if (myIgnoringFragments!= null && myIgnoringFragments.contains(nextStation.hashcode/*nextCode*/, selectedRoute.hashcode, selectedPointStationHashcode)) continue;\r\n\r\n                            if (table.type === TableType.table) // Если это точное расписание, то:\r\n                            {\r\n                                // Минимальный начальный момент, с который можно начинать ожидать посадку:\r\n                                var momentWhenAskingForGoing = momentWhenComingToStation;\r\n\r\n                                // Резервируем дополнительное время, если будем пересаживаться на другой маршрут:\r\n                                //if (selectedPoint.RouteCode == null || selectedPoint.RouteCode != selectedRoute.hashcode) momentWhenAskingForGoing += reservedTime;\r\n                                if (selectedPointFromWhichRoute != null && selectedPointFromWhichRoute !== selectedRoute) momentWhenAskingForGoing += reservedTime;\r\n\r\n                                // Подсчитываем, сколько будем ожидать этот транспорт на остановке:\r\n                                var waitingTime = table.findTimeAfter(momentWhenAskingForGoing);\r\n\r\n                                // Момент, когда мы сядем в транспорт:\r\n                                var momentWhenSitInTransport = momentWhenAskingForGoing + waitingTime;\r\n\r\n                                /*// Следующая остановка у данного транспорта:\r\n                                Station nextStation = Database.GetStationByHashcode(nextCode, databaseMysqlConnection, canReadDataFromLocalCopy: true);*/\r\n\r\n                                // И соответствующее расписание на этой остановке:\r\n                                var tbl = selectedRoute.getTimetable(nextStation);//Database.getTimetable(nextStation.hashcode, selectedRoute.hashcode, databaseMysqlConnection, canReadDataFromLocalCopy: true);\r\n                                \r\n                                // (сколько будем ехать до следующей остановки):\r\n                                var goingOnTransportTime = tbl.findTimeAfter(momentWhenSitInTransport);\r\n                                \r\n                                // Метка времени:\r\n                                var onNextPointtotalTimeSeconds = momentWhenSitInTransport - momentWhenComingToStation + goingOnTransportTime + selectedPointTotalTimeSeconds;\r\n                                \r\n                                if (this.findElement(nextStation).tryUpdate(onNextPointtotalTimeSeconds, selectedPoint, selectedPointStation, selectedRoute)) {\r\n                                    //console.log(\"upd...\");\r\n                                }\r\n                            }\r\n                            else if (table.type === TableType.periodic) {\r\n                                throw new Error();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            selectedPointCoords = selectedPoint.coords;\r\n            // Нет смысла идти пешком \"транзитом\" через остановку:\r\n            if (selectedPointFromWhichRoute == null) continue;\r\n\r\n            // Попробуем пройти пешком до других \"вершин\":\r\n            for (var j = 0, m = this.collection.length, p = this.collection[0], distanceToSelectedPoint, goingTime, newTime; j < m; p = this.collection[++j])\r\n                if (!p.isVisited && p !== selectedPoint) {\r\n                    // Блокируем попытку дойти пешком до указанной остановки:\r\n                    if (myIgnoringFragments != null && myIgnoringFragments.contains(p.stationCode, null, selectedPointStationHashcode)) continue;\r\n\r\n                    distanceToSelectedPoint = distance(selectedPointCoords, p.coords);\r\n                    \r\n                    goingTime = getTimeForGoingTo(distanceToSelectedPoint, speed/*, true, sp*/);\r\n\r\n                    newTime = selectedPointTotalTimeSeconds + goingTime + reservedTime;\r\n                    /*if (p != myFinishPoint)*/ // newTime += reservedTime;\r\n                    \r\n                    if (p.tryUpdate(newTime, selectedPoint, selectedPointStation, null)) {\r\n                        //console.log(\"upd...\");\r\n                    }\r\n                }\r\n\r\n            if (myIgnoringFragments != null && myIgnoringFragments.contains(null, null, selectedPointStationHashcode)) continue;\r\n            \r\n            var tryingNewTime = selectedPointTotalTimeSeconds + getTimeForGoingTo(distance(selectedPointCoords, this.finalPoint.coords), speed);\r\n            if (this.finalPoint.tryUpdate(tryingNewTime, selectedPoint, selectedPointStation, null)) {\r\n                //console.log(\"upd: \" + selectedPointStation.hashcode);\r\n            }\r\n        }\r\n\r\n        // Сокращаем время ходьбы пешком до минимума и избавляемся от \"бессмысленных\" пересадок, сохраняя общее время неизменным:\r\n        var currentPoint = this.finalPoint.previousPoint;\r\n        while (currentPoint !== this.startPoint) {\r\n            var r = currentPoint.fromWhichRoute;\r\n            if (r != null) {\r\n                var previousPoint = currentPoint.previousPoint;\r\n                if (previousPoint !== this.startPoint && previousPoint.fromWhichRoute !== r) // Если на предыдущую остановку мы добрались другим транспортом, то:\r\n                {\r\n                    var previousRouteStation = r.getPreviousStation(previousPoint.station);\r\n                    if (previousRouteStation != null) {\r\n                        var point = previousRouteStation.point;\r\n                        if (point != null && point.isVisited) {\r\n                            var ttt = r.getTimetable(previousRouteStation);\r\n                            if (ttt != null) {\r\n                                //var ddd = time + previousPoint.totalTimeSeconds;\r\n                                //var moment = r.getTimetable(currentPoint.station).findTimeAfter(ddd);\r\n                                //var tmp_time = ttt.findTimeBefore(ddd + moment);\r\n\r\n                                //var momentArriveOnCurrent = previousPoint.totalTimeSeconds + moment;\r\n                                //var momentSittingOnPrevious = momentArriveOnCurrent + tmp_time;\r\n                                /*bool bbb = point.fromWhichRoute != null && point.fromWhichRoute.getTimetable(point.station) != null && point.fromWhichRoute.getTimetable(point.station).findTimeAfter(time + point.totalTimeSeconds) <= previousPoint.totalTimeSeconds + moment + tmp_time;\r\n                                if (bbb)\r\n                                {\r\n                                    previousPoint.fromWhichRoute = r;\r\n                                    previousPoint.previousPoint = point;////!bbb && point.totalTimeSeconds <= momentSittingOnPrevious &&\r\n                                }\r\n                                else */\r\n                                if (/*point.totalGoingTime>=previousPoint.totalGoingTime || */point.totalTimeSeconds <= previousPoint.totalTimeSeconds/* && point.totalGoingTime <= previousPoint.totalGoingTime*/) {\r\n                                    previousPoint.fromWhichRoute = r;\r\n                                    previousPoint.previousPoint = point;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            currentPoint = currentPoint.previousPoint;\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nexport default Points;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/points.js","class WayPoint {\r\n    constructor(time, station, route, coords) {\r\n        this.time = time;\r\n        this.station = station == null ? null : { hashcode: station.hashcode, name: station.name, routes: null, Coords: { lat: station.coords.lat, lng: station.coords.lng } };\r\n        this.route = route == null ? null : { vehicles: [], gpsTrack: null, hashcode: route.hashcode, number: route.number, type: route.type, from: route.from, to: route.to, owner: \"\", stations: null, timetables: null, stationsJSON: null }\r\n        this.coords = coords;\r\n    }\r\n}\r\n\r\nexport default WayPoint;\n\n\n// WEBPACK FOOTER //\n// ./src/modules/wayPoint.js","// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g =\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this;\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime-module.js\n// module id = 15\n// module chunks = 0","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime.js\n// module id = 16\n// module chunks = 0"],"sourceRoot":""}